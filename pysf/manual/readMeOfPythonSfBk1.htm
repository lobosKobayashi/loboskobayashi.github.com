<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<HTML>
<HEAD>
<TITLE>python sf</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Shift_JIS"> 
<LINK href="./style.css" type="text/css" rel="stylesheet">
<STYLE>
</STYLE>
</HEAD>
<BODY>

<h1>■■ python sf マニュアル ■■</h1>
<h2>■■ 目次  </h2>
後回し
<h2>■■ 初めに  </h2>
<p>
Python sf は計算に特化したソフトです。普段メモ書きしている数式を、そのまま実行できることを理想としています。日常計算の九割以上をワンライナーで扱えると思います。この意味で Python sf は 計算ソフトの L.L.(Light weight Language) と言えます。
<p>
Python sf は既にある Python ライブラリ・パッケージの蓄積を活用します。特に scipy, sympy, vpython の三つのパッケージは、Python sf を動かすために必須です。<BR>
<p>
scipy の行列を中心とする数値計パッケージトは Matlab に近い機能を持ちます。sympy パッケージは、シンボリックな数式処理を可能にします。vpython は、高速にマウス操作できる 3D グラフ表示のために使っています。
<p>
でも、三つのライブラリ・パッケージだけでは、Python を使った数値計算が Matlab, Mathematica に相当できません。ユーザーが python 言語に妥協した記述をせねばなりません。
<p>
Python sf では、この三つのライブラリ・パッケージに 10000 行を超えるラッパーを被せています。これにより Python のアッパー・コンパチでありながら、計算ソフトの L.L. と言えるものに仕上げられました。
<IMG SRC="./PythonSfRelation.jpg"> <br>

<p>
Python sf で作ったラッパー・コードの半分は pre-processor です。これにより、Python の名前空間とは独立したユーザー・カスタマイズ可能な変数・関数・演算子を使えるようにしました。数学で多用するギリシャ文字や特殊記号を使えるようにしました。行列やベクトル記号を導入できました。数式記述での積演算子 * の省略を可能にしました。
<p>
scipy は素晴らしい数値演算パッケージですが、実際に使う上では多くの不満が出てきます。ベクトル・行列計算を普段メモ書きする数式までには簡略化できません。Bool 体などの一般体を要素とする行列も扱えません。微分や多項式などの扱いにも不満が出てきます。計算結果のグラフ表示も、できるだけ簡便に行わせたくなります。これらの不満をプリプロセッサと sf.py などの追加モジュールを設けて解消させました。
<p>
数学ソフトはユーザーごとにカスタマイズして使うソフトです。ユーザーによって必要とされる関数、物理定数や記述方法は異なります。理論物理学者と電気回路技術者では、同じ加減乗除算記号を使いますが、その計算内容は全くの別物です。必要される計算機能も共通部分より異なる部分のほうが多いでしょう。この違いの問題は、プリプロセッサを前提とするカスタマイズ専用ファイル：customize.py を設けることで解決しています。
<p>
Python sf は開かれたソフトです。Python で扱える機能の全てを Python sf でも扱えます。Pytho sf の配布ソフトだけでは不足している数学機能があるときは、全世界で Python sf とは無関係に作られている様々の Python ライブラリ・パッケージをユーザー側でインストールして使ってください。Python sf はアッパー・コンパチであり、それらと矛盾することなく使えます。
<p>
また python 自体がユーザー側で容易に機能を追加できる言語でもあります。Python sf が公開している octn.py にある Bool 体クラス BF、有限整数体 Zp クラスは 100 行、150 行で書かれています。別の体が必要なときは、ユーザー側で作ってください。octn.py にある BF クラスでの様に、__add__, __mul__ などの四則演算関数を定義してやるだけば、Python sf 側で用意している多項式や行列を勝手、ユーザー作った体クラスのインスタンスを操作できます。
<p>
高機能でありながらユーザー・カスタマイズ可能な開かれた L.L. 計算ソフト Python sf を是非とも試してみてください。

<h4>python で行列・数値計算なんて遅いでしょ</h4>
<p>
python による数値計算なんて遅くて使い物にならないと思われる方がいるかも知れません。でも それは誤りです。素人の C 実装による行列計算では python に勝てないと思います。

python の行列計算では linpack ライブラリが使われます。カリカリにチューニングされた C の行列計算ライブラリーです。その行列計算速度は linpack の それです。

sb();N=100;mt=sc.randn(N,N); sc.dot(mt, sl.inv(mt))[:3,:3]
===============================
[[  1.00000000e+00   1.77635684e-15  -4.64212002e-15]
 [  1.28785871e-14   1.00000000e+00  -7.32747196e-15]
 [  1.56541446e-14   1.55431223e-15   1.00000000e+00]]

U115 netbook on SSD, E7500 on Wester Digital

<pre>
実測値の表
</pre>
<h2>■■ python sf のインストール</h2>
<p>
Windows Python 2.5 を前提に、テストしています。Python 2.4 では、一部問題がでます。残念ですが、2009.06.01 現在の評価版では Linux 向けになっていません。
<h3>■ インストール方法</h3>
<p>
Python sf ではインストーラを設けていません。pythonSf091?.zip を解凍して、できたディレクトリ mtCm をカレント・ディレクトリとすれば動作するからです。mtCm の名前をユーザーの望む名前に変更しても問題ありません。
<p>
レジストリや環境変数を操作することもありません。アンインストールは mtCm ディレクトリを消去するだけです。気軽に試してください。
<p>
ただし、下の三つのソフトがインストールされていることを前提とします。
<ol>
    <li><a href="http://www.enthought.com/products/getepd.php">epd_py25-4.0.30002-win32-x86.msi</a>;;http://www.enthought.com/products/getepd.php
    <li><a href="http://code.google.com/p/sympy/">sympy-0.6.4.win32.exe</a>           ;;http://code.google.com/p/sympy/
    <li><a href="http://vpython.org/win_download25.html">VPython-Win-Py2.5-3.2.11.exe</a>       ;;http://vpython.org/win_download25.html
</ol>
<p>
Enthought の package ではなくても Python 2.5 向けの scipy がインストールされていれば動くと思います。sympy, vpython も、上以外のバージョンでも動くことが多いと思います。でも Windows 上で、2009.06.01 現在、上の組み合わせに限って動作確認しています。

<h2>■■ Python sf の実行</h2>
<p>
Python sf はコマンド・ラインで動かすソフトです。エディタのコンソール・モードに組み込んで使うと便利です。マウスを使うのは 3D グラフ表示結果を視点を変えてみるときなどです。
<p>
マウス操作になれた方には違和感があろうかも思います。この機会にコマンド・ライン操作に慣れることを勧めます。計算操作の過程でマウス操作が有利な個所は少ないからです。
<h3>■ 評価版での機能制限</h3
<p>
pythonSf091?.zip で配布している Python sf 評価版の機能は製品版と全く同じです。機能の制限ではなく、動作を遅くさせています。全ての計算で、四秒のディレーを挿入しています。四秒のディレーさえなければ Python sf を使えるとの評価をいただけましたら、有償版の Python sf に切り替えてください。
<h3>■ ワンライナーでの実行</h3
<p>
Python sf は、テキスト・エディタでメモ書きしているままで計算させることを理想としています。できるだけワンライナーの計算式で実行できるように作ってあります。線形代数を考えれば分かってもらえると思いますが、整理・完成された数学は計算させるときに場合分けすることが少なくなるように出来上がっています。研究・設計で出てくる多くの数学計算は、if then else を必要としません。多くの方にとって、半分以上の計算がワンライナーで済んでしまうと思います。
<p>
ワンライナーで計算させられることに拘る理由は、計算のためにプログラムやデバッグをしないためです。研究や設計のために、計算ソフトを実行させるのであり、そのために必要な数式を書くだけで計算をさせたいからです。設計・研究のために計算している最中にプログラムやデバッグをさせることは、設計・研究の対象への集中を削ぐことになるからです。
<p>
もちろん無理やりワンライナーにすることは避けるべきです。ワンライナーで計算させられないと思ったときは、躊躇することなく後に述べるファイル実行に切り替えてください。
<h4>ワンライナー実行の具体例</h4>
<p>
次のように計算させたい Python sf 式を引用符で囲んで、その前に 「python -m sfPP」を挿入した文字列をコマンドラインで実行させます。
<br>
<IMG SRC="./commandLine.jpg"> <br>

<p>
sfPP.py の拡張子 "py" が python.exe に関連付けられているならば 「python -m sfPP」の変わりに 「sfPP.py」だけでも計算できます
<br>
<IMG SRC="./commandLineSfPP.jpg"> <br>

<p>
以下の Python sf 式では、決まりきった「python sfPP "....."」 や 「sfPP.py "...."」を省略して、引用符の内側 .... の部分だけを書いていきます。左上に「sf expression」と書いてあるワンライナーの Python sf 式は、この意味に解釈ください。
<blockquote>
<div class="qtitle">コマンド実行</div>
<p>本稿では、Python sf ワンライナーを「微細構造定数;;`eQ^2/(h`` c` 4 `π ε0`)」のように書いていきます。これは「;;」以降の文字列を取り出して引用符で囲み、「python sfPP.py &quot Q^2/(h`` c` 4 `π ε0`)&quot」とコマンド・ラインで実行させることを意味しています。コメント部分「微細構造定数;;」なしの Python sf 式だけでも使います。私自身は、<a href="http://www.nasuinfo.or.jp/FreeSpace/kenji/other/kShell/kShell.htm">そのような WZ エディタのマクロ</a>を組んで、ctrl + O + C 操作で、引用符の追加などの定型文字列処理をエディタ・マクロで実行させています。できましたら、お使いのエディタのコンソール・モードにそのようなマクロを組み込んで使ってみてください。
<p>
エディタのコンソール・モードを使わずに、取り急ぎコードをテスト実行させたいときにはPython sf 式、すなわち「;;」以降の文字列を &quot ... &quot と引用符で囲み、その前に「python sfPP.py 」文字列を追加した文字列をエディタで作り、dos のコマンド・ラインに copy and paste し直して実行させてください。クリップ・ボードにあるコピーされた文字列は、dos 画面で「alt + space → e → p 」操作だけで dos 画面に貼り付けられます。
</blockquote>

<h4>ワンライナー行列計算の具体例</h4>
<p>
Python sf では、ベクトルや行列の生成を ~[...] の簡便な記述で可能にしています。Python プリプロセッサが、簡便な ~[....] Python sf 式記述を Python 関数に変換し、Python に処理させます。デフォルトで float/complex 型の値を要素とするベクトルや行列になります。int:整数型や一般体のベクトル／行列を生成させるためには、型を指定する必要があります。
<pre class = sf>
~[1,2,3]
===============================
[ 1.  2.  3.]
---- ClTensor ----

~[1,2+0j,3]
===============================
[ 1.+0.j  2.+0.j  3.+0.j]
---- ClTensor ----

~[[1,2,3],[4,5,6]]
===============================
[[ 1.  2.  3.]
 [ 4.  5.  6.]]
---- ClTensor ----
</pre>
<p>
行列たち、ベクトルたちの間で線形代数で定義されている加減乗除算が行えます。乗算演算子:* は、通常の数式の時のように省略可能です。
<p>
<pre class = sf>
~[1,2,3]+~[4,5,6]
===============================
[ 5.  7.  9.]
---- ClTensor ----

3 *~[1,2,3]
===============================
[ 3.  6.  9.]
---- ClTensor ----

3 ~[1,2,3]
===============================
[ 3.  6.  9.]
---- ClTensor ----

mt=~[[1,2],[3,4]]; mt mt
===============================
[[  7.  10.]
 [ 15.  22.]]
---- ClTensor ----
</pre>
Python sf でのベクトル同士の積は内積の意味になります。
<pre class = sf>
a =~[1,2,3];b=~[4,5,6];a b
===============================
32.0

a =~[1,2,3];b=~[4,5,6];(a + b) b
===============================
109.0
</pre>
<p>
行列とベクトルの掛け算も積演算子で表現され、その積演算子を省略可能です。
<pre class = sf>
mt=~[[1,2],[3,4]]; v=~[1,2];mt v
===============================
[  5.  11.]
---- ClTensor ----

mt=~[[1,2],[3,4]]; v=~[1,2];2 mt*v
===============================
[ 10.  22.]
---- ClTensor ----
</pre>
<p>
ただし、Python sf では縦ベクトル／横ベクトルの区別がありません。「ベクトル*行列」の積もサイズさえ合えば計算できます。
<pre class = sf>
mt=~[[1,2],[3,4]]; v=~[1,2];2 v mt
===============================
[ 14.  20.]
---- ClTensor ----

mt=~[[1,2],[3,4]]; v=~[1,2];2 v mt + v
===============================
[ 15.  22.]
---- ClTensor ----
</pre>
<p>
ですから、ディラック表記 &lt;v|mt|v&gt> のような計算もできてしまいます。

<pre class = sf>
mt=~[[1,2],[3,4]]; v=~[1,2];2 v mt v    # this means &lt;v|mt|v&gt;
===============================
54.0
</pre>
<p>
べき乗演算子は「^」と「**」の両方が使えます。Python では「**」がべき乗で「^」は bit exor なのですが、Python sf では「^」もべき乗にしています。数学では「^」をべき乗にすることが多いからです。この処理はプリプロセッサに行わせています。プリプロセッサを使わないときは、べき乗には ** 演算子しか使えません。
<p>

<pre class = sf>
mt=~[[1,2],[3,4]]; mt^2
===============================
[[  7.  10.]
 [ 15.  22.]]
---- ClTensor ----

mt=~[[1,2],[3,4]]; mt**2
===============================
[[  7.  10.]
 [ 15.  22.]]
---- ClTensor ----

mt=~[[1,2],[3,4]]; mt^8
===============================
[[ 165751.  241570.]
 [ 362355.  528106.]]
---- ClTensor ----
</pre>
逆行列は /,**,^ 演算子を使って表記できます。
<pre class = sf>
mt=~[[1,2],[3,4]]; mt^-1
===============================
[[-2.   1. ]
 [ 1.5 -0.5]]
---- ClTensor ----

mt=~[[1,2],[3,4]]; mt**-1
==============================
[[-2.   1. ]
 [ 1.5 -0.5]]
---- ClTensor ----

mt=~[[1,2],[3,4]]; 1/mt
==============================
[[-2.   1. ]
 [ 1.5 -0.5]]
---- ClTensor ----

mt=~[[1,2],[3,4]]; v=~[1,2];mt/mt
==============================
[[  1.00000000e+00   0.00000000e+00]
 [  8.88178420e-16   1.00000000e+00]]
---- ClTensor ----

mt=~[[1,2],[3,4]]; v=~[1,2];mt mt^-1
==============================
[[  1.00000000e+00   0.00000000e+00]
 [  8.88178420e-16   1.00000000e+00]]
---- ClTensor ----

mt=~[[1,2],[3,4]]; v=~[1,2];mt^-1 mt
==============================
[[  1.00000000e+00   0.00000000e+00]
 [  2.22044605e-16   1.00000000e+00]]
---- ClTensor ----

mt=~[[1,2],[3,4]]; v=~[1,2];2 mt^-1 v
===============================
[ 0.  1.]
---- ClTensor ----

mt=~[[1,2],[3,4]]; v=~[1,2];v/mt
===============================
[ 1.  0.]
---- ClTensor ----
</pre>


<blockquote>
<div class="qtitle">---- ClTensor ---- について</div>
<p>
Python sf でのベクトル・行列のコンソール出力で「---- ClTensor ----」が出てくるのは、後ででてくる scipy の array, 一般体向けの ClFltTns と区別するための名称です。二回までのベクトル・行列については matrix やベクトルの性質を持ちます。三階以上の ClTensor については逆行列が定義できませんが、加減乗算が定義できます。テンソルとして扱えます。
<p>
ClTensor の名前にしたのは、一般相対論での Christoffel 接続係数や Rieman テンソルを扱いたいこともあるのですが、既に Numpy にある Matrix クラスと混同させたくないこともありました。
<p>
不必要な心配をさせたかも知れませんが、ご理解ください。
</blockquote>

<h4>Pauli 行列 Levi Civita テンソル</h4>
<p>
customize.py にはユーザーが頻繁に使う変数や完遂を定義できます。Python sf を実行開始するときに customize.py に定義してある変数名を定義済みの名前として取り込みます。
<p>
後々行列、テンソル計算で使うときに便利なので、ここで、customize.py に定義してある Pauli 行列とその計算例を示しておきます。まず Pauli 行列には `σx, `σy, `σx の変数名で下のような行列を対応させてあります。これを Python sf の定義済み変数として下のように扱えます。「import customize」はプリプロセッサ側が自動的に行います。またプリプロセッサを介することで Python 2.5 であってもギリシャ文字の漢字を使えます。
<pre class = sf>
`σx
===============================
[[ 0.  1.]
 [ 1.  0.]]
---- ClTensor ----

`σy
===============================
[[ 0.+0.j  0.-1.j]
 [ 0.+1.j  0.+0.j]]
---- ClTensor ----

`σz
===============================
[[ 1.  0.]
 [ 0. -1.]]
---- ClTensor ----
</pre>
<p>
上の Python sf 式で backquote:「`」は Python の名前空間を広げるためにプリプロセッサ側で処理しています。変数名の前後に複数の ` を追加できるようにしています。
<p>
これらの Pauli 行列を組み合わせで加減乗除算が可能です。

<pre class = sf>
`σx + 2 `σy + `σy^2 `σz + 10 `σz
===============================
[[ 11.+0.j   1.-2.j]
 [  1.+2.j -11.+0.j]]
---- ClTensor ----
</pre>
<p>
sl に scipy パッケージの linalg モジュールを割り当てて Python sf 名前空間に入れてあります。これにより、linalg モジュールにある線形代数関連の関数を使えるようりなります。例えば行列の exp 関数計算を次のように行えます。

<pre class = sf>
H = `σx^2 + `σx^2; t=0.1;sl.expm(`i t H)
===============================
[[ 0.98006658+0.19866933j  0.00000000+0.j        ]
 [ 0.00000000+0.j          0.98006658+0.19866933j]]
</pre>
<p>
Hamilnonian 行列 `σx^2 + `σx^2 の時刻 t = 0.1 のときの exp を、上のように計算させられます。`i は 1j と Python 流に書いても言いのですが `i の方が数学での純虚数表記に近いので customize.py の中でユーザー変数として定義しました。
<p>
i を純虚数の記号として使えればよいのですが、文字 i はインデックスなど Python のコードで別の意味に使われることがあり、変数の衝突が発生するので短い i 一文字に純虚数を割り当てられません。でも backquote:` を i の前に追加した変数ならば Python コードのインデックス i と衝突することはありません。「`i」 ならば数式の中で純虚数の意味であることも可読性良く表記できます。
<p>

<h4>ワンライナーの最後の式の値をコンソールに自動的に出力</h4>
<p>
Python sf では、ワンライナーの式には print 文がなくても、その最終式の値をコンソールに打ち出します。これも意外と便利です。

<pre class = sf>
a=3;b=4;a+b
===============================
7
</pre>

<p>
print 文がある、最後の式の値が 100 x 100 行列で大きすぎるなど、最後の式の値を自動出力させたくないときは、Python sf の最後を ; にします。

<pre class = sf>
for i in range(4):print 2 i;
0
2
4
6

for i in range(4):print 2 i
0
2
4
6
-------------------------------
None
</pre>

<h4>ワンライナーの最後の式の値を _dt.pvl にも出力</h4>
<p>
Python sf は、ワンライナーの最終式の値をコンソールに打ち出すと同時に、その値をファイル変数として扱える形式で _dt.pvl にも出力します。
<pre class = sf>
3+4
===============================
7
</pre>
<pre class = dos>
type _dt.pvl
# python object printed out by pprint
7
</pre>
<p>
ファイル変数とは、Python sf がカレント・ディレクトリに作るファイルであり、また Python sf の変数として読み出せるファイルです。下のように 「=:」記号で、Python sf 式に戻すことができます。
<pre class = sf>
=:_dt;_dt * 5
===============================
35
</pre>

<p>
ファイル変数とは、ファイルであり、通常の OS の command が使えます。_dt.pvl の変数名を、好みの変数名に OS command で変更できます。ただし拡張子は pvl にしておかいないと、Python sf で扱えません。

<pre class = dos>
copy _dt.pvl temp.pvl /y
</pre>
<pre class = sf>
a =:temp;2 a
===============================
70
</pre>
<p>
上で、「a =:temp」は、ファイル変数を a のラベルに付け替えています。ファイル変数は _dt.pvl とは異なり、Python sf 式の実行で勝手に書き換えられないので以前に設定された値を保ちます。何時でも再利用可能です。
<pre class = sf>
=:temp;2 temp
===============================
70
</pre>
<h5>最後の式の値を入れる変数名を指定できます</h5>
<p>
Python sf は、ワンライナーの最終式の値を出力先のファイル変数名を、最終文の左値に「変数 := 式」と書くことで指定できます。
<pre class = sf>
test:=3+4
===============================
7

=:test;test*5
===============================
35
</pre>
<p>
後で何度も使うファイル変数を設けたいときに := 記号を使って、明示的にファイル変数名を指定するわけです。_dt ファイル変数は、直前の Python sf ワンライナーの結果が残っているだけであり、何度も使いたいファイル変数は _dt の名前にできません。
<p>
なお、「:=」の記号の使用は、Python sf ワンライナーの途中の文でも使えます。最終文に限っていません。
<h4>ワンライナーの最後の式の値を _dt.pvl に出力できないときもあります。</h4>
<p>
残念ながら Python sf の最終式の値によっては、ファイル変数が作られないことがあります。Python sf がファイル変数を作る方法として python の pickle モジュールを利用しているからです。python が pickle できない値はファイル変数にできません。
<pre class = sf>
λ x:2 x
===============================
&lt;function &lt;lambda&gt; at 0x0207AC30&gt;   
unpicklable
</pre>
<p>
Python では、関数自体は pickel できないので、最終式の値が関数自体のときは _dt.pvl は空ファイルになります。

<h3>■ Python sfファイル実行</h3>
<p>
複雑な計算をさせるときには、ワンライナーで書くべきではありません。可読性を犠牲にしてまでワンライナーを使うべきではありません。このときは "-fs" オプションをつけて Python sf プリプロセッサに文字列変換のみを行わせます。Python sf でに -fs オプションの後にファイル名を指定すると、プリプロセスだけをした結果を __tempConverted.py ファイルに書き出します。次のような具合です。ちなみに「-fs」 は convert File and Skip execution から決めました
<pre class = sfBlock>
//@@
def f(x,y):
    return ~[sin(x)+y^2, y cos(x)]

def g(x,y):
    return ~[sin(x) y,  cos(x)]
    #return ~[[sin(x) y,  cos(x)],[tan(x) y, sinh(x+y) x]]

px=(1,2)
pp(∂J(λ x,y: f(x,y) g(x,y))(*px))
print
pp(∂J(f)(*px) g(*px) + f(*px) ∂J(g)(*px))
//@@@
//copy \#####.### temp.py /y
//sfPP.py -fs temp.py
//__tempConverted.py
[ 4.32242, 11.0977] 

[ 7.39293, 1.53359]
</pre>
<p>
私はエディターで「//@@ .... //@@@ の間にあるテキストを C:\#####.### ファイルに書き込み、その次にある // で始まるコマンドを実行していくマクロ」を作っています。このマクロも便利です。コンソール・モードを持っているエディタをお使いならば、このマクロを作っておくと、Python sf に限らず、任意の言語一般に使えて便利ですよ。
<p>
短いテスト・プログラム・コードを一つのファイルに時系列に従って記録していけます。このマクロを Python に限らず、C++/STL/boost、Ruby、perl, OCaml, erlang, Java などにも使っています。短いテストコードを何百も溜め込んでいます。コンパイル・オプション、実行オプションまで含めて、必要な情報は全て残していけます。何時でも再実行できます。本当に便利ですよ。
<p>
<a href="http://www.nasuinfo.or.jp/FreeSpace/kenji/other/kShell/kShell.htm">このような WZ エディタのマクロ</a>も、ここに公開してあるので、WZ エディタ使いの方はご利用ください。その他のエディタの方は、是非とも、ことようにエディタのマクロを作ってみてください。
<p>
<p>
このようなエディタのマクロのおかげで、この html ファイルに書いてある Python sf 式は、全て書くと同時に再チェックしていっています。たんに 「ctrl + O -&lt; E」 のキー操作だけで、勝手に temp.py ファイルを作り、「sfPP.py -fs temp.py」 を実行させ、プリプロセッサに __tempConverted.py ファイルを作らせ、__tempConverted.py を実行させられるからです。
<p>
ちなみに、上の Python sf ファイル実行は、ベクトル値を返す関数の内積に Jacobian 微分を働かせたときにも (f g)' == f' g + f g' の分配則が成り立たないことを確認する数値実験です。∂J に汎用の Jacobian 微分関数を割り振るように、後で述べる customize.py ファイルに登録してあります。

<h4>Python sf プリプロセッサが生成するファイル </h4>
<p>
ファイル実行のために Python sf プリプロセッサが吐き出した __tempConverted.py ファイルを見てやると、その働きが良く判ります。

<pre class = dos>
type __tempConverted.py

from __future__ import division
# -*- encoding: cp932 -*-
from sf import *
from sf.customize import *
if os.path.exists('.\sfCrrntIni.py'):
    from sfCrrntIni import *
def f(x,y):
    return krry([[sin(x)+y**2, y * cos(x)],[tan(x), sinh(x+y)]])

def g(x,y):
    return krry([[sin(x) * y,  cos(x)],[tan(x), sinh(x+y)]])

px=(1,2)
pp(k__Round_J___(lambda x,y: f(x,y) * g(x,y))(*px))
pp(k__Round_J___(f)(*px) * g(*px) + f(*px) * k__Round_J___(g)(*px))
</pre>
<p>
「from __future__ import division」は整数／整数の割り算のとき float 値を返すようにさせています。これがないと 2/3 は 0 になってしまいます。
<p>
Python 3000 では、デフォルトで整数／整数は float 値にする仕様に変わります。でも 2.x バージョンの python は「from __future__ import division」がないと整数／整数は整数になってしまいます。
<pre class = code>
//@@
a=2/3
print a
//@@@
//copy \#####.### temp.py /y
//python temp.py
0
</pre>
<p>
実数の数値計算が主なとき、これでは困ります。2.0/3 と書けばよいのですが、どうしても2/3 と書いてしまいます。通常書いている数式が 2/3 と書くからです。しかも、上のような二行だけでしたら、直ぐに気づきます。でも 20 行のコードの中に、このミスが紛れ込むと簡単には分かりません。何かおかしいからとデバッガで何十分もかけておって初めて割り算の書き間違いだと気づくことが何度も発生します。これを避けるために Python sf では、無条件で「from __future__ import division」を有効にしています。ワンライナーのときも同じです。
<p>
「from sf import *」により、 Python sf の基本機能：行列演算、表示関数などの名前空間を global 変数に取り込んでいます。kzrs(3) と書くだけで sf.py に定義してある、0 ベクトル／行列を生成する kzrs 関数をで呼び出せます。「import sf;sf.kzrs(3)」 などと冗長な書き方をせずに済ませられるようにしています。
<p>
「from customize import *」も同様に customize.py ファイル内で宣言・定義してある変数名、関数名、モジュール名を global 変数に取り込ませています。customize.py はユーザーが必要とするデフォルトの名前空間を指定するために設けています。ユーザー側で customize.py を編集し、必要なユーザー環境に向けてカスタマイズしてください。

<h3>■ 漢字コードは shift-jis </h3>
<p>
Python sf のプリプロセッサにより、ギリシャ文字と∇□∂△記号を使えるようにしています。これらは短く可読性のある数式を記述するに必須の記号です。残念ですが、この漢字コードは、現在のところ shift-jis を前提としています。utf-8 も使えるようにしたいのですが、今の所、手が回っていません。
<BR>

<h3>■ 多重ループ・イタレータ </h3>
<h4> arsq </h4>
<h4> mrange </h4>
<h4> mitr </h4>
<h4> klsp </h4>
sc.linspace の ClTensor 版です。ClTensor ベクトルを返します。
<pre class = sf>
klsp(-2,2)
===============================
[-2.         -1.91836735 -1.83673469 -1.75510204 -1.67346939 -1.59183673
 -1.51020408 -1.42857143 -1.34693878 -1.26530612 -1.18367347 -1.10204082
 -1.02040816 -0.93877551 -0.85714286 -0.7755102  -0.69387755 -0.6122449
 -0.53061224 -0.44897959 -0.36734694 -0.28571429 -0.20408163 -0.12244898
 -0.04081633  0.04081633  0.12244898  0.20408163  0.28571429  0.36734694
  0.44897959  0.53061224  0.6122449   0.69387755  0.7755102   0.85714286
  0.93877551  1.02040816  1.10204082  1.18367347  1.26530612  1.34693878
  1.42857143  1.51020408  1.59183673  1.67346939  1.75510204  1.83673469
  1.91836735  2.        ]
---- ClTensor ----
</pre>


<h3>■ ファイル実行 </h3>
<p>
:=, =: を使えない。putPv(..) getPv(..) を使います
<h2>■■ Python sf の名前空間と help</h2>
<p>
Python sf を使いこなすためには、それが用意している関数の名前を知らねばなりません。Python 言語の言葉で表現すると、Python sf が割り当てている名前空間を知らねばなりません。でも何百、何千とある関数の名前の他に、その引数まで全てを頭に入れることは不可能です。

<p>
パッケージやライブラリのドキュメントを直ぐに見られるように、Python にはイントロスペクションの機能が組み込まれています。イントロスペクション機能とは、極端に単純化すれば「関数のソース・コードに書かれている説明を help(..) によって表示させる」機能です。膨大な機能を全て記憶できるはずもなく、イントロスペクション機能は非常に重宝します。

<p>
Python アッパー・コンパチな Python sf でも help(..) は重宝します。Python sf で help(..) 関数を使うためには、Python sf での名前空間の概略を知っていなければなりません。

<p>
Python sf の名前空間をは sf.pyc と customize.py ファイルより定まります。sf.pyc は Python sf の中心的な機能を纏めたモジュールであり、sf.pyc にある名前空間すべてが Python sf の名前空間に取り込まれます。customize.py ファイルは Python sf の名前空間をユーザー・カスタマイズするために設けています。

<p>
Python sf の名前空間を理解するには、Python sf の実行時のファイル依存関係、すなわちパッケージやライブラリが import される順序関係を知っておくと便利です。また Python sf の名前空間は、ユーザー側で自由にカスタマイズできるのですが、そのためにも、import の順序関係の理解が必須です。

<p>
Python sf で計算をするには「引数に数式文字列または数式の書き込まれたテキスト・ファイルを指定して」 sfPP.py プリプロセッサを働かせます。

<p>
sfPP.py プリプロセッサは、数式テキストやテキスト・ファイルを処理する前に、sf.pyc, customize.pyc モジュールの名前空間を自分の名前空間にとりこみます。

<pre class = block>
    sfPP.py # python pre-processor
        from sf import *            # import sf's name space
        from sf.customize import *  # import customize's name space
        if os.path.exists('.\sfCrrntIni.py'):
            from sfCrrntIni import *# import sfCrrntIni's name space

        processing 数式 or 数式ファイル

</pre>
<p>
pythonSf091?.zip 配布ファイルを解凍してできる mtCm ディレクトリに sf.pyc, customize.pyc, customize.py ファイルが含まれています。これらの名前空間を取り込むことで、Python sf 式の処理が機能になります。

<blockquote>
<div class="qtitle">「.pyc」,「.py」 拡張子について</div>
<p>
Python のソース・ファイルは「.py」拡張子が付いたテキスト・ファイルです。「.pyc」拡張子は、python ソース・ファイルをコンパイルして作られます。
<p>
pyc ファイルより py ファイルのタイム・スタンプが新しいとき、Python はコンパイラを働かせて、pyc ファイルを更新します。
<p>
Python プログラムの実行のためには pyc ファイルさえあれば十分です。イントロスペクションに使うドキュメント文字列も pyc ファイルに書き込まれています。
<p>
pythonSf091?.zip 配布ファイルには customize.py ファイルと customize.pyc ファイルの両方を入れてあります。でも sf.py ソースは入れてありません。コンパイル済みの sf.pyc ファイルだけを入れてあります。sf.py には Python sf の行列処理などの中心機能が入っており、公開できません。了解ください。customize.py はユーザーが欲しい環境にソースをカスタマイズして使うので、ソース・ファイルも添付しています。
<p>
octn.py, tlRcGn.py ソース・ファイルも pythonSf091?.zip 配布ファイルに添付してあります。これらはユーザー欲しい数学機能を自分で作り上げるときの参考にしてもらうため、ソース添付としています。
</blockquote>
<h3>■ sfFnctns.pyc 名前空間 </h3>
<p>
「from sf.sfFnctns import *」を Python インタプリタが実行することで sfFnctns.pyc の中で定義されているモジュール／変数／関数の名前空間が全て取り込まれます。それらの名前を使えるようになります。help(..) で、それらの関数のドキュメントを読めるようになります。
<p>
sfFnctins.pyc には次の名前が定義されています。
<pre class = block>
    scipy 主要パッケージ名の alias 名
        import scipy as sc
        import scipy.optimize as so
        import scipy.integrate as si
        import scipy.linalg as sl
        import scipy.special as ss
        import scipy.signal as sg

    偏微分方程式
        def solvePDE(dctBoundary, fncRecurring, inIteration=64, dfltValue = 0
        def solveLaplacian(dctBoundary, inIteration=64):
        def itrSlvPDE(dctBoundary, inIteration=64, dfltValue = 0

    ループ・イタレータの追加
        def mrng(*args):
        def arSqnc(startOrSizeAg, sizeAg = None, strideAg=1):
        def masq(*args):
        def enmasq( *args, **kwarg):
        def mitr(*args):
        def enmitr( *args, **kwarg):
        def combinate(items, n):            組み合わせイタレータ
        def permutate(items, inSignAg=1):   順列イタレータ

    有理式
        class ClRtnl(object):

    グラフ表示
        def plotTrajectory(arg, color = vs.color.cyan, radiusRate = 80.0, blAxis = True):
        def plotGr(vctAg, start=(), end=None, N=128, color = vs.color.cyan):
        def plotTmChS(*tplAg):
        def plotTmCh(vctMtrxAg):
        def plotBode(clRtnlAg, lowerFreq, higherFreq = None):
        def plotDgBode(clRtnlAg, higherFrqAg = 1, lowerFrqAg = 0):
        def render2dRGB(mtrxAg, boundary=1.0, limit=10.0, blReverse=False, blBoth=False
        def renderMtrx(mtrxAg, color=blue, blMesh = True, meshColor = vs.color.white
        def renderMtCplxWithRGB(mtCplxAg, blMesh = False, meshColor = vs.color.white
        def renderFacesWithRGB(obarAg, blMesh = False, meshColor = vs.color.white
        def renderFaces(obarAg, blMesh = False, colorFace = vs.color.green

    数値微分
        class D_(object):
        class P_(object):
        class Pt_(P_):
        class Nl_(object):  # Nabla
        class Dv_(object):  # Divergence
        class Jc_(object):

    ベクトル・行列
        def krry(*ag, **dctAg):
        def kzrs(*sqShape, **dctAg):
        浮動小数点のベクトル・行列
            ClTensro
        一般体のベクトル・行列
            ClFldTns
    その他
        def cOdeInt(fncAg, y0, t, args=() ):複素関数の常微分方程式の数値解
        def dct2(sqAg):                     cosine 変換
        def compose(fnLeftAg, fnRightAg):   関数合成
</pre>
これらの名前それぞれについて help(..) を働かせます。例えば permutate 関数について help を行わせると、下のようにドキュメントを表示します。
<pre class = sf>
help(permutate)
Help on function permutate in module pysf.sfFnctns:

permutate(items, inSignAg=1)
    'A generator for calculating all the permutations of a sequence with sign
        modified from 
        http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/190465
    
        premutate given sequece and return the (permutated list,sign)
        inSignAg is initial sign value and changed sign for each exchange
    
        permutate(.) returns tuple of (tuple,int), not of [list,int] to ease
        make index:sign dictionary from returned value
        e.g.
        tuple(sf.permutate([2,1,0]))
        ===============================
        (((2, 1, 0), 1), ((2, 0, 1), -1), ((1, 2, 0), -1), ((1, 0, 2), 1)
                , ((0, 2, 1), 1), ((0, 1, 2), -1))
    
        tuple(sf.permutate([0,1,2]))
        ===============================
        (((0, 1, 2), 1), ((0, 2, 1), -1), ((1, 0, 2), -1), ((1, 2, 0), 1)
                , ((2, 0, 1), 1), ((2, 1, 0), -1))
    '

===============================
None

help(pp)
</pre>
<p>
Python sf 式で、意味の分からない関数やクラスに出くわしたとき、このような help(..) を行ってみて概要を理解した後、幾つか自分で関数やクラスを実行させてみるのが、手っ取り早く Python sf を使いこなす早道です。
<blockquote>
<div class="qtitle">「.pyc」,「.py」 拡張子について</div>
<p>
Python のソース・ファイルは「.py」拡張子が付いたテキスト・ファイルです。「.pyc」拡張子は、python ソース・ファイルをコンパイルして作られます。
<p>
pyc ファイルより py ファイルのタイム・スタンプが新しいとき、Python はコンパイラを働かせて、pyc ファイルを更新します。
<p>
Python プログラムの実行のためには pyc ファイルさえあれば十分です。イントロスペクションに使うドキュメント文字列も pyc ファイルに書き込まれています。
<p>
pythonSf091?.zip 配布ファイルには customize.py ファイルと customize.pyc ファイルの両方を入れてあります。でも sfFnctins.py ソースは入れてありません。コンパイル済みの sf.pyc ファイルだけを入れてあります。sfFnctns.py には Python sf の行列処理などの中心機能が入っており、公開できません。了解ください。customize.py はユーザーが欲しい環境にソースをカスタマイズして使うので、ソース・ファイルも添付しています。
<p>
octn.py, tlRcGn.py ソース・ファイルも pythonSf091?.zip 配布ファイルに添付してあります。これらはユーザー欲しい数学機能を自分で作り上げるときの参考にしてもらうため、ソース添付としています。
</blockquote>

<h3>■ scipy 名前空間 </h3>
<p>
sfFnctns.pyc の中で次の名前を定義しています。ここで、行列数値計算を担う、膨大な scipy パッケージのサブ名前空間にも短い名前を付けてます。
<pre class = block>
    scipy 主要パッケージ名の名前付け
        import scipy as sc
        import scipy.optimize as so
        import scipy.integrate as si
        import scipy.linalg as sl
        import scipy.special as ss
        import scipy.signal as sg
</pre>
<p>
scipy パッケージの膨大さは help(scipy) を行わせてみると、20000 行を超えるドキュメントを返してくれることからも推測できます。
<pre class = sf>
help(scipy)

python -m sfPP "help(scipy)"
Help on package scipy:

NAME
    scipy

FILE
    c:\lng\python25\lib\site-packages\scipy-0.6.0.0006-py2.5-win32.egg\scipy\__init__.py

DESCRIPTION
    SciPy --- A scientific computing package for Python
    ===================================================
        ・
        ・
    typecodes = {'All': '?bhilqpBHILQPfdgFDGSUVO', 'AllFloat': 'fdgFDG', '...

VERSION
    0.6.0
</pre>


<h2>■■ Python sf プリプロセッサ概要</h2>
ベクトル・行列
ギリシャ文字
特殊記号
<h2>■■ ユーザー名前空間と customize</h2>
<h3>■ </h3>
<h3>■ </h3>
<p>
<p>
<p>
<h4>khlp:正規表現ヘルプ</h4>
<p>
モジュールのドキュメント文字列より khlp('...') 引数に指定された文字列を含んでいるものを返します。デフォルトで sf 名前空間に入っている変数名を対象にします。

<p>
名前空間に入っている文字列の指定に正規表現文字列を使えます

<p>
引数を何を指定しないときは sf 名前空間に入っているドキュメント文字列を全て返します。
<h2>■■ Python sf プリプロセッサ詳細</h2>

<h2>■■ 数値行列操作の詳細 bool, int, float, complex, object（Python 基本型）</h2>
<h3>■ なぜ numpy 行列とはべつに ClTensor 行列を設けるのか </h3>

int
内積
dot
<a|A|b>

sc.array([1,2,3]) sc.array([4,5,6])
===============================
[ 4 10 18]

[1*4, 2*5, 3*6] と要素同士を掛け合わせた演算になっています

文字列表記だけでは array と分りません。これだと、一般の体を要素とする行列が入り込んできたとき、混乱してしまいます。
<h3>■ ベクトル・行列宣言 </h3>
<h4>ベクトル・行列要素の型指定 </h4>
<p>
~[....] の一番最後に、型変数を書き込むことで、ベクトル行列の要素の型を明示的に指定できます
<pre class = sf>
~[1,2,3, complex]
===============================
[ 1.+0.j  2.+0.j  3.+0.j]
---- ClTensor ----

~[[1,2,3],[4,5,6],int]
===============================
[[1 2 3]
 [4 5 6]]
---- ClTensor ----
</pre>

<h4>ベクトルの内積 </h4>
Python sf でのベクトル同士の積は内積の意味になります。ただし複素ベクトルの積はユーザーが明示的に複素共役であることを「.d」属性で指定してやらねばなりません。数学でのように勝手に複素共役に変換して内積をとることはありません。特殊相対論での、このような内積の取り方が多用されるため、こちらを選択しました。
<pre class = sf>
a =~[`i,2,3];b=~[4`i,5,6];a b
===============================
(24+0j)

a =~[`i,2,3];b=~[4`i,5,6];a.d b
===============================
(32+0j)

</pre>

<h4>0 行列の 0 べき乗 </h4>
<p>
正方行列の 0 べき乗は無条件に単位行列にしています。たとえ、0 行列の 0 べき乗でも、単位行列にします。0^0 は数学では不定であることは分かっていますが、Python では 0^0 == 1 です。これを踏襲しました。不定なのを単位行列にしても誤りで花からです。また こちらのほうが krzs(8,8)^0 などと簡単に単位行列を定義できて便利だからです。
<pre class = sf>
0^0
===============================
1

mt=~[[1,2],[3,4]]; mt^0
===============================
[[ 1.  0.]
 [ 0.  1.]]
---- ClTensor ----

mt=~[[0,0],[0,0]]; mt^0
===============================
[[ 1.  0.]
 [ 0.  1.]]
---- ClTensor ----

mt=~[[0j,0],[0,0]]; mt^0
===============================
[[ 1.+0.j  0.+0.j]
 [ 0.+0.j  1.+0.j]]
---- ClTensor ----
</pre>

<h4>外積</h4>
下のような Levi Civita テンソル `εL も配布ファイルの中の customize.py ファイルに定義してあります。これを使えば、三次元ベクトルの外積を計算できます。
<pre class = sf>
`εL
===============================
[[[ 0.  0.  0.]
  [ 0.  0.  1.]
  [ 0. -1.  0.]]

 [[ 0.  0. -1.]
  [ 0.  0.  0.]
  [ 1.  0.  0.]]

 [[ 0.  1.  0.]
  [-1.  0.  0.]
  [ 0.  0.  0.]]]
---- ClTensor ----

-~[1,2,3] `εL ~[4,5,6]
===============================
[-3.  6. -3.]
---- ClTensor ----
</pre>
<p>
符号を反転させるために、マイナスを付けるのが嫌ですが、それなりに使えるでしょう
<p>
scipy/numpy にも三次元の外積を求める関数 cross があるます。これらのモジュール名には sc の名前をすでにわりふってあります。下のように外せきを計算します。
<pre class = sf>
sc.cross([1,2,3], [4,5,6])
===============================
[-3  6 -3]
</pre>
<p>
vpython にも三次元の外積を求める関数 cross があるます。vpython モジュールには vs の名前を割符って有ります
<pre class = sf>
vs.cross([1,2,3], [4,5,6])
===============================
<-3, 6, -3>
unpicklable

vs.cross([1,2], [4,5])
===============================
<0, 0, -3>
unpicklable
</pre>


<p>
ただし、計算結果は vpython の array になります。三次元専用なので、二次のベクトルを与えても、三次元の外積を計算します。
<p>
Wedge 積を `Λ(...) の関数名で customize.py に定義してあります。数学に詳しい方には、Wedge 積関数が、外積計算の方法として一番整合性がとれるでしょう。二次元、三次元、四次元, ... 任意の次元で外積を計算できのるですから。
<pre class = sf>
`Λ([1,2],[4,5])
===============================
[[ 0. -2.]
 [ 2.  0.]]
---- ClTensor ----

`Λ([1,2,3],[4,5,6])
===============================
[[ 0. -3. -6.]
 [ 3.  0. -3.]
 [ 6.  3.  0.]]
---- ClTensor ----

`Λ([1,2,3,4],[4,5,6,7])
===============================
[[ 0. -3. -6. -9.]
 [ 3.  0. -3. -6.]
 [ 6.  3.  0. -3.]
 [ 9.  6.  3.  0.]]
---- ClTensor ----
</pre>
<p>
ただし計算結果は反対称行列として出力されるので、数学に詳しくない方は面食らうかも知れませんね。
<p>
<!-- うぞ、まだエラーになるだけ
ちなみに `Λ wedge 積関数は一般体のベクトルでも受け付けます。例えば bool 体のベクトルの外戚は次のように計算されます。
<pre class = sf>
`Λ([`1,`0,`1,`0], [`1,`1,`1,`1])
</pre
-->

<p>
<p>
<p>

<h3>ClTensor ^ operator</h3>
<p>
ClTensor が numpy array と大きく異なる点の一つが ^ operator 拡張をしている点です。

<h2>■■ 一般体行列とその操作詳細</h2>
<p>
Bool 体、など、一般体の行列を独立に実装する必要があります。ClFldTns として ClTensor, sc.array とは独立して実装してあります。
<p>
scipy.py の行列には object タイプの行列があります。

ar=sc.array([oc.Pl(oc.RS(2), 1), oc.Pl(oc.RS(4), 1)], dtype=object);ar+ar
===============================
[0 0]

ar=sc.array([oc.Pl(oc.RS(2), 1), oc.Pl(oc.RS(4), 1)], dtype=object);ar oc.RS(5)
===============================
[0x0ax+0x05 0x14x+0x05]

ベクトル演算は可能です。

ar=sc.array([oc.Pl(oc.RS(2), 1), oc.Pl(oc.RS(4), 1)], dtype=object);sc.dot(ar, ar)

下と同じです。
oc.Pl(oc.RS(2),1)^2+ oc.Pl(oc.RS(4), 1)^2


ar=~[`1,`0,`1,`1]
===============================
[1 0 1 1]
---- ClFldTns:<class 'pysf.octn.BF'> ----

ar=~[`1,`0,`1,`1];ar[3]=4;ar
===============================
[1 0 1 4]
---- ClFldTns:<class 'pysf.octn.BF'> ----

<h4>normalize</h4>
<p>

<pre class = sf>
normalize([1,2,3])
===============================
[ 0.26726124  0.53452248  0.80178373]
---- ClTensor ----

normalize(`σx)
===============================
[[ 0.          0.70710678]
 [ 0.70710678  0.        ]]
---- ClTensor ----

normalize(`εL)
===============================
[[[ 0.          0.          0.        ]
  [ 0.          0.          0.40824829]
  [ 0.         -0.40824829  0.        ]]

 [[ 0.          0.         -0.40824829]
  [ 0.          0.          0.        ]
  [ 0.40824829  0.          0.        ]]

 [[ 0.          0.40824829  0.        ]
  [-0.40824829  0.          0.        ]
  [ 0.          0.          0.        ]]]
---- ClTensor ----

norm(normalize(`εL))
===============================
1.0
</pre>

<h4>norm</h4>
<p>
できるだけ多くの対象の norm を計算しようと努力しています。数値をもつコンテナ：リスト・タプル、辞書、ベクトル、行列、ClTensor の他に数値を返すイタレータも対象にします。
<p>
戻り値は double 精度の浮動小数点値になります。
<pre class = sf>
        norm( 1, 1, 0, 0, 1, 1 ) == 2

        norm(dict([(0, 1.2),(1, 5)]))
        ===============================
        5.14198405287

        norm(`σx)
        ===============================
        1.41421356237
        
        norm(`εL)
        ===============================
        2.44948974278
        norm(set([1,2,3]))
        ===============================
        3.74165738677
</pre>
<h4>normSq</h4>
<p>
norm(..) と normSq(..) は殆ど同じです。
<p>
戻り値が norm(..) の自乗値になっていることと、integer 要素のコンテナについては integer 値になることが異なります。
<pre class = sf>
        nearlyEq(normSq([1,2,3]), 14)
        ===============================
        True
        nearlyEq(normSq(dict([(0, 1.2),(1, 5)])), 26.44)
        ===============================
        True
        nearlyEq(normSq(`σx), 2)
        ===============================
        True
        nearlyEq(normSq(`εL), 6)
        ===============================
        True
        normSq([2^30]) == 2^60
        ===============================
        True
</pre>
<h4>zeros</h4>
<p>

<h2>■■ シンボル式行列とその操作詳細</h2>
<p>
sympy のシンボルを使って行列操作を行うことも可能です。
<pre class = sf>
tr();mt=ts.Matrix([[`x,`y],[`x+`y,1]])
===============================
[    x, y]
[x + y, 1]

tr();mt=ts.Matrix([[`x,`y],[`x+`y,1]]);mt ts.Matrix([`x,`y])
===============================
[  x**2 + y**2]
[y + x*(x + y)]

tr();mt=ts.Matrix([[`x,`y],[`x+`y,1]]);mt^2 ts.Matrix([`x,`y])
===============================
[       x*(y*(x + y) + x**2) + y*(y + x*y)]
[x*(x + y + x*(x + y)) + y*(1 + y*(x + y))]
</pre>
<p>
でも、シンボル式の演算結果が簡約されているわけではありません。
<pre class = sf>
tr();mt=ts.Matrix([[`x,`y],[`x+`y,1]]);mt^-1
===============================
[y*(x + y)/(x**2*(1 - y*(x + y)/x)) + 1/x, -y/(x*(1 - y*(x + y)/x))]
[          -(x + y)/(x*(1 - y*(x + y)/x)),      1/(1 - y*(x + y)/x)]
</pre>
<p>
上のような逆行列式が計算されたとき

<h2>■■ シンボル式の操作</h2>
<p>
sympy モジュールの機能を使うことで、python／python sf でもシンボル式を扱えます。
<h4>`x,`y,`z, `t, `p, `q シンボル</h4>
<p>
<pre class = sf>
tr();(`x,`y,`z, `t, `p,`q)

tr();(ts.S('(x+y+z)*(x+y)')).expand()
===============================
x*z + y*z + 2*x*y + x**2 + y**2
</pre>

<h4>ts.S(..文字列..)式</h4>
<pre class = sf>
tr();(ts.S('(x+y+z)*(x+y)')).expand()
===============================
x*z + y*z + 2*x*y + x**2 + y**2
</pre>
<p>
でも x,y,z シンボルが定義されるわけではありません。
<pre class = sf>
tr();(ts.S('x+y+z')).subs([(x,0),(y,1),(z,2)])
name 'x' is not defined at excecuting:(ts.S('x+y+z')).subs([(x,0),(y,1),(z,2)])
</pre>

<h3>■ Float/Complex</h3>
<h4>単位付 sympy 式と Float/Complex</h4>
<p>
sympy シンボル式の計算結果が数値になったとしても、それは sympy の数値です。scipy などの関数引数には使えません。なので python の float/complex 型の変数にする必要があります。
<p>

tr();`Rat(1,3)
===============================
1/3

tr();`Rat(1,3) * 2.0
===============================
0.666666666666667

tr();float(`Rat(1,3))
tr();float(`Rat(1,3))*2.0
tr();type((`Rat(1,3))*2.0)
===============================
<class 'sympy.core.numbers.Real'>

tr();type(float(`Rat(1,3))*2.0)
===============================
<type 'float'>

tr();type(float(`Rat(1,3)))
ts()
<h4>sympy 関数式と Float/Complex</h4>
<p>
また sympy 関数式に引数を与えて数値を出させるとき .subs(...) と書かねばなりません。これは書くのも読むのも面倒です。


`x,`y,`z,`t, `p,`q のシンボルで記述される sympy 式に限定されますが、これらの式は Float(式, 引数値) または Complex(式, 引数値) で float/complex 値を返すようにしたくなります。その機能を Float/Complex 関数に実装しました。F:\my\vc7\mtCm>

<p>
関数側で sympy.core.numbers.Real/Complex を受け付けるようにする考え方はとれません。sin,cos などの基本関数に限れば、そのようにできます。でも ClRtnl など python で定義される関数の大部分は sympy.core.numbers.Real/Complex については考慮していない関数だからです。
<p>
もし無理やりに sin,cos.. などの基本関数を「sympy.core.numbers.Real/Complex を受け付ける関数に改造してやる」とすると、関数の動作に二種類のものができてしまうことになります。これ耐えられないことだと考えます。
<h2>■■ グラフ表示</h2>
<h3>表示したグラフの終了</h3>
<p>
特に専用のアイコンで書かれたボタンを用意しています。マウスで終了させたければ、ウィンドウの右上にある × をクリックしてください。
<p>
Windows 標準で備わっているキーボーデでの終了のやりかた:「ctrl+space --> C」  のほうが素早く衆力できると思います。

<h3>plotGr</h3>
<p>
plotG(..) は、最小の手間で一変数関数のグラフを描くことを目指した関数です。
help('plotGr')
plotGr(sin)
plotGr(sin,-pi,pi)
plotGr(sin,[-pi,pi])
plotGr(sin,klsp(-pi,pi))
plotGr(sin,[-3,-2,-1,0,2 4])
plotGr(sc.sin,[-3,-2,-1,0,2, 4])
plotGr(sin+cos,[-3,-2,-1,0,2 4])
       sin+cos([-3,-2,-1,0,2 4])
       sc.sin([-3,-2,-1,0,2 4])

<p>
引数に関数と lower bound, upper bound の値を与えることでグラフを表示できます

<pre class = sf>
plotGr(arctan, -3,3)
</pre>
<p>
plotGr(..) は、一変数のグラフ表示を最小の手間で行わせる関数です。
<p>
引数にリスト、タプル、scipy ベクトル、ClTensor ベクトルを与えることで、折れ線グラフを表示できます。長さを 32 以上にすれば曲線と変わらなくなってきます。
<pre class = sf>
plotGr([arctan(x) for x in klsp(-3,3)])
</pre>
<p>
引数に関数と [lower bound, upper bound] を分割したシーケンスまたはイタレーターを与えることでグラフを表示できます
<pre class = sf>
plotGr(arctan, klsp(-3,3))

plotGr(arctan( klsp(-3,3)))
<== plotGr(arctan( klsp(-3,3))) はufunc である必要がある
    <== arctan( klsp(-3,3)) がベクトルを返す関数であることを前提としているから
        <== 1 引数だけだから
</pre>
<p>
グラフの色指定と重ね合わせ表示が可能です。
<pre class = sf>
plotGr(arctan, -3,3);plotGr(cos, -2,1, color=red)
</pre>
注意
plotGr(arctan, [-3,3]) の書き方をしないでください。

plotGr([arctan(-3),arctan(3)]) の意味になります。二点を結んだ直線になります。
plotGr(arctan, -3,3) の書き方をする必要があります。
<== 数学で関数の定義域を [-3,3] と表すことが多いので、誤って書いてしまうことがあります。
    <== python では [...] はリストをあらわします。
        <== plotGr([...]) はリストをグラフ化します。

<h3>plotTmCh</h3>
<p>
plotGr(..) は重ねがきはできますが、ディジタル信号のタイムチャートのように複数の信号を表示するのに向きません。そこで plotTmCh(..) に　行列データを与えることで、タイムチャート表示を可能にしました。
<pre class=sf>
help(plotTmCh)
plotTmCh(vctMtrxAg)
    ' plot time chart for vector,array or matrix dictionary data
    '
</pre>
<p>
1,0 のデジタル信号だけに限らず、アナログ信号の複数表示も可能になっています。
<pre class=sf>
example
</pre>
<h2>■■ Basic Functions</h2>
<p>
basicFnctns.py に入っている基本関数群についての説明です
<h3>ClAF/ClAFM</h3>
<p>
ClAF/ClAFM は、関数の加減乗と合成を可能にする関数のラッパー・クラスです。ClAF が一変数のみの引数の関数のためのラッパークラスです。ClAFM は多変数引数のラッパー・クラスです。
<p>
下のように、ClAF(.) でラップされた一変数関数は絵加減乗算が可能になります。
<pre class = sf>
    f,g=ClAF(sin), ClAF(cos);  f(2 f g + 3 g)(pi/3)
    ===============================
    0.700121217943
</pre>
<p>
関数の除算は入れていません。0 div エラーを嫌ったためです。
<p>
下の関数 g の戻り値が [2x+y, x+2y] と長さ 2 のシーケンスになっています。これにより f(..) の二個の引数と合成が可能になっています。
<pre class = sf>
    f, g =ClAFM(arctan2),ClAFM(λ x,y:[2x+y,x+2y]); f(g)(5,6)
    ===============================
    0.755104403479
</pre>

<h3>putPv</h3>
<p>
sf.putPv(..) 関数は行列値など、Python でのインスタンス一般を python の pickle 機能を使って、カレント・ディレクトリに保存しています。残念ながら、pickle ではテキスト・ファイルで保存するのですが、その中身は人間が読むようには作られていません。行列以外のインスタンスもテキストで保存することを想定すれば納得してもらえると思います。

でも Python sf で使う ClTensor のインスタンスならば、人間が読める形式で、カレント・ディレクトリに保存します。

<pre class = sf>
putPv(~[[16,3,2,13],[5,10,11,8],[9,6,7,12],[4,15,14,1]], "magic")

Python sf プリプロセッサは 「:=」によるアサインでも putPv(..) の機能を行わせます
magic:=~[[16,3,2,13],[5,10,11,8],[9,6,7,12],[4,15,14,1]]
===============================
[[ 16.   3.   2.  13.]
 [  5.  10.  11.   8.]
 [  9.   6.   7.  12.]
 [  4.  15.  14.   1.]]
---- ClTensor ----
</pre>
<p>

そのテキスト・ファイルは、下のように人間が読めます。
<pre class = dos>
type magic.pvl

# python object printed out by pprint
ClTensor([[ 16.,   3.,   2.,  13.],
       [  5.,  10.,  11.,   8.],
       [  9.,   6.,   7.,  12.],
       [  4.,  15.,  14.,   1.]])
</pre>

<h3>getPv</h3>
<p>
putPv(..) でカレント・ディレクトリに作られたファイル変数は getPv(...) で読み戻せます。Python sf プリプロセッサでは「=:」によっても、読み戻せます。
<pre class = sf>
magic = sf.getPv('magic')
下のように読み出したほうが python sf らしいでしょう。
=:magic; 2 magic
===============================
[[ 32.   6.   4.  26.]
 [ 10.  20.  22.  16.]
 [ 18.  12.  14.  24.]
 [  8.  30.  28.   2.]]
---- ClTensor ----
</pre>


<h3>combinate</h3>
<p>
n 個の組み合わせを返すジェネレータです。
辞書式順序で返します。
<pre class = sf>
list(combinate(list('abcd'),3))
===============================
[('a', 'b', 'c'), ('a', 'b', 'd'), ('a', 'c', 'd'), ('b', 'c', 'd')]

list(combinate([0,1,2,3],2))
===============================
[(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]
</pre>

<h3>permutate</h3>
<p>
シーケンス引数に対する順列組み合わせを順次返していくイタレータを生成します
<pre class = sf>
    tuple(sf.permutate([2,1,0]))
    ===============================
    (((2, 1, 0), 1), ((2, 0, 1), -1), ((1, 2, 0), -1), ((1, 0, 2), 1)
            , ((0, 2, 1), 1), ((0, 1, 2), -1))

    tuple(sf.permutate([0,1,2]))
    ===============================
    (((0, 1, 2), 1), ((0, 2, 1), -1), ((1, 0, 2), -1), ((1, 2, 0), 1)
            , ((2, 0, 1), 1), ((2, 1, 0), -1))

</pre>
<h3>compose</h3>
<p>
一変数関数の組から、合成関数を作って返します。cmps の別名を定義してあります。
<pre class = sf>
    compose(sin, cos)(0)
    ===============================
    0.841470984808
    
    compose(λ x:x^2, λ x:x*2)(3.0)
    ===============================
    36.0
</pre>

<h2>■■ kNumeric scipy インターフェース</h2>
<h3>微分</h3>
<h3>積分</h3>
<h4>qdrt:積分</h4>
<p>
関数 f(x) を区間 [a,b] で積分します。
<pre class = box>
                      b
   qdrt(f,  a, b) ≡ ∫ f(x) dx
                      a
</pre>
<pre class = sf>
qdrt(sin,0,pi)
===============================
2.0

qdrt(sin, pi, 0)
===============================
-2.0

</pre>
<p>
scipy の integrate.quad を殆どそのまま使っています。これは適応的自動積分のアルゴリズムで積分しており、被積分関数の変動がが激しい箇所では積分点を細かく取り、穏やかな箇所では粗く取る積分アルゴリズムです。
<p>
積分範囲を ∞:sf.inf にまで広げられます。
<pre class = sf>
qdrt(λ x:exp(-x^2), -sc.inf, sc.inf)
===============================
1.77245385091

  +∞
 ∫     exp(-x^2) dx
  -∞


√π;; sqrt(pi)
===============================
1.77245385091
</pre>
<p>
ただし、sc.inf を含む積分範囲は、大小関係を逆転させないで下さい。エラーになります。
<pre class = sf>
qdrt(λ x:exp(-x^2), sc.inf, -sc.inf)
(33, 'Domain error') at excecuting:qdrt(lambda x:exp(-x**2), sc.inf, -sc.inf)

</pre>

<p>
scipy.integral の quad 積分は、その計算精度と組で結果を返すので、電卓的な用途では面倒になることが多いので qdrt を設けました。計算精度が必要なときは、quad を使ってください。

<pre class = sf>
si.quad(sin, 0,pi)
===============================
(2.0, 2.2204460492503131e-014)
</pre>

<h4>quadAn:解析関数の線積分</h4>
<p>
quadAn(..) は複素平面状での線積分を行います。。引数に解析関数と その積分経路のシーケンスを与えることで、積分経路に沿った積分値を計算します。
<pre class = sf>
quadAn(λ z:1/z, [1+`i,1-`i, -1-`i,-1+`i,1+`i])
===============================
(-6.2831853071795871j, 3.0615980059724259e-014, 6.9757369942584612e-014)

quadAn(λ z:  z**2, [1+`i,1-`i, -1-`i,-1+`i,1+`i])
===============================
(0j, 7.3849307489406795e-014, 7.3849307489406795e-014)

quadAn(λ z:1/z**2, [1+`i,1-`i, -1-`i,-1+`i,1+`i])
===============================
(0j, 5.0593736107878128e-014, 5.0593736107878128e-014)
</pre>
<p>
ただし解析関数は多価関数になりうるにも関わらず scipy で実装されている解析関数は、主値のみを返す一価関数であることに注意してください。
<pre class = sf>
quadAn(log, [1+`i,1-`i, -1-`i,1-`i,1+`i])
===============================
(-2.2204460492503131e-016j, 3.238252998456195e-009, 3.2383033509434062e-009)
</pre>
<p>
注意１!! quadC による複素数平面での計算には、∫計算での誤差が付きまといやすい。特に複素平面での exp で発散していくときに数値積分計算に、大きな誤差が付きまとう。複素平面での値分布をイメージできていないときは、quadC ではなく quadAn を使うべき。quadAn は、計算結果の誤差推定値を出してくれるから。

<p>
注意２!! si.quad には、被積分変数以外のパラメータのタプルをを args キーワード引数を使って渡せます。でも quadAn(..) では、まだ そこまでの実装をしていません。 quadC は引き渡せるようにしました。

<h4>quadN:多次元空間での線積分</h4>
<p>
quadGN(..) は、N 次元空間での N 次元ベクトル分布の線積分を計算します。
<p>
下では三次元空間での電場分布に対して線積分を計算させています。
<pre class = sf>
    vctE = λ vctP:vctP/norm(vctP);quadN(vctE, ([1,1,1],[1,2,3]) )
    ===============================
    (2.0096065792050641, 2.2311114946716608e-014)
    
    vctE = λ vctP:vctP/norm(vctP);quadN(vctE, ([1,1,0],[1,-1,0],[-1,-1,0],[-1,1,0],[1,1,0]) )
    ===============================
    (2.8130846960094083e-017, 3.6623805685846749e-014)
</pre>

<h4>quadGN:多次元空間ての Gauss 積分法を使った線積分</h4>
<p>
quadGN(..) は、N 次元空間での N 次元ベクトル分布の線積分を、Gauss 積分法を使って計算します。quadN(..) は scipy.quad(..) を使って計算させていることだけが異なっています。
<p>
下では三次元空間での電場分布にたいし線積分を計算させています。
<pre class = sf>
vctE = λ vctP:vctP/norm(vctP);quadGN(vctE, ([1,1,1],[1,2,3]) )
===============================
(2.0096065781679306, 7.8044882778627311e-009)

vctE = λ vctP:vctP/norm(vctP);quadGN(vctE, ([1,1,0],[1,-1,0],[-1,-1,0],[-1,1,0],[1,1,0]) )
===============================
(0.0, 0.0)
</pre>

<h4>cOdeInt:複素数値微分方程式の積分</h4>
<p>
scipy.integrate.odein(..) を複素数値関数にも適用できるように拡張しました。
<p>
一次元調和振動子
<pre class = sf>
//@@
# 10.02.06 Harmonic Oscilator by step
import pysf.sfFnctns as sf
def func(psi, x):
    return 1/1j * psi

N = 30
#y = sf.cOdeInt( func, [1+1j, 0], sf.arSqnc(0,N,5.0/N) )
y = sf.cOdeInt( func, [1+1j], sf.arSqnc(0,N,5.0/N) )

print y
sf.plotTrajectory([(x.real, x.imag) for x in y[:,0]])
//@@@
//copy c:\#####.### temp.py /y
//temp.py
[[ 1.00000000+1.j        ]
 [ 1.15203938+0.82024708j]
 [ 1.27215166+0.61776221j]
 [ 1.35700810+0.39815699j]
 [ 1.40425705+0.16751743j]
 [ 1.41258907-0.06776463j]
 [ 1.38177327-0.30116869j]
 [ 1.31266364-0.5262263j ]
 [ 1.20717546-0.73670032j]
 [ 1.06823217-0.92675777j]
 [ 0.89968440-1.09113149j]
 [ 0.70620319-1.22526609j]
 [ 0.49315060-1.32544424j]
 [ 0.26643106-1.38888964j]
 [ 0.03232778-1.41384399j]
 [-0.20267144-1.39961575j]
 [-0.43205391-1.34659919j]
 [-0.64946264-1.25626361j]
 [-0.84887247-1.13111252j]
 [-1.02475703-0.9746143j ]
 [-1.17224196-0.79110607j]
 [-1.28723991-0.58567349j]
 [-1.36656389-0.36400983j]
 [-1.40801556-0.13225816j]
 [-1.41044613+0.10315884j]
 [-1.37378825+0.33571695j]
 [-1.29905785+0.55897116j]
 [-1.18832595+0.7667343j ]
 [-1.04466134+0.95324852j]
 [-0.87204547+1.11334484j]]
</pre>
<IMG SRC="./cOdeInt1D.jpg"> <br>

<p>
二次元調和振動子を複素領域での Hamiltonian で計算させる。一次元のときとはことなり、運動量成分：純虚数成分は表示しない。
<pre class = sf>

二次元調和振動子
初期位置 (1,0)
初期速度 (1,1): (1j,1j) での運動

            X' =ΔX/(Δ(`i t))= ∂H(Z)/∂P == -`i Z.imag
            P' =ΔP/(Δ(`i t))= ∂H(Z)/∂X ==  Z.real

H(p,x) = 1/2(x^2+p^2) == H(P,X) == 1/2(X^2 - P^2) where X∈real, P∈imaginaryNumber

//@@
# 10.02.06 Harmonic Oscilator by step
import pysf.sfFnctns as sf
def func(psi, x):
    return 1/1j * psi

N = 30
#y = sf.cOdeInt( func, [1+1j, 0], sf.arSqnc(0,N,5.0/N) )
y = sf.cOdeInt( func, [1+1j, 1j], sf.arSqnc(0,N,5.0/N) )

print y[:,0]
sf.plotTrajectory([(x[0].real, x[1].real) for x in y])
//@@@
//copy c:\#####.### temp.py /y
//temp.py
</pre>
<IMG SRC="./cOdeInt2D.jpg"> <br>

<p>
常微分方程式の右辺式の呼び出される時刻は scipy 側で定める。引数に与える時刻：sf.arSqnc(0,N,5.0/N) に右辺式を呼び出すわけではない
<pre class = sf>
//@@
import pysf.sfFnctns as sf

N=100
N=10

def func(x,t):
    print "Now in func. x=",x, "   t=",t
    return 1

y = sf.si.odeint( func, 1, sf.arSqnc(0,N,5.0/N) )
print y
sf.plotGr(y)
//@@@
//copy c:\#####.### temp.py /y
//temp.py
Now in func. x= [ 1.]    t= 0.0
Now in func. x= [ 1.00005921]    t= 5.92128761832e-005
Now in func. x= [ 1.00011843]    t= 0.000118425752366
Now in func. x= [ 1.59224719]    t= 0.592247187584
Now in func. x= [ 2.18437595]    t= 1.18437594942
Now in func. x= [ 2.77650471]    t= 1.77650471125
Now in func. x= [ 8.69779233]    t= 7.69779232956
[[ 1. ]
 [ 1.5]
 [ 2. ]
 [ 2.5]
 [ 3. ]
 [ 3.5]
 [ 4. ]
 [ 4.5]
 [ 5. ]
 [ 5.5]]
</pre>
<h3>nearlyEq:near 判定</h3>
<h4></h4>
<p>

<h3>others</h3>

<h4>dct2(sq)</h4>
<p>
<p>
dct2(sq) は、離散 Cos_II 変換を行います。<BR>
<pre class = sf>
dct2([0.7, 0.6, 0.95, 0.85,  0.55, 0.1, 0.68, 0.43])
===============================
[ 1.71826948  0.36452813 -0.08071514 -0.38011727  0.07071068  0.32186722
 -0.15790841  0.2548168 ]
---- ClTensor ----

dct2(range(32))
===============================
[  8.76812409e+01  -5.18555951e+01  -2.04281037e-14  -5.74305749e+00
  -5.32907052e-15  -2.05378057e+00   0.00000000e+00  -1.03699056e+00
  -1.15463195e-14  -6.18143249e-01   8.88178420e-16  -4.05658019e-01
   2.13162821e-14  -2.82932996e-01  -9.76996262e-15  -2.05367296e-01
   8.43769499e-14  -1.52902657e-01   3.64153152e-14  -1.15420131e-01
   1.42108547e-14  -8.73494434e-02  -4.39648318e-14  -6.53996651e-02
   1.02140518e-14  -4.75025193e-02  -3.28626015e-14  -3.22782075e-02
  -6.43929354e-15  -1.87448835e-02  -8.65973959e-15  -6.14826207e-03]
---- ClTensor ----
</pre>

<h4>compose(f,g)</h4>
<p>
compose(f,g)(x) は関数の合成：f(g(x))を行います。
<pre class = sf>
compose(sin, cos)(0)
===============================
0.841470984808

compose(λ x:x^2, λ x:x*2)(3)
===============================
36
</pre>
<p>
cmps の別名も、compose と全く同じものです。

<h4>bin(..)</h4>
<p>
整数値を binary 表記したときの文字列を返します。Python 3000 のバイナリ表記と同じです。

<h4>bin_(..)</h4>
<p>
整数値を binary 表記したときの文字列を返します。引数が浮動小数点でも整数にしてしまいます。デフォルトでは 0 が連続する上位ビットは表示しません。二番目の引数に 1 以上のビット・サイズを指定医すると、その 0 ビットが連続する上位ビットも表示するようになります。
<p>
4 ビットごとに '_' を挿入することで、ユーザーにビット位置を解りやすくします。
<p>
二番目のビット長を指定する引数よりも、一番目の数値によるビット長を優先します。
<pre class = sf>
bin_(16)
===============================
0b1_0000

bin_(16, 32) # 32bit length
===============================
0b0000_0000__0000_0000___0000_0000__0001_0000

bin_(16.125)
===============================
0b1_0000

bin_(256+33, 5)  # not five digit
===============================
0b1__0010_0001
</pre>

<h4>pp(..)</h4>
<p>
行列・ベクトルデータの pretty print です。小数点以下の値が 0 ならば浮動小数点値でも、少数点以下を表示しません。複素数で実数成分／純虚数成分のどちらかが 0 のときは、それを表示しません。
<p>
行列・ベクトル・データをできるだけ簡単な、手で書くときに近い表示で表現します。特に複素行列の表示に有効です。
<pre class = sf>
pp(~[3.5, 4.0, 7.1])
[ 3.5,   4, 7.1]
-------- pp --
===============================
None

   `σy 
===============================
[[ 0.+0.j  0.-1.j]
 [ 0.+1.j  0.+0.j]]
---- ClTensor ----

pp(`σy)
[[  0, -1j]
,[ 1j,   0]]
-------- pp --
===============================
</pre>

<h4>invF</h4>
sciIntf.py
<p>
invF に「実数を引数とし実数を戻り値とする一変数の関数：f」を与えると、f の逆関数を返します。デフォルトでは [-1,1] の定義域から f(x) == 値 を満たす x を scipy.optimize.brentq を使って探します。

<pre class = sf>
invF(arctan)(0.5)
===============================
0.546302489844

invF(arctan)(1.1)
f(a) and f(b) must have different signs at excecuting:invF(arctan)(1.1)
</pre>
<p>
brentq を使うため「invF(f, rangeLeft=-1,rangeRight=1)(a)」を計算するためには「 f(rangeLeft) &lt; a &lt; f(rangeright)」をユーザーは保証せねばならない。
<!-- invF は 機能からすれば basicFnctns.py に入れたい。so.brentq を使うため sciIntf に入れている
    <== numpy で済ませられるのならば basicFnctns.py でも良い？
    <== basicFnctns.py は numpy なしでも動くようにしたい
    <== λ しか使わないユーザーにも python sf を使ってもらうため
->

<h2>■■ tlRcGn 再帰・繰り返し</h2>
<p>
<pre class=box>
//@@
import time
startTimeAt = time.time()

import os
os.system("""python -m sfPP 3+4""")

print "Total executing time:",time.time() - startTimeAt
//@@@
Enthought 2.6 in MSI pysf0.95 customizeBig.py
protect 止め:ipconfit /all を実行しない
import tlRcGn as tn を customizeMiddle.py に追加
C:\my\vc7\mtCm>python temp.py
===============================
7
Total executing time: 2.59399986267
Total executing time: 1.60899996758
Total executing time: 1.60899996758
Total executing time: 1.60899996758
Total executing time: 1.60899996758
Total executing time: 1.625
Total executing time: 1.625
Total executing time: 1.60899996758
Total executing time: 1.60899996758
Total executing time: 1.60899996758


F:\my\vc7\mtCm>python temp.py
===============================
7
Total executing time: 3.61000013351
Total executing time: 2.5
Total executing time: 2.65600013733
Total executing time: 2.56299996376
Total executing time: 2.56299996376
Total executing time: 2.54700016975
Total executing time: 2.60899996758
Total executing time: 2.71900010109
Total executing time: 2.625
Total executing time: 2.54700016975


Enthought 2.6 in MSI pysf0.95 customizeMiddle
protect 止め:ipconfit /all を実行しない
import tlRcGn as tn を customizeMiddle.py に追加

C:\my\vc7\mtCm>python temp.py
===============================
7
Total executing time: 1.10899996758
Total executing time: 0.93799996376
Total executing time: 0.921999931335
Total executing time: 0.93700003624
Total executing time: 0.953999996185
Total executing time: 0.953000068665
Total executing time: 0.953000068665
Total executing time: 0.93700003624
Total executing time: 0.952999830246
Total executing time: 0.953000068665

F:\my\vc7\mtCm>python temp.py
===============================
7
Total executing time: 1.79699993134
Total executing time: 1.81200003624
Total executing time: 1.625
Total executing time: 1.54699993134
Total executing time: 1.51499986649
Total executing time: 1.5
Total executing time: 1.64100003242
Total executing time: 1.51600003242
Total executing time: 1.51600003242
Total executing time: 1.57800006866



Enthought 2.6 in MSI pysf0.95 customizeMiddle
protect 止め:ipconfit /all を実行しない

C:\my\vc7\mtCm>python temp.py
===============================
7
Total executing time: 1.07799983025
Total executing time: 0.968999862671
Total executing time: 0.93799996376
Total executing time: 0.93700003624
Total executing time: 0.93700003624
Total executing time: 0.952999830246
Total executing time: 0.93700003624
Total executing time: 0.93700003624
Total executing time: 0.922000169754
Total executing time: 0.93799996376
Total executing time: 0.93799996376

F:\my\vc7\mtCm>python temp.py
===============================
7
Total executing time: 3.26599979401
Total executing time: 1.51600003242
Total executing time: 1.57800006866
Total executing time: 1.54600000381
Total executing time: 1.56299996376
Total executing time: 1.67199993134
Total executing time: 1.51600003242
Total executing time: 1.53100013733
Total executing time: 1.48399996758
Total executing time: 1.54699993134

</pre>
<h3>■ 無限数列</h3>
<p>
python には itertools という標準モジュールがあります。遅延評価されるジェネレータを繰り返し記述に便利に使うための機能をまとめています。
<p>
でも itertools は数列・級数を扱うのには適していません。[..] によるインデックス機能がないからです。逆に itertools にインデックス機能を追加してやれば無限列を扱えるようになります。
<h4>mkSrs(..): 関数引数から無限数列の生成</h4>
<p>
mkSrs は make infinite series の省略形です。
<p>

<pre class = sf>
N=5;tn.mkSrs( λ n:0.75^n sin(n pi/6) )[:N]
===============================
[0.0, 0.37499999999999994, 0.4871392896287467, 0.421875, 0.27401585041617005]

</pre>

<h2>■■ vsGraph</h2>
<h2>■■ rational ClRtnl</h2>
<pre class = sf>
( (`s-1)/(`s+1) ).plotBode(0.001,100)
</pre>
<h2>■■ octn.py</h2>
<h2>■■ symIntf</h2>
<h2>■■ kmayavi</h2>
<h2>■■ kre.py</h2>
<h2>■■ cusomize.py</h2>

<h3>■ 微分</h3>
∂x
∂t
∂p,∂q は？
tr();∂x(`x)
tr();∂p(`p^2)
===============================
2*p

<h2>■■ モジュールごとの時間負荷</h2>
<h2>■■ kv：テスト</h2>

<h3>scalarStt</h3>
<p>
scalarStt に値が設定されるのは、python sf 計算結果が実数・複素数値のときです。
<p>
コンピュータでの実数・複素数計算値には誤差がつき物です。理論値どおりにはなりません。kVerifier では、実数型の変数については誤差を許容する比較を行います。デフォルトで 1e-6 以下の誤差ならば __compare は正しいと判断します。
<HR>
<ADDRESS>
    mailto: your@email.ne.jp<br>
    Last update: 
</ADDRESS>
</BODY>
</HTML>
