<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HEAD>
<TITLE>one-liners</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Shift_JIS"> 
<LINK href="./style.css" type="text/css" rel="stylesheet">
<STYLE>
</STYLE>
</HEAD>
<BODY>

<H1 class=title>■■ PythonSf one-liners and short codes ■■</H1>
<h2>■■ Table Of Contents  </h2>
<a href="#■■ はじめに">■■ introduction</a><br>
<a href="#■■ Portable PythonSf">■■ Portable PythonSf</a><br>
<a href="#■■ PythonSf vim operation">■■ PythonSf vim operation</a><br>
<a href="#■■ PythonSf Fast Tour">■■ PythonSf Fast Tour</a><br>
<a href="#■■ グラフ表示">■■ グラフ表示</a><br>
<a href="#■■ 積分:quadR(..), quadC(..), quadAn(..)">■■ 積分:quadR(..), quadC(..), quadAn(..)</a><br>
<a href="#■■ 行列演算 2">■■ 行列演算 2</a><br>
<a href="#■■ 代数系">■■ 代数系</a><br>
<a href="#■■ 多項式">■■ 多項式</a><br>
<a href="#■■ 無限長数列と itertools">■■ 無限長数列と itertools</a><br>
<a href="#■■ その他">■■ その他</a><br>
<a href="#■■ Laplace 演算子:`s および遅延演算子 z^-1">■■ Laplace 演算子:`s および遅延演算子 z^-1</a><br>
<a href="#■■ 置換群：Sn(N)">■■ 置換群：Sn(N)</a><br>
<a href="#■■ PythonSf を使った遊び">■■ PythonSf を使った遊び</a><br>
<a href="#■■ 正規表現">■■ 正規表現</a><br>
<a href="#■■ PythonSf Octernion と Cayley/Dickson construction">■■ PythonSf Octernion と Cayley/Dickson construction</a><br>
<a href="#■■ Category Theory">■■ Category Theory</a><br>
<a href="#■■ オペアンプ・フィルタ回路">■■ オペアンプ・フィルタ回路</a><br>
<a href="#■■ Fractal 図形">■■ Fractal 図形</a><br>
<a href="#■■ wav データ処理">■■ wav データ処理</a><br>

<a name="■■ はじめに"></a>
<h2>■■ introduction</h2>
<!--
PythonSf とは？
    エディタ上でのメモ書き数式
    プリプロセッサ
    Python Upper compatible
    カスタマイズ

短い数式記述
-->
<p>
PythonSf is short for Python Scientific Functional math software. It has computing abilities as overwhelming as that of Matlab/Mathematica with the handiness of a calculator. PythonSf is a scripting language of mathematical softwares.
<p>
Daring to implement it as a console program, <b>it is enabled to calculate daily memo writing expressions that are written on your editor</b>, and the user interface inputting expressions is suited for each user. 
Intervening a preprocessor, we reconcile upper compatibilities for Python and memo writing mathematical expressions, such as enabling the abbreviation of a product operator. 
Moreover, by extension of name space and customization features, it is enabled to use mathematical expressions that are appropriate for your special fields of study. The extensions enable you to use one-liner descriptions maintaining readability and short formula. 
Probably a large majority of users can solve 90 percent or more of their daily mathematical problems with one-liners. 
Moreover, you can execute arbitrary Python one-liner codes. We show some examples below. 
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
# four numeric operations and exponent operation
(1-2*3/4)^5
===============================
-0.03125

# sin(1/x) value at x=pi
sin(1/`X)(pi)
===============================
0.312961796208

# numerical differential value: sin(1/x) value at x=pi
∂x( sin(2/`X) )(`π)
===============================
-0.162946719226

# symbolic differentiation: sin(1/x)
ts(); ∂x( ts.sin(1/`x) )
===============================
-cos(1/x)/x**2

# symbolically calculate Groebner bases
ts();x,y,z=ts.symbols('x y z');f1,f2,f3=[x+y^2+3z^2-4, 4y^2-5,y^4-5z-10]; ts.groebner([f1,f2,f3], [x,y,z])
===============================
[-5/4 + y**2, 1483/256 + x, 27/16 + z]

# multiply a matrix and a vector
#  |1,2| * |5|
#  |3,4|   |6]
mt,vc=~[[1,2],[3,4]], ~[5,6]; mt vc
===============================
[ 17.  39.]
---- ClTensor ----

# W:Watt、A:Ampere, numeric calculation with units
ts(); wattage,current=100W`,2.3A`; wattage/current^2
===============================
18.9035916824197*V`/A`

# quotient and residuum for a polynomial that has Bool field coefficients
(`P^7+1)/(`P^2+1)
===============================
(Pl(`P^5+`P^3+`P), Pl(`P+1))

x=`P; (x^7+1)%(x^2+1)
===============================
`P+1

# elliptic function:calculate the first kind/Jacobi elliptic function
φ,m=pi/3,0.6; sy(); u=ss.ellipkinc(φ,m); ss.ellipj(u,m)
===============================
(0.8660254037844386, 0.50000000000000011, 0.74161984870956643, 1.0471975511965976)

# left coset of {Sb(2,3,0,1), Sb(1,0,3,2),Sb(1,3,2,0)} in Sn(4)
=:SS4; SS4/{Sb(2,3,0,1), Sb(1,0,3,2),Sb(1,3,2,0)}
===============================
kfs([Sb(0,1,2,3), Sb(0,1,3,2), Sb(0,2,1,3), Sb(0,2,3,1), Sb(0,3,1,2), Sb(0,3,2,1)])

# Python test code that calculate hash value of a number:1234 and a character:1
hash(1234), hash('1')
===============================
(1234, 1977051568)

# graph drawing: sin(1/x) on [0.2, pi]
plotGr( sin(1/`X), 0.2, pi )
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/plotGrSin1_x.jpg">
<p>
In above mathematical expressions `X is a variable in extended name space using the back quote character. We have assigned a identity function for `X which is operated by addition, subtraction, multiplication,division, exponentiation and functional composition. This enables us to use computable notations which are memo writing mathematical expressions. Similarly we have assigned a Bool field coefficient unary polynomial for which is also operated by addition, subtraction, multiplication,division, exponentiation. So you can calculate Bool coefficient polynomials as almost the same as memo writing mathematical expressions.
<p>
Furthermore PythonSf approximates to mathematical expressions in textbooks using special kanji characters:∂∇□△ and Greek kanji characters:α,β,γ, ... .
<p>
~[...] describes a vector or matrix. It plots a graph to call plotGr(..) with a function name and the area parameters。Both aims to use the least number of characters for calculating matrices or drawing graphs.

<h3>PythonSf one-liners</h3>
<p>
You will use many one-liners using PythonSf. If you use a number of Python expressions or statements, you must insert a semicolon between them. All upper examples are written in one-liners.
<p>
Please take notice printing the value of the last expression without a printing instruction. If you calculate expressions/statements at a one-liner, you would want to know the last expression value, so PythonSf automatically prints the value in console.
<p>
In Mathematics, expressions reconcile shortness ans readability. PythonSf also pursuits the shortness and readability. It is an example to print out the last expression's value in a one-liner.

<h3>PythonSf has computing abilities of Matlab/Mathematica</h3>
<!--
np: Numpy package は import numpy as np と import ずみ
sy() 関数を呼び出すことで SciPy package/sub_package を sy, ss, .... などの名前で import
一般体への拡張
    oc.Pl([1,2,3,4,5,6])
    # 多項式割り算の商と剰余
    oc.Pl([1,2,3,4,5,6])//oc.Pl([1,1,1])
customize
-->
<p>
At the first paragraph, we said &quot;PythonSf has computing abilities of Matlab/Mathematica&quot;. This is not a delusion of grandeur or a big talk. Because PythonSf is Python upper compatible and can use all functions in any Python package/module and have powerfull customizing functions..
<p>
At PythonSf it imports SciPy package and it's sub packages to call sy() function. SciPy package implements many Matlab functions that are practically enough. sy() imports special function sub package as ss so that we call elliptic functions:ellipkinc, ellipj under ss label.
<p>
And to call ts() imports simpy as ts and assign sympy symbolic variables to `x,`y,`z,`t labels. So you can operate symbolic operations and symbolic expressions. The upper example differentiates symbolically.
<p>
And another thing, we extends matrix/vector to deal with general fields, so that you can calculate Zp(n) or polynomials which have Zp(n) coefficients. Further more we had implemented permutation group Sn(N) class and rational expression class which deal with Laplace transformation or z transformation.
Standard Python has mathematical abilities that undergraduates need. 
<p>
If you need higher mathematical abilities, you can implement yourself with Python language and PythonSf customizing abilities. It is easy.
<h3>It is easy to learn PythonSf</h3>
<p>
Though PythonSf can dieal with huge mathamatical areas, the larning cost of PythonSf might be one day if you are familiar with Python. Because the syntax of PythonSf is that of Python and upper compatible with Python. PythonSf preprocessor is only getting up to mathematical form. You need only to learn about labels which correspond to PythonSf objects. For example, label ss corresponds to special function subpakcage in scipy and `x,`y,`z correspond symbolic variable in SymPy. Only if you can memorize these labels then you can estimate PythonSf expressions by analogy with mathmatics and Python Syntax. Many might be able to calculte with PythonSf than scientific functional calculators only look at upper examples.
<p>
Althour you are a heavy user of a exsiting mathematical software, if you are a Python user we exhort you to use PythonSf. Python is a scripting language. You can calculate as same as memo writinge mathematical expressions. If you are a hevey user of another mathematical soiftware, you will use PythonSf more frequently because you can calculate more shortly and easyly with PythohSf. 
<p>
At PythonSf discripting power of mathematical expression is give from customizablities that are expalined the next section.
<h3>short descripotions of mathematica expression and custimizablities</h3>
<!--
Sb, `P
customize.py(python path にある), sfCrrntIni.py(current directory にある) の両方を import * してからユーザーが記述した PythonSf 式を実行しています。 
from pysf.ptGrp import kfs,Cy,group,Sb, TyZp, ClZp
グラフ関数
-->
<p>
Desirable abilties of mathematical software might differ for areas where each user specailizes. Many users must customize a mathematical software. Many users migh customize their mathematical software from necessity. Adversely many users might desire a easy customizable mathematical softwares
<p>
At PythonSf you can customize it assigning short length labels at a xtended name space in customize.py or sfCrrntIni.py where you assign the labels desirable Python objects using Python program codes. You must put customize.py at Python path and sfCrrntIn.py at a currnt directory here. Python sf does &quot;from customize import *&auot;,&quot;from sfCrrntIni import *&quot;. So in the global namespace, we get all the variables, functions, classes, and class instances those are defined in customize.py or sfCrrntIni.py
<p>
For the upper instance, `P is a Bool field coefficient unary polynomial. We implement this writing a below code in customize.py. And pre-processor  substitutes `P to k_bq_P___. So the PythonSf expression:(`P^7+1)/(`P^2+1) is converted to the code strings that Python can execute as a Python program codes. 
<pre>
<code>
<span style="color: #9f009f;">
class PB(oc.Pl):
    """' BF:Bool Field `P polynomial '"""
    def __init__(self, *sqAg):
        oc.Pl.__init__(self, dtype = oc.BF, variable='`P', *sqAg)

k__bq_P___ = PB(1,0)
</span>
</code>
</pre>
<p>
Users can freely import any module or package and assign any object to any label. If you assign some other instance to k__bk_P___, `P has the other meaning.
<p>
Please notice the extension of name space by back quote:`. It is too incautious to assign Bool field  coefficient unary polynomial to one character P, because unexpected results might occur by the collision of name. But `P restrict the collision within the area inside PythonSf expressions. It is not necessary to worry about collisions of name. So you can express short PythonSf form and calculate complex mathematical expressions. For real, you can calculate a division of Bool field coefficient polynomial by only (`P^7+1)/(`P^2+1) form.
<p>
You can describe customizations that is limited for an current directory if you write them in sfCrrntIni.py on the current directory. if you assign special equations to global variables in sfCrntIni.py that fill the needs for your special fields of study, then you can operates calculation with short PythonSf expressions.
<p>
If you customize PythonSf, you might solve 90 percent or more of your daily mathematical problems with PythonSf one-liners. You can freely set the customizations to calculate like (`P^7+1)/(`P^2+1).
<p>
Please notice that you explicitly condense your thinking given expressions.
<p>
At a notebook as of Mathematica, You can save calculation process and can refer it. But the great extents of it are rubbish. And it is difficult to sort out what are important expressions. Immediately after writing expressions it is useful because you still take the context and the important expressions in your brain. But after one year you must read the notebook from the beginning and reconstruct the context that you was thinking in long-ago days. You must work very hard to pick up important expression from the garbage and to reconstruct the old context.
<p>
In sfCrrntIn.py there are only important expressions that are referred many times. Eve after one year you can reconstruct the context that you was thinking after rereading sfCrrntIn.py. And you can redo the old one-liner expressions in remaining memo pads

<h3>PythonSf uses CUI beneficial in human interface</h3>
<!--
前後の文脈の影響を受けないことの方が多い
計算で GUI は面倒なだけ
    マウスを使うことなくキーボードだけで済ませられる
    漢字を使えば微分記号は ∂x で済ませられる
式を与えて計算させるだけ。
    途中で人間とやり取りする必要がありません。
エディタに組み込んで使う
-->
<p>
PythonSf uses CUI, not GUI. You need a mouse little more than viewing 3D graphs from some angles. GUI is inadequate for calculating software but in viewing graphs. Because you put a expression string and computer calculate it and return a resulting string. There is no need of dialog between computer and you in process of calculating. It also makes CUI useful to use kanji characters:∂∇□△ and kanji Greek characters:α β--- because it approximates mathematical expressions in textbooks.
<p>
It is adequate to input a mathematical expression string by using a favorite editor. Because a favorite editor is the best adequate method to input expressions. You only wait a resulting string, making computer to calculate the sting by the use of the editor macro to hand over it to PythonSf CUI interface.
<p>
You can make computer to calculate directly at a console window. You can calculate the Bool coefficient polynomial in a console window as below too.
<br>
<img src="./jpg/1111/sfPP_dosBoolPoly.jpg">

<p>
The point is giving a PythonSf expression string to sfPP.py pre-processor and calculating it. But we recomment using a editor macro to avoid giving the string python -u -m sfPP &quot...&quot as daily drudge and copying the resulting computed string. We strongly recomend to coding a editor macro that execute a connented string of quotpython -u -m sfPP&quot and a PythonSf expression string under the cursor. We go into detail <a href="#■■ PythonSf vim operation">here</a> about the Vim macro that executes Python Sf expressions and about the distribution. If you want to only evalate PythonSf then it may then you can use a console window.
<p>
We use one-liners heavily, calculating in an editor, customizing PythonSf for your special fields of study to calculate shortly.

<h3>You can solve a lot of problems using natural PythonSf one-liners</h3>
<p>
You you might solve 90 percent or more of your daily mathematical problems with PythonSf one-liners customizing PythonSf for you. You can change your mathematical thinking. You might copy out difficult abstruct mathematical reading textbooks as in group theory, category theory, special/general relativity. But you can go through them calculating illustrative examples, using PythonSf one-liners. This gives you to learn about them over a short time.
<p>
Here &quot;natural&quot; means no to include if-then-else syntax. You can use natural one-liners in calculating process much more times than usual program codings. Mathematics organizes theory perfectly and it is no use of if-then-else syntax in many cases. I there is no if-then-else syntax, then the codes lines without indents. If a program is made of codes without lines, then the program is readable though you align them horizontally and make a one-liner.
<p>
In natural one-liners, we don't include if-then-else syntax, but include for loop syntax, list comprehension syntax and if-then-else syntax after list comprehension. These don't make the readability worse. In a one-liner, you can do only one statement/expression in for loop syntax and you don't need the indent. You can naturally deal with multiple loop in a one-liner using a multiple range:mrng(..), a multiple iterator like mitr(..) or others. 
<p>
You can make a function reusable with a one-liner and a copy-and-paste by a editor. Please notice not only the easy operations using copy-and-past but also the easy thinking. A one-liner is a comprehensive function. A one-liner isn't be affected by previous codes. After one-year the one-liner works independently and comprehensively. You can reuse suchlike one-liners as unit parts when you pile up your thinking.
<p>
Definitely you must avoid unnatural one-liners. Don't use one-liners if you can't read the details. Definitely you can use block descriptions in PythonSf too. Please use block descriptions if one-liners are unnatural. Even then amount of the cods might be less than half.
<p>
Seeing is believing. Loot at below scripts that draw a figure eight orbit of 3 particles that move under the Newton mechanics. 
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf block</b>
//@@
# initial positions/vectors
inV=[-0.97,0.243,       # 0th particle initial position
      0.97,-0.243,      # 1st parcitle initial position
      0,0,              # 2nd parcitle initial position

     -0.466,-0.432,     # 0th particle initial velocity
     -0.466,-0.432,     # 1st particle initial velocity
      0.932,0.864]      # 2nd particle initial velocity

# N particle problem
N=len(inV)//4

# get force to j-th particle from k-th particle
getFV=λ v,i,k:(λ r=krry(v[2k:2k+2])-krry(v[2i:2i+2]):r/norm(r)^3 if norm(r)!=0 else ~[0,0])()

# sum up forces to j-th paticle
sumFc=λ v,j:sum([getFV(v,j,k) for k in range(N) if j!=k])

# define function:fnc which drives a differential equation dv/dt == fnc(*v).
# kOde(...) needs a fnc(x0,x1,...) whick parameter is expanded.
fnc= λ *v: np.r_[v[2N:],(~[sumFc(v,j) for j in range(N)]).r]

# solve the differential equation numerically untill 2 second on 400 points
# kOde(...) returns 400 x 2N data
mt=kOde(fnc,inV, 2 s`,400)

# draw the trajectories of 3 particles using mt data
pt=plotTrajectory
pt(mt[:,:2])
pt(mt[:,2:4],color=red)
pt(mt[:,4:6],color=green)
//@@@
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/8charTrajectory6.jpg">
<p>
Code of &quot fnc= λ *v: np.r_[v[2N:],(~[sumFc(v,j) for j in range(N)]).r]&quot is too artificial. But you might be able to read the other codes if you are lightly familiar with Python and Numpy. We must use the artifice because kOde:a solver of ordinary differential equation accept only vector parameters and we must use one vector parameter to describe positions and velocities of 3 particles. Though you can easily understand the artifice in detail after you read the next section if you are familiar with Numpy matrix methods.

<p>
The upper script draws upper the figure eight orbit.
<p>
In the upper script we add comments and insert null lines and line feeds to achieve reader's understanding. But there is no need to execute the script. If you remove them then only PythonSf expression/statement line up vertically without indent and if-then-else. The you can line them up horizontally. Actually the below on-liner works in the exactly same way and you can display the one-liner at a line on a 27 inch LCD.
<p>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
<br>
inV=[-0.97,0.243, 0.97,-0.243, 0,0, -0.466,-0.432, -0.466,-0.432, 0.932,0.864]; N=len(inV)//4; getFV=λ v,i,k:(λ r=krry(v[2k:2k+2])-krry(v[2i:2i+2]):r/norm(r)^3 if norm(r)!=0 else ~[0,0])(); sumFc=λ v,j:sum([getFV(v,j,k) for k in range(N) if j!=k]); fnc= λ *v: np.r_[v[2N:],(~[sumFc(v,j) for j in range(N)]).r]; mt=kOde(fnc,inV, 2 s`,400); pt=plotTrajectory; pt(mt[:,:2]); pt(mt[:,2:4],color=red); pt(mt[:,4:6],color=green)
</span>
</code>
<p>
If you add physical units to upper complicated initial value parameters, you can express that the lump of PythonSf expression solves the figure eight orbit. The meaning of the below one-liner will be naturally understood without a special decoding work by one year after yourself or the people who have mastery of the field of study. 
<p>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
inV=[-0.97m`,0.243m`, 0.97m`,-0.243m`, 0m`,0m`, -0.466m`/s`,-0.432m`/s`, -0.466m`/s`,-0.432m`/s`, 0.932m`/s`,0.864m`/s`]; N=len(inV)//4; getFV=λ v,i,k:(λ r=krry(v[2k:2k+2])-krry(v[2i:2i+2]):r/norm(r)^3 if norm(r)!=0 else ~[0,0])(); sumFc=λ v,j:sum([getFV(v,j,k) for k in range(N) if j!=k]); fnc= λ *v: np.r_[v[2N:],(~[sumFc(v,j) for j in range(N)]).r]; mt=kOde(fnc,inV, 2 s`,400); pt=plotTrajectory; pt(mt[:,:2]); pt(mt[:,2:4],color=red); pt(mt[:,4:6],color=green)
</span>
</code>
<p>
You can use this one-liner for not only the figure eight orbit but alsot any 2 dimensional 3-body problem. You can change this one-liner to solve any 3 dimensional 3-body problem like <a href="#kOde:常微分方程式">a later explanation</a>.
<p>
This one-liner works without anything else. It doesn't depend on before codings as in a notebook of Mathematica or Matlab. It is comprehensive only with this one line. If you copy and paste this line and change the parameter values, then you can study many orbits. You can reuse this one-liner when you pile up your thinking about the N-body problem.
<p>
Adversely you accumulate reusable one-liners like this at each field, you can deeply understand the field. PythonSf changes mathematical thinking to thinking exploiting computers. Though until now you had to copy out equations in esoteric textbooks,you can calculate the equations applying them to actual practical examples using PythonSf.
<p>
Hereafter we show many one-liner computing as a gallery. These will show powers of PythonSf.
<br>
<br>
<br>
<h3>Why PythonSf, not SAGE？</h3>
<p>
If you are familiar with mathematical processing in Python, you might think why not to use SAGE. The reason is that SAGE is a mathematical software for professional mathematicians. If you are a user of mathematics, then PythonSf is more convenient than SAGE. Only professional mathematicians use  PARI/GP、GAP、Maxima、SINGULAR that SAGE includes.
<p>
SAGE and PythonSf overlaps in their many application areas. The big difference between them is that SAGE is a mathematical softare to make out new theories and PythonSf is the one to use mathematical formulas. PythonSf calculates 90 percent or more of mathematical problems by one-liners with convenience as of calculators.
<p>
As for using mathematics PythonSf is more convenient than SAGE in many situations. If you are a user of SAGE and you use it only in a range where you deal with Python only such as SciPy, SymPy, Matplotlib and others then you might feel more convenient in Python Sf than in SAGE.
<p>
Many of SAGE users might want to use them in a editor. If you are such one, please try PythonSf. If you implemented your theorems/formulas in Python, please customize them to use them in PythonSf. The learning cost might be one day or so.

<a name="■■ Portable PythonSf"></a>
<h2>■■ Portable PythonSf</h2>
<p>
We distribute Portable PythonSf for Python 2.7. All you need to do is to unzip and use it. We don't use installer. Users might cheer up this because it dosen't change computer settings. 
<p>
In this distribution, we include Vim which can calculate PythonSf strings under the cursor using vim macros.

There are 2 types of Portable PythonSf:small version and big version.

<h3>Small PythonSf</h3>
<p>
We distribute <a href="http://www.adrive.com/public/uPsuxQ/smallWithoutPythonSf096a_win7_64.zip">smallWithoutPython_v096a_win7_64.zip</a>,<a href="http://www.adrive.com/public/W2nyBg/smallWithoutPython_v096a_win_32.zip">smallWithoutPython_v096a_win_32.zip</a> for users who have installed Python and SciPy,VPython,SymPy,Matplotlib packages that are needed to work PythonSf. Small PythonSf is a set in small file size:80MB.
<p>
Currently we distribute only only for windows, The difference between smallWithoutPython_v096a_win7_64 and smallWithoutPython_v096a_win_32 is in only for Vim editor. PythonSf itself works at both of 64/32 bit environments.
<h3>big PythonSf</h3>
<p>
We distribute <a href="http://www.adrive.com/public/akJe3F/bigIncludingPythonSf096a_win7_64.zip">bigIncludingPython_v096a_win7_64.zip</a> ,<a href="http://www.adrive.com/public/6XjKBZ/bigIncludingPython_v096a_win_32.zip">bigIncludingPython_v096a_win_32.zip</a> for users who have not installed Python and SciPy,VPython,SymPy,Matplotlib packages that are needed to work PythonSf. Big PythonSf is a set in big file size:250MB. You don't need to install Python. In return for that, the size become big as 1.2GB after extracting it. But you can carry about it in current USB memory without problems.
<p>
Currently we distribute only only for windows, The difference between bigIncludingPython_v096a_win7_64 and bigIncludingPython_v096a_win_32 is in only for Vim editor. PythonSf itself works at both of 64/32 bit environments.
<h3>Install PythonSf</h3>
<p>
If you approve PythonSf after trying it, you can install it in your computer as below

If you use smallWithoutPython_v???, you have installed Python and other libraries that are needed to make PythonSf work, so you have to do below works.
<ol>
<li>copy sfPP.py file in python\Lib\ directory.
<li>copy pysf directory and files in python\Lib\site-packages\ directory.
<li>copy sfCrrntIni.py and Vc7VrfyMDdRt10D.zip files in current directory.
</ol>
<p>
If you use bigIncludingPython_v???, you have to do below works.
<ol>
<li>copy all of bigIncludingPython_v096_win_32 directory in a appropriate place of your HDD and files and rename bigIncludingPython_v096_win_32 to a favourite one:pyton for example.
<li>set PATH to the new directory.
<li>move sfPP.py file in python\Lib\ directory.
<li>move pysf directory and files in python\Lib\site-packages\ directory.
<li>copy sfCrrntIni.py and Vc7VrfyMDdRt10D.zip files in current directory.
</ol>
<p>
Vc7VrfyMDdRt10D.zip is a key file to make a evaluation version of PythonSf work. You will not use Vc7VrfyMDdRt10D.zip after upgrading to a commercial version of PythonSf.


<h3>Differences between a evaluation version and commertial version of PythonSf</h3>
<p>
Differences between a evaluation version and commertial version of PythonSf is only below 2 points.
<ol>
<li>There is a 5 sec delay at starting a calculation.
<li>You need Vc7VrfyMDdRt10D.zip at current directory to make PythonSf work.が必要となる
</ol>
<p>
If you approve PythonSf and want a commercial vesion of PythonSf, please send a e-mail accompanying a yourMachine.code file to kverifierlab@yahoo.co.jp.
<p>
The price of the commercial PythonSf is \5000 or $60.

<a name="■■ PythonSf vim operation"></a>
<h2>■■ PythonSf vim operation</h2>
<p>
Python is a CUI interface software which is superior in human interfaces. We implements PythonSf supposing that PythonSf is embedded in a editor which is familiar for each youser and have a console interface. For example we distribute Vim in portable PythonSf. It includes Vim macro:pysf.vim whichcalculates the strings under the cursor in Vim editor. We expect thant pairing PythonSf and vim bring about life changing software environments.
<p>
If you wand to use your Vim not a unfamiliar Vim in a portable PythonSf distribution, then copy vim\vim73\plugin\pysf.vim to you Vim plungin directory. If you want to customize key bindings, please modify nnoremap lines. pysf.vim is a small macro which consists of 300 lines. If you know vim macros then you can customize it easily. Hereafter we explain pysf.vim macro assuming that you embedded pysf.vim in the vim plugin directory.
<p>
Though pysf.vim is symple and small macros, you can use it for not only calculations of PythonSf expressions but also execution of Python codes, execution of os commands, and compilations of C language or others that are installed in you computer. Those macros are sorted to 2 types:macros related to one-liners and macros related tor blocks. Let start looking at simpler macros related to one-liners.
<p>
In addition, Vim in portable PythonSf is <a href="http://www.kaoriya.net/software/vim">kaoriya's vim </a>. It is a Vim distribution for Japanese. It will be less troublesome at using kanji simbole characters:∂∇□△ and kanji Greek characters:α β---.
<h3>Vim macros related to one-liners</h3>
<h4>calculation of PythonSf one-liners</h4>
<p>
To calculate a PythonSf one-liner expression in Portable PythonSf Vim editor, you move the cursor ont to the one-liner expression string and operate keys:&quot;;j&quot; at normal mode and at insert mode operta keys&quot;Alt+;j"
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
3+4
===============================
7
</span>
</code>
</pre>
<img src="./jpg/1111/one_liner_python_sf_eq_e.jpg">
<p>
The operation ;j make OS execute 3+4 string adding python -u -m sfPP strign before it. And in the command line at the bottom of Vim editor, the macro displays a string which OS returns from CUI
<img src="./jpg/1111/one_liner_python_sf_eq_execute_e.jpg">
<p>
If you want to write the calculated result, you operate &quot;p&quot; at Vim normal mode.
<img src="./jpg/1111/one_liner_python_sf_eq_execute_paste_e.jpg">
<h4>execution of Python one-liners</h4>
<p>
PythonSf is upper compatible with Python, so you can execute Python one-liners with ;j operation. At Vim normal mode, move the cursor on a Python one-liner code and do ;t key operation and Vim will execute the one-liner as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
import tarfile as tr; tr.open('pycrypto-2.0.1.tar.gz', 'r').extractall()
IOError:You may use nonexistent variable name:[Errno 2] No such file or directory: 'pycrypto-2.0.1.tar.gz'
</span>
</code>
</pre>
<p>
By the way, it is below 9 lines that we implement a Vim macro for ;j operation.
<pre>
<code>
function! ExecPySf_1liner()
    let l:strAt = __getLineOmittingComment()
    let l:strAt = 'python -u -m sfPP "' . l:strAt . '"'
    echo l:strAt
    let @0= system(l:strAt)
    let @" = @0
    " Though clipboard would not be set unnamed 、the returned value is set at a* too
    " for application except for vim could refer to the calculated results.
    " Below code is needed even  clipboard += unnamed because p pastes a content of a*
    let @* = @0
    echo @0
endfunction         
</code>
</pre>
<p>
You can customize this short Vim macro easily if you cant accept these operations.
<p>
<b>ATTENTION</b>
<p>
Plese note that you can't use &quot; at Python/PythonSf one-liners. You have to enclse a string with single quote:' because Vim one-liner macro make a OS command string:python -u -m sfPP+adding &qutot;string under the cursor&quot; 
<h4>execution of OS commands</h4>
<p>
pysf.vim macro can also execute OS commands under the cursor at normal mode, operating ;a as below.
<pre>
<b>dir command string</b>
dir cl*.pvl
</pre>
<img src="./jpg/1111/one_liner_command_execute.jpg">
<p>
You might not be approval doing dir command from Vim editor, but please think that it can execute any commands or executable files with parameters. It can do many things, For example do ;a key operation at Vim normal mode moving the cursor on the below string. It will open a byte_of_vim_v051 pdf file just at the 10th page. If you modify the page parameter 10 and file name, you can open the file at the page.
<pre>
<b>command starting Acrobat assigning a page number</b>
C:"\Program Files (x86)\Adobe\Reader 9.0\Reader\AcroRd32.exe" /A page=10 D:\utl\vim73\byte_of_vim_v051.pdf
</pre>
<p>
By the way, Exc_command() vim macro executes OS commands. If you interest it or want to customize it then refer to pysf.vim file.
<h4>execution of OS command with start</h4>
<p>

The upper command opening a pdf file doesn't require return value. But you can't edit Vim while opening the pdf file because Vim executes the opening command as a child process of Vim. To avoid this, please do ;f operation at Vim normal mode. Vim macro:Exec_start() executes commands adding &quot;start&quot; string at Windows OS.
<p>
If you execute &quot;start fileName&quot; at Windows OS, then OS executes an application programm that are associated with the filename extension using the filename as a command parameter. Applying this, you might operate computers more conveniently. For example you move the cursor on URL string at Vim normal mode and do the key operation ;f then Windows OS executes default brauser with the URL as below. 
<pre>
<b>;f on URL i.e start execution</b>
http://www.nhk.or.jp/daily/english/
</pre>
<br>
<b>After upper ;f operation, the web page of NHK English new is opend in a default brauser.</b>
<br>
<img src="./jpg/1111/one_liner_start_nhk.jpg">
<h4>start execution of PythonSf calculations</h4>
<p>
It is often wanted to display another graph leaving the first graph displaying. At a time like this, please do ;s key operation and Vim macro:ExecSf_start_1liner() will execute to calculate PythonSf expression in another process. This gives you to edit at Vim in parallel leaving displaying other graphs.
<pre>

<h4>line head comments of one liners</h4>
<p>
Comments are written in line head to ;; at Vim one-liner execution macro.
<b>comment + ;; + a string of PythonSf expression </b>
PythonSf expression displaying a graph;;plotGr(sin, 0,2pi)
</pre>
<p>
We put comments in a line head because it is difficult to find out a start point of a one-liner at a glance. It become clearer at very long URL. So that Vim one-liner macro use ;; as a delimiter and take away the comment from line head to ;; and execute the command or expression after the ;;. For example move the cursor one the below URL and do ;f key operation then OS make a default browser go to a web page where you can download the news voice file ro calculate a PythonSf expression.
<pre>
<b>comment + ;; + URL string</b>
NHK English news;;http://www.nhk.or.jp/nhkworld/english/radio/program/index.html

<b>comment + ;; + PythonSf expression string</b>
comment for a PythonSf expression;;3+4
</pre>
<h3>Vim macro related to a block</h3>
<p>
pysf.vim macros can compile and execute a block code of Python or C or other general programming language.
<p>
Block lines at pysf.vim means lines between //@@ and //@@@ strings as blow. Macro of pysf.vim executes or compiles the block.
<pre>
<code>
<b>a block for pysf.vim</b>
//@@
    ・
  block lines
    ・
//@@@
</code>
</pre>

<h4>calculations of PythonSf block expressions</h4>
<p>
If you want to calculate a number of PythonSf expressions in a block than calculating in a one-liner, please do the next things.
<ol>
<li>write down the PythonSf expressions between &quot;//@@&quot; line and &quot;//@@&quot; line
<li>move the cursor on a line between &quot;//@@&quot; and  &quot;//@@@&quto;
<li>do ;k key operation at Vim normal mode
</ol>
<p>
Then pysf.vim macro writes down lines between //@@ and //@@@ to temp.py in current directory and executes python -u -m sfPP -fs temp.py. The the pre-processor transforms temp.py to __tempConverted.py that Python can deal with. After that it executes &quot;python -u __tempConverted.py&quot;.

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf block</b>
//@@
# 07.11.26 beer barrel form pulley
# width = 5 meter, hieght = 1meer,  depth 1 meter, 

#import sf
import pysf.sfFnctns as sf

N, M =20,5
dctUpper={}
dctLower={}
for pos, index in zip(sf.masq([-2.5,N+1, 5.0/N],[-0.5,M+1, 1.0/M]), sf.mrng(N+1,M+1) ):
    dctUpper[index] = (pos[0], 1, pos[1])
    dctLower[index] = (pos[0],-1, pos[1])

N, M = 10,5
dctLeft ={}
dctRight ={}
for (theta, z), index in zip(sf.masq([sf.pi/2, N+1, -sf.pi/N], [-0.5, M+1, 1.0/M])
                            ,sf.mrng(N+1,M+1) ):
    dctRight[index] = [2.5+sf.cos(theta), sf.sin(theta),z]
    dctLeft[index] = [-2.5-sf.cos(theta), sf.sin(theta),z]


sf.renderFaces(dctUpper)
sf.renderFaces(dctLower)
sf.renderFaces(dctLeft)
sf.renderFaces(dctRight)

dctLeft ={}
dctRight ={}
N=40
for (theta, z), index in zip(sf.masq([sf.pi, N+1, -2*sf.pi/N], [-0.5, M+1, 1.0/M])
                            ,sf.mrng(N+1,M+1) ):
    dctRight[index] = [2.5+(2-sf.cosh(z))*sf.cos(theta), (2-sf.cosh(z))*sf.sin(theta),z]
    dctLeft[index] = [-2.5-(2-sf.cosh(z))*sf.cos(theta), (2-sf.cosh(z))*sf.sin(theta),z]

sf.renderFaces(dctLeft, blMeshOnly=True, meshColor=sf.red)
sf.renderFaces(dctRight, blMeshOnly=True, meshColor=sf.red)
//@@@
</span>
</code>
</pre>
<p>
By the way Vim macro:ExecSf_Bloc() executes the PythonSf block expressions. If you are interested to it, please refer it in pysf.vim file.
<p>
The upper PythonSf block expressions draws a 3D belt conveyer graphic.
<br>
<img src="./jpg/1111/block_python_sf_comveyer.jpg">
<p>
By the way pulleys of belt conveyers is bigger at the center than at edge. It preserve the belt in center although it oppose your intuition.
<p>
Adversely if you make the center of th pulley nallow, then the conveyer bolt will be pulled to one of the edge of th pulley and the conveyer will be destroyed.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf block equations</b>
//@@
# 07.11.26
# width = 5 meter, hieght = 1meer,  depth 1 meter, 

#import sf
import pysf.sfFnctns as sf

N, M =20,5
dctUpper={}
dctLower={}
for pos, index in zip(sf.masq([-2.5,N+1, 5.0/N],[-0.5,M+1, 1.0/M]), sf.mrng(N+1,M+1) ):
    dctUpper[index] = (pos[0], 1, pos[1])
    dctLower[index] = (pos[0],-1, pos[1])

N, M = 10,5
dctLeft ={}
dctRight ={}
for (theta, z), index in zip(sf.masq([sf.pi/2, N+1, -sf.pi/N], [-0.5, M+1, 1.0/M])
                            ,sf.mrng(N+1,M+1) ):
    dctRight[index] = [2.5+sf.cos(theta), sf.sin(theta),z]
    dctLeft[index] = [-2.5-sf.cos(theta), sf.sin(theta),z]


sf.renderFaces(dctUpper)
sf.renderFaces(dctLower)
sf.renderFaces(dctLeft)
sf.renderFaces(dctRight)

dctLeft ={}
dctRight ={}
N=40
for (theta, z), index in zip(sf.masq([sf.pi, N+1, -2*sf.pi/N], [-0.5, M+1, 1.0/M])
                            ,sf.mrng(N+1,M+1) ):
    dctRight[index] = [2.5+sf.cosh(z)*sf.cos(theta), sf.cosh(z)*sf.sin(theta),z]
    dctLeft[index] = [-2.5-sf.cosh(z)*sf.cos(theta), sf.cosh(z)*sf.sin(theta),z]

sf.renderFaces(dctLeft, blMeshOnly=True, meshColor=sf.red)
sf.renderFaces(dctRight, blMeshOnly=True, meshColor=sf.red)

thetaS = 2.05117740593
#Z0 = 0.48121182506 # real value
Z0 = 0.35   # exagerated value
lstRear =[(2.5+sf.cosh(0.5)*sf.cos(thetaS),1,-0.5), (2.5, sf.cosh(-Z0), -Z0)]
lstFront =[(2.5+sf.cosh(0.5)*sf.cos(thetaS),1,0.5), (2.5, sf.cosh(Z0), Z0)]
N=30
for theta in sf.arSqnc(sf.pi/2, N+1, -sf.pi/N):
    lstRear.append( (2.5+sf.cosh(Z0)*sf.cos(theta), sf.cosh(-Z0)*sf.sin(theta),-Z0) )
    lstFront.append( (2.5+sf.cosh(Z0)*sf.cos(theta), sf.cosh(Z0)*sf.sin(theta),Z0) )

sf.plotTrajectory(lstRear, blAxis=False)
sf.plotTrajectory(lstFront, blAxis=False)
//@@@
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/block_python_sf_concave_comveyer.jpg">
<p>
It is a hard work to draw up 3D graphs like upper ones using drawing software like Microsoft Word. If you are with math and science majors, you might more easily draw them with PythonSf expressions.

<h4>execution of Python block codes</h4>
<p>
You can also execute Python codes between //@@ and //@@@, doing ;p key operation at Vin normal mode like upper PythonSf block executions.
<pre>
<code>
<span style="color: #9f009f;">
<b>Python block execution</b>
//@@
#from;;http://www.daniweb.com/forums/thread113274.html
#from TurtleWorld import *
#TurtleWorld()
import turtle as t

def Koch(length):
    if length&lt=2 :
        t.forward(10*length)
        return

    Koch(length//3)
    t.left(60)
    Koch(length//3)
    t.right(120)
    Koch(length//3)
    t.left(60)
    Koch(length//3)

t.setpos(-300,10)
Koch(60)
t.exitonclick()
</span>
</code>
</pre>
<p>
<img src="./jpg/1111/block_python_kocho.jpg">
<p>
In addition PythonSf is upper compatible with Python, so you can execute the upper Python block codes as a block of PythonSf expression and you can also execute the upper turtle program by ;k operation It will draw the same Koch curve. It will elapse more CPU time to pre-process the codes although you will not be aware of the time difference at a commercial version of PythonSf. At a evaluation version of PythonSf, there is a 5 sec delay and you will be aware the differnece of elapsed time.
<p>
By the way Vim macro:ExecPy_Bloc() executes the PythonSf block expressions. If you are interested to it, please refer it in pysf.vim file.

<h4>Continuous execution after block</h4>
<p>
You can compile,link and execute any language continuing execution of string lines which is written just after a block. We have assigned this to ;e key operation.
<p>
If you do ;e key operation putting cursor in a code block between //@@ and //@@@, then pysf.vim macro:Exec_BlockCntn() will do the below things.
<ol>
<li>write to a __temp file the block codes between &quot;//@@&quot; line and &quot;//@@&quot; line
<li>look for the next string lines //@@@
<li>if the head of the string line is &quot;//&quot; then execute the string line as OS command
<li>continue the executions until it finds no &quot;//&quot;
</ol>
<p>
If you had written down a copy command and a compile command as //copy __temp ... //gcc ..., in __temp file Exec_BlockCntn() macro writes the code beteween //@@ and //@@@ and copy and comple as a below example. 
<pre>
<code>
<span style="color: #9f009f;">
<b>continuing execution of command with a block code： compile and execute C programm</b>
//@@
//06.01.28  test valarray sum <== OK
#include &;t;valarray&gt;
#include &;t;iostream&gt;   // iostream cannot co-exist with systemc.h
using namespace std;

int main()
{
    valarray&lt;int&gt; vlrInAt(5);  // size 5 vararray initialize by 0
    vlrInAt[0]=1;
    vlrInAt[1]=2;
    vlrInAt[2]=3;
    vlrInAt[3]=4;
    vlrInAt[4]=5;
    
    cout &lt;&lt; vlrInAt.sum() &lt;&lt; endl;
    return 0;
}
//@@@
//copy __temp a.cpp /y
//g++ a.cpp  -O0 -g
//a

</span>
</code>
</pre>
<br>
<img src="./jpg/1111/block_gpp_block_continue.jpg">

<p>
You can write any string lines after &quot;//@@@&quot; at ;e key operation:continuing execution of command with a block code. If you want to execute block codes with Haskell, you might just write down as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>continuing execution of command with a block code： compile and execute C programm</b>
//@@
data Variables = C Char | S String | I Int | Iex Integer | D Double | F Float
data VarList a = VarX a [Variables]

instance Show Variables where
    show (C ch)  = "C "   ++ show ch
    show (S str) = "S "   ++ show str
    show (I m)   = "I "   ++ show m
    show (Iex n) = "Iex " ++ show n
    show (D o)   = "D "   ++ show o
    show (F p)   = "F "   ++ show p

instance Show a => Show (VarList a) where
    show (VarX x y) = "Var " ++ show x ++ " " ++ show y

x = VarX 11 [(Iex 21), (S "fd"), (C 'a')]

main = do
    print x
//@@@
//copy __temp temp.hs /y
//D:\lng\Haskell\ghc6121\bin\runghc.exe temp.hs

Var 11 [Iex 21,S "fd",C 'a']
</span>
</code>
</pre>
<p>
You can execute upper Haskell program even without setting PATH environment variable becuase the upper example executes Haskell with the full path file name.
<p>
Continuing execution of command with a block code is convenient for execution of test program codes which are so many and small. If you wold have these small test code files by hundres, You couldn't manage them. But you can put the codes in big one file. You would leave compile/liner options too in the big file. You can rerun each of the codes any time and a number of time just moving the cursor on one of the code block and doing the key operation ;e at Vim normal mode.
<p>
By the way there is no error handlings in Exec_BlockCntn() code. That should be fixed up. But even the current Exec_BlocnTntn() is sufficiently convenient. So we make a test exhibition of Exec_BlockCntn()

<h3>Inputting kanji characters of greek letters or ∂∇□△ symbols</h3>
<p>
You could input kanji characters of greek letters or ∂ symbol using Windows IME. But it is bother to do on/off operations of IME in the typing actions of expressions. We have implementd vim macros:ConvertAlpbt2Greek() that help out to input the greek/symbol characters
<ol>
<li>You can input each of αβγδεζηθικλμνξοπρστυφχψω by ctrl+a g key operation at Vim input mode just after each of abgdezhqiklmnxoprstufcyw.
<li>You can input each of ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩby ctrl+a g key operation at Vim input mode just after each of ABGDEZHQIKLMNXOPRSTUFCYW.
<li>You can input ∂:round kenji character by ctrl+a+g key operation just after r`
<li>You can input ∇:nabla kenji character by ctrl+a+g key operation just after n`
<li>You can input □:dalembertian kenji character by ctrl+a+g key operation just after d`
<li>You can input △:laplacian kenji character by ctrl+a+g key operation just after l`
</ol>

<a name="■■ PythonSf emacs operation"></a>
<h2>■■ PythonSf emacs operation</h2>
<p>
There isn't a Emacs Lisp for PythonSf now. <!--Please write down it yourself. We will send a commercial PythonSf for the first programmer who implements the Emacs Lisp for PythonSf under the GPL General Public License. Please send me a e-mail to kverifierlab@yahoo.co.jp. -->


<a name="■■ PythonSf Fast Tour"></a>
<h2>■■ PythonSf Fast Tour</h2>
<p>
We have slightly extended Python syntax to resemble PythonSf expression to memo writing mathematical expressions. You might come across PythonSf expressions that you can't understand, if you don't understand the extended parts of the syntax. PythonSf beginner should read this chapter through.

<h3>Abbreviation of product operators</h3>
<p>
Product operators are abbreviated in general at Mathematics. Alsot PythonSf take over the abbreviation.
<p>
We implement PythonSf aiming to resemble daily PythonSf expression to memo writing matmematical expressions. So we intervene in syntax analysys proces using a pre-processor to abbreviate the product operators as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
a,b=3,4; 2 a b
===============================
24

a,b=3,4; 2a + 3b
===============================
18

a,b=3,4; 2(a+b)
===============================
14

a,b=3,4; a (a+b)
===============================
21

<b>PythonSf one-liner missusing the abreviation of product operators</b>
a,b=3,4; ab
name 'ab' is not defined at excecuting:ab

a,b=3,4; a(a+b)
'int' object is not callable at excecuting:a(a+b)
</span>
</code>
</pre>
<p>
Please notice that you can't write expressions as ab or a(a+b) for compliance with Python syntax. &quot;ab&quot mmeans a variable ab not a expression a*b at Python syntax. &quot;a(a+b)&quot; means a function &quot;a&quot; with a parameter &quot;a+b&quot; not a expression a*(a+b).

<h3>Product operator:^</h3>
<p>
Generally &quot;^&quot; is used for exponentiation operator. &quot;**&quot; operator is used only in programming. On the other hand &quot;^&quot; operator means bit exor in Python.
<p>
We preffered to resemble PythonSf expression to memo writing mathematical expressions than to maintain Python syntax. Python use \^ for bit exor operator. Definitely you can also use ** operator as a exponentiation operator at PythonSf expressions. We show up examples as below.

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
2^4, 2\^4, 2**4
===============================
(16, 6, 16)
</span>
</code>
</pre>
<p>
Though we sait that PythonSf was upper compatible with Python, there are few of parts that are not compatible with Python. In Python you can calculate &quot;sin (pi/3)&quot; inserting space, but it means sin*(pi/3) in PythonSf as at ^ operator. But you might not use bit exor operator less than once a year. You need no space between sin and (pi/3). It shoud be allowed to say tha PythonSf is compatible with Python, if the imcompatible exceptions are limited in few parts.

<h3>Backquote and name space</h3>
<p>
It is desirable that you can write PythonSf expressions shortly as far as possible. There are many implicit assumptions. For example &quot;x&quot; &quot;y&quot; means given variables and &quto;x+y&quot; means a addition of variables i.e. a function of two variables. But at programming, you must write declaring statement of x,y to avoid undefined variable erros. 
<p>
You can avoid the undefined erros, if you have assigned some instances to x,y. But it wrongly affect Python codes to assign some objects ot very short labels of x,y.
<p>
We have allowed PythonSf labels to add backquote(s) at head or tail of them. We have extended PythonSf namespace adding backquote and enable to use short mathematical labels that are not in the existing Python namespace.
<p>
For example, to &quot;`X&quot; we have assigned a instance of a identical function class that has four operations methods and exponentiation operation method. So you can use &quot;`X^2+3`X+1&quot; as a quadratic function as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
(`X^2+3`X+1)(1)
===============================
5

(`X^2+3`X+1)(2)
===============================
11
</span>
</code>
</pre>
<p>
To &quot;`Y&quot; we have assigned a instance of a identical function class that has four operations methods and exponent operation method and a method picking up the 2nd argument from parameters. So you can use &quot; `X^2+3`Y&quot; as a quadratic function of 2 variables as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
(`X^2+3`Y+1)(1,2)
===============================
8

sqrt(`X^2+3`Y+1)(1,2)
===============================
2.82842712475
</span>
</code>
</pre>
<h3>Symbols indicating vectors or matrices</h3>
<p>
We use ~[...] syntax to indicate vectors or matrices as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
~[1,2,3]    # float value vector
===============================
[ 1.  2.  3.]
---- ClTensor ----

~[1,2,3+4j]    # complex value vector
===============================
[ 1.+0.j  2.+0.j  3.+4.j]
---- ClTensor ----

vc=~[1,2,3]; vc+[4,5,6]    # vector add
===============================
[ 5.  7.  9.]
---- ClTensor ----

vc=~[1,2,3]; vc [4,5,6]    # vector inner product
===============================
32.0

~[ [1,2],[3,4] ]           # matrix
===============================
[[ 1.  2.]
 [ 3.  4.]]<F12>
---- ClTensor ----

mt,vc=~[[1,2],[3,4]],~[5,6]; mt vc   # product of matrix and vector
===============================
[ 17.  39.]
---- ClTensor ----

mt=~[[1,2],[3,4]]; 1/mt, mt^-1   # inverse of matrix
===============================
(ClTensor([[-2. ,  1. ],
           [ 1.5, -0.5]]),
 ClTensor([[-2. ,  1. ],
           [ 1.5, -0.5]]))

# a generation of a ClTensor matrix instance from a matrix dictionary object
dct={(0,0):1,(0,1):2,(1,0):3,(1,1):1}; ~[dct]
===============================
[[ 1.  2.]
 [ 3.  1.]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
We assign a floating type vector or matrix by default because it both of integer type and floating type one bring about same result values. Adversely dividing operation of a integer type vector or matrix bring about 0 values after the decimal points.
<p>
If you want to use vectors or matrices other than floating type, please ust ~[..., type] syntax adding type parameter at the tail posiion.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
~[1,2,3, int]   # int type vector
==============================
[1 2 3]
---- ClTensor ----
</span>
</code>
</pre>
<p>
If you set user defined type like as oc.BF, you can operate that type vectors or matrices.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
~[1,0,1, oc.BF]     # oc.BF:Bool Filed type vector
===============================
[1 0 1]
---- ClFldTns:&lt;class 'pysf.octn.BF'&gt; ----

mt,vc=~[[1,1,0],[1,1,1],oc.BF],~[1,0,1, oc.BF]; mt vc     # product of Bool Type matrix and vector
===============================
[1 0]
---- ClFldTns:&lt;class 'pysf.octn.BF'&gt; ----

~[1,2,3, oc.BF]     # oc.BF:Bool Filed type vector
===============================
[1 0 1]
---- ClFldTns:&lt; class 'pysf.octn.BF'&gt; ----

class Cl(int):pass; ~[1,2,3, Cl]    # user defined type
===============================
[1 2 3]
---- ClFldTns:&;t;class 'pysf.sfPPrcssr.Cl'&gt; ----
</span>
</code>
</pre>
<p>
PythonSf ~[...] syntax generates instances of ClTensor class or ClFldTns class, not instances of ndarra in Numpy. Because it makes us to describe multiplication and division of vectors or matrices multiply as like as the ways of integer or float. So that multiplication of the ClTensor or ClFldTns instances is multiplication of a matrix and vector or matrix and matrix. Multiplication of the ClTensor or ClFldTns vectors is inner product. At ClTensor or ClFldTns, division of vector over vector become a error. Meanwhile at ndarray, multiplications means multiplications of each element. You well be puzzled at first time. Please notice this.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
# Multiplication for vectors: inner product at PythonSf
~[1,2,3] ~[4,5,6]
===============================
32.0

<b>PythonSf one-liner</b>
~[1,2,3]/ ~[4,5,6]
Traceback (most recent call last):
  File "D:\lng\Python26\lib\runpy.py", line 122, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "D:\lng\Python26\lib\runpy.py", line 34, in _run_code
    exec code in run_globals
  File "D:\my\vc7\mtCm\sfPP.py", line 2, in <module>
    pysf.sfPPrcssr.start()
  File "pysf\sfPPrcssr.py", line 2722, in start
    __execLine( (" ".join(sys.argv[1:])).strip() )
  File "pysf\sfPPrcssr.py", line 2345, in __execLine
    valStt = eval(ustConvertedAt, globals(), locals() )
  File "<string>", line 1, in <module>
  File "pysf\sfFnctns.py", line 547, in __truediv__
    return self.__mul__(ag.inv())
  File "pysf\sfFnctns.py", line 492, in inv
    return copy.deepcopy(self.m_inv)
  File "pysf\sfFnctns.py", line 909, in __getattr__
    self.__dict__['m_inv'] = ClTensor(sl.inv(self))
  File "D:\lng\Python26\lib\site-packages\numpy\linalg\linalg.py", line 423, in inv
    return wrap(solve(a, identity(a.shape[0], dtype=a.dtype)))
  File "D:\lng\Python26\lib\site-packages\numpy\linalg\linalg.py", line 290, in solve
    _assertRank2(a, b)
  File "D:\lng\Python26\lib\site-packages\numpy\linalg\linalg.py", line 134, in _assertRank2
    two-dimensional' % len(a.shape)
numpy.linalg.linalg.LinAlgError: 1-dimensional array given. Array must be             two-dimensional

<b>PythonSf one-liner</b>
# division for vectors: inner product at PythonSf
vA,vB = np.array([1,2,3]),np.array([4,5,6]); vA/vB
===============================
[ 0.25  0.4   0.5 ]

<b>PythonSf one-liner</b>
# division for vectors: division for each elements at Numpy
np.array([1,2,3]) np.array([4,5,6])
===============================
[ 4 10 18]

np.array([1,2,3])/np.array([4,5,6])
===============================
[ 0.25  0.4   0.5 ]
</span>
</code>
</pre>
<p>
In addition we add a &quot;---- ClTensor ----&quot; string if calculation results are a vector or matrix which element is integer or float or complex. We add something like  &quot;---- ClFldTns:< class 'pysf.octn.BF'> ----&quot; string if calculation results are a vector or matrix which element is not integer and float and complex. We add no string if calculation results are numpy.ndarray instances. We show up examples below.

<pre>
<code>
<span style="color: #9f009f;">
an expression of ClTensor instances
===============================
returned value
---- ClTensor ----


an expression of ClFldTns instances
===============================
returned value
---- ClFldTns:< class 'pysf.octn.BF'> ----

an expression of np.ndarray instances
===============================
returned value
# There is no explicit type information 

</span>
</code>
</pre>
<h3>Greek letters and special symbols</h3>
You might frequently use Greek characters in mathematical expressions. PythonSf pre-processor enables us to Greek characters even in Python 2.x version.( At the moment of 2011 year 10 month. PythonSf use shift JIS kanji characters. If there is a lot of requirements to use utf8, we will implemnt it). You can use Greek characters as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
σx,σz=~[[0,1],[1,0]], ~[[1,0],[0,-1]]; σx σz
===============================
[[ 0. -1.]
 [ 1.  0.]]
---- ClTensor ----

σx,σz=~[[0,1],[1,0]], ~[[1,0],[0,-1]]; σx+σz
===============================
[[ 1.  1.]
 [ 1. -1.]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
In addition to Greek characters, you can use special kanji symbols &quot;∇□∂△&quot; which are frequently used in daily calculations. Particularly the differential symbol:∂ is conveniently in heavy usage
 as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
# numerical differentiation
∂x(`X^2+2`X+3)(2)
===============================
6.0

# symbolic differentiation
ts(); ∂x(`x^2+2`x `y+3)
===============================
2*x + 2*y

# Jacobian numerical differentiation
∂J(`X^2+`Y^2, 2)(1,2)
===============================
[ 2.  4.]
---- ClTensor ----
</span>
</code>
</pre>
<h4>lambda expression and Greek kanji character λ</h4>
<p>
PythonSf use Greek kanji character:λ to lambda expressions, becuase 
it wins an advantage over visibility and lambda expressions are frequently used. Herewith you can use λ expression as in computer science textbooks as below. In return to the advantage, you can't use the variable which is only one character:λ
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
f=λ x:sin(x)+2cos(x); f(pi/2)
===============================
1.0

# Using let statement utilizing a default parameter in a λ expression.
# The default parameter:y=sin(x)+2cos(x) might be considered as a let statement.
# You cant change the y value.
f=λ x:(λ y=sin(x)+2cos(x): y+y^2)(); f(pi/2)
===============================
2.0

# You can't assign a value to λ label. Becuase λ is lambda syntax.
λ=3; 2λ
invalid syntax (<string>, line 1) at excecuting:lambda=3
</span>
</code>
</pre>
<p>
Lambda expressions in Python resemble to lambda expression in computer science textbooks. You can model the natural number using Church number as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
# 2 at Church number
Z='1';S =λ s:s+'1';(λ s:λ z:s(s(z)))(S)(Z)
===============================
111

# 2 + 3 at Charch number
Z='1';S =λ s:s+'1';(λ s:λ z:s(s(  s(s(s(z))) )))(S)(Z)
===============================
111111
</span>
</code>
</pre>

<h3>Extensions of operator symbols</h3>
<p>
You can diffine infix operators:~~, ~^, ~+, ~-, ~*, ~/, ~%, ~&, ~|, ~== for yourself. Please note that the kind of the priority of the user operators is only one:maximum only. So you might control the priority by parentheses.
<p>
For example, we assigned nearlyEq(..) function to ~== extended user operator. So you can calculate as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
(3.3pF`) ~== (3.300001pF`)
===============================
True

(3.3pF`) ~== (3.30001pF`)
===============================
False

~[1, 2] ~== [1, 2.000001]
===============================
True

~[1, 2] ~== [1, 2.00001]
===============================
False
</span>
</code>
</pre>

<h3>Name space of the global variables</h3>
<p>
The pre-processor of PythonSf imports sfFnctns.py module before calculations. So PythonSf has imported a lot of basic mathematical objects as basic numeric functions:exp, sin, cos, tan, sinh, cosh, tanh, arcsin, arccos, arctan, log10, sqrt and athers to the global name space. So you can calculate the basic numeric functions without importing math. You can do almost all the calculations that normal scientifc calculator do as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
tan(pi/3)
===============================
1.73205080757
</span>
</code>
</pre>

<h3>Extended name space and Customizing</h3>
<p>
Though we had used extended variable as `X, you can use variables which are added multiple single quate(s) in head or tails, because PythonSf intervene in syntax analysis process. It is allowed that Python syntax works with short mathematical expressions according to mathematical conventions because of extended name space and customizing i.e. assigning Python objects to short labels.
<p>
Let look more concretely. If PythonSf pre-processor founds a variable lable that starts with &quot;`&quot, it adds &quot;k__bq_&quot; at the head of the label and adds &quot;__&quot; at the tail of the label. For example the pre-processor transforms &quot;`X&quot; to k__bq_X__. And we have assigned the short label a identical function that is a Python object and allowed four and exponent operations. So you can write short expressions as &quot;`X^2+1&quot; and others.
<p>
It is desirable to write mathematical expressions shortly as far as possible. So the expression are written under many implicit assumptions. In the field of mathematics &quot;X&quot; means a unkown variable. In the field of physics &quot;h&quot means Planck constant and &quot;c&quot; means the light velocity. But it is crazy to assign short variable names  Python objects as of identical function, Planch constant, light velocity, because they might conflict with Python codes in some way.
<p>
To avoid this problem, we extended the name space adding one or more back quotes at head or tail. Assigning a identical function or Planck constant or others to the extended labels, we enabled to write short calculatable memo writing expression that assumes implict assumptions at the field of mathematics or physics or others.
<p>
By the way we use a naming conventions adding a back quotes at tail for physical units or constants.
<p>
In addition we also use back quotes to notate upper or lower indexes of tensor as  Γ``_[i,j,k]. For this example i,j is upper index and k is lower index. You migh say that the back quotes are int in tail at Γ``_. Please regard that _:underscore as not included at tails of name string when more appropriate.
<h4>Customizing by customize.py, sfCrrntIni.py</h4>
<p>
There are many implicit assumptions for fields of each expertise at each users. You may use different assumptions for each directories as the cases.
<p>
So we use pysf\customize.py file for global implicit assumptions. Adversely you can use sfCrrntIn.py file in current directory for local implict assumptions. PythonSf does &quot;from pysf.customize import *&quot; and does &quot;from sfCrrntIni import *&quot; if there is a sfCrrntIn.py file in the current directory.
<p>
There are customize.py and sfCrrntIni.py files in distributions of PythonSf. We have defined phyisical units as of &&quot;kg`&quot; or variables as of &quot;`X&quot;. In addition, we have defined pure imaginary number unit:&quot;`i&quot;, Pauli matrix:&quot;`σx `σy `σz&quot; and others in customize.py. We also have defined ratianal unit number:&quot;`1r&quot; in ts() function on customize.py. You can calculte expressions as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
exp(2pi `i/3)
===============================
(-0.5+0.866025403784j)

# addition of oc.BF Bool value vectors
~[`1,`0,`1]+[`1,`1,`1]
===============================
[0 1 0]
---- ClFldTns:< class 'pysf.octn.BF'> ----

`σx + 2`σy
===============================
[[ 0.+0.j  1.-2.j]
 [ 1.+2.j  0.+0.j]]
---- ClTensor ----

# calculation of exponential matrix
t,mt=0.1, `σx + 2`σy; expm(`i t mt)
===============================
[[ 0.97510399+0.j          0.19833750+0.09916875j]
 [-0.19833750+0.09916875j  0.97510399+0.j        ]]
---- ClTensor ----

# series of rational number
ts(); [`1r/(k+1) for k in range(10)]
===============================
[1, 1/2, 1/3, 1/4, 1/5, 1/6, 1/7, 1/8, 1/9, 1/10]

ts(); sum( [`1r/(k+1) for k in range(10)] )
===============================
7381/2520
</span>
</code>
</pre>
<p>
We also have defined rank 3 Levi-Civita tensor:&quot;εL, difirentiating function:&quot;∂x&quot;,Laplace operator unary polynomial:&quot;`s&quot; and others, so you can calculate expressions using these Python objects as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
`εL        # Levi-Civita tensor
===============================
[[[ 0.  0.  0.]
  [ 0.  0.  1.]
  [ 0. -1.  0.]]

 [[ 0.  0. -1.]
  [ 0.  0.  0.]
  [ 1.  0.  0.]]

 [[ 0.  1.  0.]
  [-1.  0.  0.]
  [ 0.  0.  0.]]]
---- ClTensor ----

a,b=~[1,2,3],~[4,5,6]; -a `εL b      # outer product by Levi-Civita tensor
===============================
[-3.  6. -3.]
---- ClTensor ----

a,b=~[1,2,3],~[4,5,6]; np.cross(a,b)     # outer product by Numpy
===============================
[-3.  6. -3.]

∂x(`X^2+1)(1)                      # differential value of x^2+1 at 1
===============================
2.0


∂J(~[`X+`Y, `X `Y], 2)(1,2)        # Jacobian of ~[x+y,x y] field at [1,2]
===============================
[[ 1.  1.]
 [ 2.  1.]]
---- ClTensor ----


1/(`s+1) ( (`s+2) +1/(`s+3))        # calculate Laplace operator expression
===============================
   2
1 s + 5 s + 7
-------------
  2
 s + 4 s + 3

# Bode plot
(1/(`s+1) ( (`s+2) +1/(`s+3))).plotBode(0.01Hz`,100Hz`)
</span>
</code>
</pre>
<img src="./jpg/1111/bode_sp1_sp2_sp2.jpg">
<br>
<p>
In sfCrrntIni.py we have defined Z2,Z3,Z4,Z5,Z7 that are Zp(N) where N is 2,3,4,5,7. There is in global variables, so you can use Z2,Z3,Z4,Z5,Z7 freely in Pythonsf expressions as blow.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
# Z3 行列
~[range(2*2), Z3].reshape(2,2)
===============================
[[Z3(0) Z3(1)]
 [Z3(2) Z3(0)]]
---- ClFldTns:< class 'sfCrrntIni.Z3'> ----

# Z3 行列の逆行列
mt=~[range(2*2), Z3].reshape(2,2); mt^-1
===============================
[[Z3(0) Z3(2)]
 [Z3(1) Z3(0)]]
---- ClFldTns:< class 'sfCrrntIni.Z3'> ----

# Z3 行列どうしの積
mt=~[range(2*2), Z3].reshape(2,2); mt mt^-1
===============================
[[Z3(1) Z3(0)]
 [Z3(0) Z3(1)]]
---- ClFldTns:< class 'sfCrrntIni.Z3'> ----

</span>
</code>
</pre>
<p>
You should customize &quot;customize.py&quot; or &quot;sfCrrntIni.py& by yourself at your convenience. The contents of them are only Python codes, so you can freely change them according to your need.

<h3>File variables</h3>
<p>
You can make a file variable of a picklable instance. In current directory, this file variable is made as a file that extensions is &quot;pvl&quot;. In other words using OOP terms, you can serialize calculated picklable results and can reuse them anytime. You can write the file variable by &quot;:=&quot; and can read it by &quot;=:&quot; The function of file variable is resembling the function of sfCrrntIni.py
<p>
As we show up below, &quot;tmp:=3+4&quot; makes tmp.pvl file in current directory. You can read the &quot;tmp.pvl&quot; file as by &quot;=:tmp; tmp/2&quot;. &quot;:=tmp&quot; reads tmp.pvl file in current directory and set the value to tmp global variable of Python, then you can calculate expression which contain tmp variable.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
tmp:= 3+4
===============================
7
<b>dos command</b>
dir tmp.pvl
D:\my\vc7\mtCm>dir tmp.pvl
 Volume in drive D is ?????
 Volume Serial Number is 4CBC-BC86

 Directory of D:\my\vc7\mtCm

2012/06/15  11:16                42 tmp.pvl
               1 File(s)             42 bytes
               0 Dir(s)  12,429,426,688 bytes free

<b>dos command</b>
type tmp.pvl
# python object printed out by pprint
7

<b>PythonSf one-liner</b>
# read tmp.pvl and halve it
=:tmp; tmp/2
===============================
3.5
</span>
</code>
</pre>
<h4>File variables: X32,X64,X28,  Px32,Px64,Px128 and matrix mechanics</h4>
<p>
We show up most practical examples of file variables. There are X32.pvl,X64.pvl,X28.pvl,  Px32.pvl,Px64.pvl,Px128.pvl files that are position operators of arear [-1,1] and momentum operators of arear [0,2pi]. These are used for Heisenberg's matrix mechanics. For example we show X32 below. 
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
P,X=:Px32,X32; X
===============================
[[-0.96875  0.       0.      ...,  0.       0.       0.     ]
 [ 0.      -0.90625  0.      ...,  0.       0.       0.     ]
 [ 0.       0.      -0.84375 ...,  0.       0.       0.     ]
 ..., 
 [ 0.       0.       0.      ...,  0.84375  0.       0.     ]
 [ 0.       0.       0.      ...,  0.       0.90625  0.     ]
 [ 0.       0.       0.      ...,  0.       0.       0.96875]]
---- ClTensor ----
</span>
</code>
</pre>
You can describe a Hamiltonian matrix as a polynomial made of the position matrix and momentum matrix, so you can calculate the equations those are explained in textbooks of quantum mechanics. For example you can write down a Hamiltonian of harmonic oscillator as below

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
P,X=:Px64, X64; H=P^2+X^2;          H 
===============================
[[ 4.25805908 +8.32667268e-17j  1.99678801 +9.80959047e-02j
   0.49679034 +4.89295777e-02j ...,  0.21901645 -3.24880216e-02j
   0.49679034 -4.89295777e-02j  1.99678801 -9.80959047e-02j]
 [ 1.99678801 -9.80959047e-02j  4.19751221 +5.55111512e-17j
   1.99678801 +9.80959047e-02j ...,  0.12179970 -2.42274668e-02j
   0.21901645 -3.24880216e-02j  0.49679034 -4.89295777e-02j]
 [ 0.49679034 -4.89295777e-02j  1.99678801 -9.80959047e-02j
   4.13891846 -5.55111512e-17j ...,  0.07680678 -1.92390964e-02j
   0.12179970 -2.42274668e-02j  0.21901645 -3.24880216e-02j]
 ..., 
 [ 0.21901645 +3.24880216e-02j  0.12179970 +2.42274668e-02j
   0.07680678 +1.92390964e-02j ...,  4.13891846 +2.04697370e-16j
   1.99678801 +9.80959047e-02j  0.49679034 +4.89295777e-02j]
 [ 0.49679034 +4.89295777e-02j  0.21901645 +3.24880216e-02j
   0.12179970 +2.42274668e-02j ...,  1.99678801 -9.80959047e-02j
   4.19751221 +6.80011603e-16j  1.99678801 +9.80959047e-02j]
 [ 1.99678801 +9.80959047e-02j  0.49679034 +4.89295777e-02j
   0.21901645 +3.24880216e-02j ...,  0.49679034 -4.89295777e-02j
   1.99678801 -9.80959047e-02j  4.25805908 -8.32667268e-17j]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
This Hamiltonian matrix is just only an approximation of infinite one in Hilbert space. Though it is the approximation by a 64x64 matrix at most, it has properties that the harmonic oscillator has in quantum mechanics. Let start with ascending order energy eigenvalues of the Hamiltonian and a list of deference between neighboring elements.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
# Ascending order eigenvalues of the Hamiltonian
P,X=:Px64, X64; H=P^2+X^2; eigvalsh(H)
===============================
[  0.03125000+0.j   0.09375000+0.j   0.15625000+0.j   0.21875000+0.j
   0.28125000+0.j   0.34374997+0.j   0.40625022+0.j   0.46874830+0.j
   0.53125901+0.j   0.59370001+0.j   0.65642917+0.j   0.71797533+0.j
   0.78307742+0.j   0.83758165+0.j   0.91619057+0.j   0.94962095+0.j
   1.06362868+0.j   1.07763419+0.j   1.23050560+0.j   1.23652959+0.j
   1.41810063+0.j   1.42121437+0.j   1.62625614+0.j   1.62810710+0.j
   1.85462810+0.j   1.85582224+0.j   2.10294704+0.j   2.10374776+0.j
   2.37102704+0.j   2.37156478+0.j   2.65874147+0.j   2.65908661+0.j
   2.96600288+0.j   2.96619493+0.j   3.29274974+0.j   3.29281031+0.j
   3.63887701+0.j   3.63893806+0.j   4.00435423+0.j   4.00453612+0.j
   4.38921091+0.j   4.38952113+0.j   4.79342210+0.j   4.79387721+0.j
   5.21696632+0.j   5.21759441+0.j   5.65982304+0.j   5.66066864+0.j
   6.12196967+0.j   6.12310288+0.j   6.60337666+0.j   6.60491066+0.j
   7.10399790+0.j   7.10612440+0.j   7.62374802+0.j   7.62681621+0.j
   8.16243915+0.j   8.16715679+0.j   8.71954535+0.j   8.72762234+0.j
   9.28731293+0.j   9.31657988+0.j   9.75250929+0.j  10.19014824+0.j]
---- ClTensor ----

# Differences of the eigenvalues of the Hamiltonian
P,X=:Px64, X64; H=P^2+X^2; vc=eigvalsh(H); vc=vc-shftSq(vc)
Waring: don't use assignment at last sentence.We ignore the assignment.
===============================
[  3.12500000e-02+0.j   6.25000000e-02+0.j   6.25000000e-02+0.j
   6.24999998e-02+0.j   6.25000026e-02+0.j   6.24999695e-02+0.j
   6.25002517e-02+0.j   6.24980750e-02+0.j   6.25107081e-02+0.j
   6.24410072e-02+0.j   6.27291558e-02+0.j   6.15461604e-02+0.j
   6.51020863e-02+0.j   5.45042324e-02+0.j   7.86089186e-02+0.j
   3.34303833e-02+0.j   1.14007733e-01+0.j   1.40055090e-02+0.j
   1.52871408e-01+0.j   6.02399218e-03+0.j   1.81571035e-01+0.j
   3.11374152e-03+0.j   2.05041772e-01+0.j   1.85096230e-03+0.j
   2.26521002e-01+0.j   1.19413904e-03+0.j   2.47124794e-01+0.j
   8.00725528e-04+0.j   2.67279275e-01+0.j   5.37743185e-04+0.j
   2.87176693e-01+0.j   3.45136237e-04+0.j   3.06916275e-01+0.j
   1.92040921e-04+0.j   3.26554815e-01+0.j   6.05733205e-05+0.j
   3.46066693e-01+0.j   6.10529677e-05+0.j   3.65416172e-01+0.j
   1.81887321e-04+0.j   3.84674788e-01+0.j   3.10218641e-04+0.j
   4.03900971e-01+0.j   4.55112728e-04+0.j   4.23089107e-01+0.j
   6.28094792e-04+0.j   4.42228631e-01+0.j   8.45595766e-04+0.j
   4.61301033e-01+0.j   1.13320700e-03+0.j   4.80273786e-01+0.j
   1.53399721e-03+0.j   4.99087243e-01+0.j   2.12649374e-03+0.j
   5.17623621e-01+0.j   3.06819454e-03+0.j   5.35622935e-01+0.j
   4.71764271e-03+0.j   5.52388560e-01+0.j   8.07698830e-03+0.j
   5.59690586e-01+0.j   2.92669528e-02+0.j   4.35929408e-01+0.j
   4.37638952e-01+0.j]
---- ClTensor ----
</span>
</code>
</pre>
<p>
The first eigen value is 2pi h/2:2/64:3.125e-2:zero point energy. The next deference of the eigenvalues is  2pi h:4/64:6.25e-2.25e. The eigenvalues distribute on a parabolic curve, if they are near the zero point energy. But they distribute on a .. if they get away from the zero point energy. You can visualize the distribution as below.
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
<br>
P,X=:Px64, X64; H=P^2+X^2; plotGr( eigvalsh(H) )
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_harmonic_oscilator_eig.jpg">
<br>
<p>
You can also calculate a dynamic motion of a wave function by the Hamiltonian. If a initial condition is geven as a vector which has concenterd point at the 16th index, you can calculate the dynamics of the wave function including the phase and visualize the result by the below natural one-liner.
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
<br>
P,X=:Px64, X64; H=P^2+10 X^2; vc=kzrs(64); vc[16]=1; renderMtCplx( ~[ expm(`i H t) vc for t in klsp(0, 5s`)]) 

</span>
</code>
<br>
<img src="./jpg/1111/oneliner_harmonic_oscilator_wave_function.jpg">
<!--
<p>
File variables are used as intermediate data when you calculate by a number of one-liners thinking with gradual devlopment.
ファイル変数はワンライナーでは収まらない、何段階もの計算・思考の中間データとして使います。先の Hamiltonian 行列が大規模・複雑で その計算に時間がかかるときは、Hamiltonian 行列のデータを ファイル変数として残しておき再利用する方法を使います。
<== X64 は中間データではない
<p>
全ての PythonSf ワン･ライナー式の計算結果は pickable なときは _dt.pvl ファイルとしてカレント・ディレクトリに残されます。これを別の変数名に OS のコマンドで rename してやれば、その rename された変数名で PythonSf 式の中で利用できます。これらのデータはファイル・データとして HDD 上のカレント・ディレクトリに残っているので永続的に残ります。様々の PythonSf 式で何度でも再利用できます。
-->
<p>
You can user customize files any number of times. So you can utilize customize files as customizing data. You can utilize picklable instances as a customizing data. But you can reuse them by re-reading them using :=. It is small time load to re-read them for PythonSf. If you write a time spending codes in customizing files, PythonSf read them for all each run time, so it will increase response time. So you can utilize PythonSf file variables as customizing data.
<br>
<br>
<br>
<h3>Four operations, exponentiation and composition of basic numeric functions</h3>
<p>
PythonSf has basic numeric functions:exp, sin, cos, tan, sinh, cosh, tanh, arcsin, arccos, arctan, log10, sqrt, absF these are global functions. You can use them without import any statement. In addition they can do four operations, exponentiations and functional composition as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
x=pi/6; ( 2 sin cos )(x), sin(2`X)(x)
===============================
(0.8660254037844386, 0.8660254037844386)
</span>
</code>
</pre>
<p>
We use ClAF class to enable four operations, exponentiation and composition. It is implemented in pysf.basicFnctns module. We make ClAF instances of Numpy exp, sin, cos, tan, sinh, cosh, tanh, arcsin, arccos, arctan, log10, sqrt.
<p>
You can customize your functions enable to do four operations, exponetiation and composition by writing codes that instantiates ClAF with your functions in customize.py or sfCrrntIni.py files. These are imported at each PythonSf run time. So you can use your functions that can do four operations, exponentiation and composition without any import statement.
<p>
We implement ClAF instances of exp, sin, cos, tan, sinh, cosh, tanh, arcsin, arccos, arctan, log10, sqrt in pysf.kNumeric module. Plese read the file, if you are interested in these functions.
<h3>`X,`Y,`Z、`T  variables</h3>
<p>
In mathematical world, x,y,z mean variables. Without referring x,y,z, you can write expressions as sin(x^2), cos(2x+1), tan(x+y), exp(x^2+y^2+z^2) and others. And there meanings are clear. You can write quadratic function x^2+2x+3 without referring x.
<p>
To enable to write such expressions, We have introduced `X,`Y,`Z,`T variables these are assigned as identical functions these can do four operations, exponentiation and composition. These are assigned in customize.py file. These identical functions:`X,`Y,`Z,`T also mean to select the first,second,third and last parameter from argments. Though they are identical functions, you can write any polynomial combining them as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
(`X^2+2`X+3)(2)     # quadratic function
===============================
11

(`X^2+`Y^2)(2,3)     # 2 parameter quadratic function
===============================
13

(`X^2 + `T)(2,3)    # `T picks up the last parameter 3
===============================
7

N=6; [(sin(2`X))(n/N) for n in range(N)]
===============================
[0.0, 0.32719469679615221, 0.61836980306973699, 0.8414709848078965, 0.97193790136331271, 0.99540795775176494]
</span>
</code>
</pre>
<h3>Utilize Numpy and SciPy package</h3>
<p>
In Python there are Numpy, SciPy packages these implement very big mathematical libraries. SciPy contain Numpy, SciPy has sub packages as  scipy.optimize,integrate,linalg,special,signal and others these are sold as a proprietary package in Matlab. But Numpy doesn't have these packages.
<p>
But you have to use Numpy package. Because SciPy is too big and you have to wait to import it. It would be 2 second if computers are low power such as netbooks those CPU is N280. On the other hand it is 200 mili second to import Numpy even at netbooks. So PythonSf importr Numpy at every turn. But SciPy is imported when you call sy() function.
<p>
If you call sy() function, Python dose &quot;import scipy as sy&quot; statement. In addition, it imports below sub packages and set so,si,sl,ss,sg module labels for them. These sub packaged has below features.
<ol>
<li>so optimize:    General-purpose Optimization Routines
<li>si integrate:   Methods for Integrating Functions given function object.
<li>sl linalg:      Linear Algebra
<li>ss specia:      Special Functions
<li>sg signal:      Signal Processing Tools
</ol>
<p>
PythonSf imports Numpy at every turn in pysf.sfFnctns module by &quot;import numpy as np&quot; statement. You can use large number of functions in Numpy package under np name-space as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
# numpy.source(..) returns souce code for a function or class that is given as a parameter
np.source(fft)
In file: pysf\kNumeric.py

def fft(sqAg, n=None, axis = -1):
    """' reverse Fasst Fourier Transform
         return ClTensor array
    '"""
    import numpy.fft as fp
    return sf.krry(fp.fft(sqAg, n, axis))

===============================
None

<b>PythonSf one-liner</b>
# numpy.info(..) returns conpact information about a function or class that is given as a parameter
# The information is not too detailed as help(..)
np.info(np.linalg)
Core Linear Algebra Tools
-------------------------
Linear algebra basics:

- norm            Vector or matrix norm
- inv             Inverse of a square matrix
- solve           Solve a linear system of equations
- det             Determinant of a square matrix
- lstsq           Solve linear least-squares problem
- pinv            Pseudo-inverse (Moore-Penrose) calculated using a singular
                  value decomposition
- matrix_power    Integer power of a square matrix

Eigenvalues and decompositions:

- eig             Eigenvalues and vectors of a square matrix
- eigh            Eigenvalues and eigenvectors of a Hermitian matrix
- eigvals         Eigenvalues of a square matrix
- eigvalsh        Eigenvalues of a Hermitian matrix
- qr              QR decomposition of a matrix
- svd             Singular value decomposition of a matrix
- cholesky        Cholesky decomposition of a matrix

Tensor operations:

- tensorsolve     Solve a linear tensor equation
- tensorinv       Calculate an inverse of a tensor

Exceptions:

- LinAlgError     Indicates a failed linear algebra operation
===============================
None

<b>PythonSf one-liner</b>
# pseud-inverse of matrix
np.linalg.pinv([[1,2,3],[4,5,6]])
===============================
[[-0.94444444  0.44444444]
 [-0.11111111  0.11111111]
 [ 0.72222222 -0.22222222]]

<b>PythonSf one-liner</b>
# confirmation of upper result
# The multiplication with pseud-inverse is a unit matrix
np.dot([[1,2,3],[4,5,6]], np.linalg.pinv([[1,2,3],[4,5,6]]))
===============================
[[  1.00000000e+00  -4.44089210e-16]
 [  0.00000000e+00   1.00000000e+00]]
</span>
</code>
</pre>
<p>
By the way, we have modified Numpy Fourier transform:fft,ifft,fftshift, eigen values or eigen vectors:eig,eigvals, exponetial/logarithm/square root of matrix:expm,logm,sqrtm, and random: rand,randn,randint,shuffle those are used frequently and changed to return ClTensor instances. You can directly use these functions as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
fft([1,2,3,4])
===============================
[ 10.+0.j  -2.+2.j  -2.+0.j  -2.-2.j]
---- ClTensor ----

eig([[1,2],[3,4]])
===============================
(ClTensor([-0.37228132,  5.37228132]),
ClTensor([[-0.82456484, -0.41597356],
       [ 0.56576746, -0.90937671]]))

eigvals([[1,2],[3,4]])
===============================
[-0.37228132  5.37228132]
---- ClTensor ----

expm([[1,2],[3,4]])
===============================
[[  51.9689562    74.73656457]
 [ 112.10484685  164.07380305]]
---- ClTensor ----

sqrtm([[1,2],[3,4]])
===============================
[[ 0.55368857+0.46439416j  0.80696073-0.21242648j]
 [ 1.21044109-0.31863972j  1.76412966+0.14575444j]]
---- ClTensor ----

seed(0); rand(2,3)
===============================
[[ 0.5488135   0.71518937  0.60276338]
 [ 0.54488318  0.4236548   0.64589411]]
---- ClTensor ----

seed(0); randn(2,3)
===============================
[[ 1.76405235  0.40015721  0.97873798]
 [ 2.2408932   1.86755799 -0.97727788]]
---- ClTensor ----

seed(0); randint(10,size=[2,3])
===============================
[[5 0 3]
 [3 7 9]]
---- ClTensor ----

seed(0); shuffle(range(10))
===============================
[2, 8, 4, 9, 1, 6, 7, 3, 0, 5]
</span>
</code>
</pre>
<p>
You can use SciPy package after calling sy() function as below.

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
sy(); sy.factorial(10), sy.factorial(10, True)
===============================
(array(3628800.0), 3628800L)

</span>
</code>
</pre>
<p>
SciPy will be imported as sy label of the package, if you call sy() function. Function sy() alsom executes &quot;import scipy.optimize as so&quot;,&quot;import scipy.integrate as si&quot;,&quot;import scipy.linalg as sl&quot;,&quot;import scipy.special as ss&quot;,&quot;import scipy.signal as sg&quot; statements. Calling sy() only one time, you can use very huge amount of functions in optimize,integrate,linalg,special,signal sub packages under the lebels of so,si,sl,ss,sg.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
sy(); so.bisect(`X^3+2`X^2-3`X-1, -10,10)   # find 0 point by bi-section method
===============================
1.19869124352

<b>PythonSf one-liners</b>
# double integral: integral of functio f(x,y)=x^2 + y^2 on a area in a circle with a radius of 1 from a origin
sy(); si.dblquad(`X^2+`Y^2, -1,1, sqrt(1-`X^2),-sqrt(1-`X^2) )
===============================
(-1.5707963267947727, 1.2484818956437493e-08)
# 1.2484818956437493e-08 in right side is a estimated accidental error

<b>PythonSf one-liners</b>
sy(); sl.sinm(`σx)         # sinm(x) == x - x^3/3! + x^5/5! - ...
===============================
[[ 0.          0.84147098]
 [ 0.84147098  0.        ]]
# Attention! Universal functions in SciPy return ClTensor instances if you give ClTensor instances parameter.
# But there are some functions these are not ufunc and doesn't return ClTensor instance as sl.sinm, even though you give a ClTensor instance parameter.

<b>PythonSf one-liners</b>
sy(); ss.zeta(3,0)          # special function ζ(..) 
===============================
1.79769313486e+308
</span>
</code>
</pre>

<h4>info,source functions in Numpy</h4>
<p>
&quot;info functions in Numpy&quot; is very convenient. It prints more compact information than &quot;help() function" and just only np.info(..)'s information is sufficient frequently. You can use np.info(..) for every Python object as of package, module, class, function or a instance which have document strings. &quot;np.info(..)&quot; should be used more frequently without limiting in PythonSf.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.info(set)
 set()

set() -> new empty set object
set(iterable) -> new set object

Build an unordered collection of unique elements.


Methods:

  difference_update  --  Remove all elements of another set from this set.
  symmetric_difference  --  Return the symmetric difference of two sets as a new set.
  pop  --  
  issuperset  --  Report whether this set contains another set.
  remove  --  Remove an element from a set; it must be a member.
  issubset  --  Report whether another set contains this set.
  union  --  Return the union of sets as a new set.
  add  --  Add an element to a set.
  discard  --  Remove an element from a set if it is a member.
  intersection  --  Return the intersection of two or more sets as a new set.
  symmetric_difference_update  --  Update a set with the symmetric difference of itself and another.
  update  --  Update a set with the union of itself and others.
  difference  --  Return the difference of two or more sets as a new set.
  copy  --  Return a shallow copy of a set.
  isdisjoint  --  Return True if two sets have a null intersection.
  clear  --  Remove all elements from this set.
  intersection_update  --  Update a set with the intersection of itself and another.
===============================
None
</span>
</code>
</pre>
<p>
&quot;np.source(..)&quot; is a function that print out a source code of module,class,method or function. Python is a language which is one of the most readable languages. You can frequently understand a Python class or function by reading the source codes more than by reading the document. Please check source codes if you are hard to understand the documents as below. 
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
np.source(mitr)
In file: pysf\basicFnctns.py

def mitr(*args):
    """ 多次元の繰り返しを生成するジェネレータ
        generator generating for multiple dimention iterators
    e.g.
    list(mitr(2,3))
    ===============================
    [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)]

    s=set(['a','b']);list(mitr(s,s))
    ===============================
    [('a', 'a'), ('a', 'b'), ('b', 'a'), ('b', 'b')]

    s=[1,2,3];list(mitr(s,s))
    ===============================
    [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]

    """
    head, tail = args[0], args[1:]

    if type(head) in [int, long, float]:
        head = range(int(head))

    if tail:
        if len(tail) == 1 and hasattr(tail[0],'next'):
            # to avoid multiple use of one iterator
            tailAt = (tuple(tail[0]), )
        else:
            tailAt = tail

        for i in head:
            for j in mitr(*tailAt):
                if len(tail) == 1:
                    yield (i, j)
                else:
                    yield (i,)+j
    else:
        for i in head:
            yield i

===============================
None
</span>
</code>
</pre>
<p>
By the way the upper mitr(..) is a generator function which express multi loops at just one iterator. PythonSf use it because it expresses multiple loops shortly. You might unerstand that it deals with arbitrary N multiple loops and is implemented as in functional programming style, if you trace the source code.
<p>
It is also worth nothing that the feature of mitr(..) is same as that of itertools.product(..). But we dare to use mitr(..), because we implemented mitr(..) before itertools.product(..) and it is consistent with the next enumitr(..) generator.
<p>
&quot;enmitr(..)&quot; generator has a feature of integer index adding to the feature of mitr(..). So it is convenient to create a matrix or tensor data as below
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
# create a dictionary matrix data of x^2 - x y fucntion distribution on the area of [-1,1]x[-1,1] and pay it to graph
dct={}; v=klsp(-1,1); for idx,pos in enmitr(v,v):dct[idx]=(`X^2-`X `Y)(*pos); renderMtrx(dct)
</span>
</code>
</pre>
<img src="./jpg/1111/oneliner_xpw2_xy.jpg">
<br>
<p>
If you come across unkown codes, you can examint them by using np.info(..), np.source(..).  If you don't understand the feature of klsp(..), please examine it by np.info(..) and np.source(..). It is easy to examine them using PythonSf one-liners as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
# source of klsp(..): just only re-cast a Numpy instance that linspace created to the ClTensor instance.
np.source(klsp)
In file: pysf\basicFnctns.py

def klsp(*sq, **dct):
    """' return ClTensor of scipy.linspace(...)
    '"""
    return sf.krry(sc.linspace(*sq, **dct) )

===============================
None

# ClTensor 50 points data that was created by cutting into equal 49 parts of [-1,1] area
klsp(-1,1)
===============================
[-1.         -0.95918367 -0.91836735 -0.87755102 -0.83673469 -0.79591837
 -0.75510204 -0.71428571 -0.67346939 -0.63265306 -0.59183673 -0.55102041
 -0.51020408 -0.46938776 -0.42857143 -0.3877551  -0.34693878 -0.30612245
 -0.26530612 -0.2244898  -0.18367347 -0.14285714 -0.10204082 -0.06122449
 -0.02040816  0.02040816  0.06122449  0.10204082  0.14285714  0.18367347
  0.2244898   0.26530612  0.30612245  0.34693878  0.3877551   0.42857143
  0.46938776  0.51020408  0.55102041  0.59183673  0.63265306  0.67346939
  0.71428571  0.75510204  0.79591837  0.83673469  0.87755102  0.91836735
  0.95918367  1.        ]
---- ClTensor ----

# ClTensor 6 points data that was created by cutting into equal 5 parts of [-1,1] area
klsp(-1,1, 6)
===============================
[-1.  -0.6 -0.2  0.2  0.6  1. ]
---- ClTensor ----
</span>
</code>
</pre>
<p>
It is effective not only at PythonSf expressions but alsot at general Python codes to examine Pythonobjects usint np.inf(..), np.source(..). Plese utilize them.
<!--
Numpy 行列関数
その他で使う頻度の多い Numpy 行列関数として下のようなものが PythonSf global 変数に取り込んでいます。
expm,logm, sqrtm, ['eigvalsh', 'eigvals', 'eig', 'eigh']
用例だけ
-->

<h4>Differences between np.ndarray, ClTensor and ClFldTns matrices</h4>
<!--
ベクトルの内積はベクトルどうしの積によって計算させます。

vc=np.array([1,2,3]);vc[0]=2.4; vc
===============================
[2 2 3]
<== 何度も痛い目にあって、数値計算向けのデフォルト整数にしました。
ベクトル
<== デフォルト整数、dot を使わねばならない。
np.dot
    行列　ベクトルの積
    ClTensor/ClFldTns には縦ベクトル、横ベクトルの区別がない
最後のClTensor, ClFldTns 表記による区別

np.matrix は ndarray と統一が取れていない
<== fast tour の段階では避けるべき。
    np.matrix はあるが、使いにくい
        np.matrix(`σx) [1,2]
        matrices are not aligned at excecuting:np.matrix(k__bq__sSigma_x___) * [1,2]
        np.matrix(`σx) [[1],[2]]
        ===============================
        [[ 2.]
         [ 1.]]

Numpy/SciPy の行列・ベクトルは matlab に近い実装
三次元 vector 分布関数
~[`X^2+1,`X^2+`Y^2, `Z](1,2,3)
===============================
[ 2.  5.  3.]
---- ClTensor ----
-->
<p>
PythonSf primarily uses ClTensor or ClFldTns instances than numpy.ndarray. Because they are easier to calculate vectors or matrices. PythonSf uses ClTensor instances whose elements are integer, float or complex and ClFldTns instances whose elements are not integer, float and complex.  Instances which are made by ~[...] expressions are eather ClTensor instances or ClFldTns instances
<p>
We list up below why we avoid numpy.ndarray 
<ol>
<li>If you create a vector or matrix with integer parameters, then integer type vector or matrix is generated. So if you assign float values to elements of the vector or matrix, then the elements was assigned by the integer to which the float values are truncated.
<li>You need numpy.dot(..) function for multiplication of vectors and matrices.
</ol>
<p>
You would be embarrassed, if you use numpy.ndarray. Because you would unconsciously use makes integer type vectors or matrices for float ones, They would work plausibly and you would accumulate considerations without noticing them. It is difficult to find out erroneous expressions afterward. It is rare in mathematics to distinguish integer and float, because both of them are number. Even though you would be careful for the miss-uses, they would steal into your expressions because of mathematical habits. So ClTensor class makes float type vectors or matrices, if you designate &quot;int&quot; explicitly, although it inherits numpy.ndarray.
<p>
We also have implementd functions corresponding to four operations and exponentiation like as __mul__(..), __pow__(..) and others. So you can write expressions of vector, matrices that are more resembled to daily memo writing expressions.
<p>
You can calculate four operations between a ClTensor instance and Python sequence as tuple, list, numpy.ndarray, if their dimension is conformed. So you can calculate multiplications between a matrix and vector or inner products between vector and sequence, without using a row vector or column vector as in Matlab. You can look at the examples below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
# inner product
vc=~[1,2,3]; vc ~[4,5,6]
===============================
32.0

# a inner product between a vector and list
vc=~[1,2,3]; vc  [4,5,6]
===============================
32.0

~[k for k in range(1,4)] [4,5,6]
===============================
32.0

vc=~[1,2,3]; vc range(4,7) 
===============================
32.0

# inner product between a vector and tuple
vc=~[1,2,3]; vc  (4,5,6)

# multiplication between a matrix and vector
mt = ~[[1,2],[3,4]]; mt ~[5,6]
===============================
[ 17.  39.]
---- ClTensor ----

# multiplication between a matrix and list
mt = ~[[1,2],[3,4]]; mt  [5,6]
===============================
[ 17.  39.]
---- ClTensor ----

# multiplication between a list and matrix
mt = ~[[1,2],[3,4]]; [5,6] mt 
===============================
[ 23.  34.]
---- ClTensor ----

# multiplication between a matrix and tuple
mt = ~[[1,2],[3,4]]; mt  (5,6)
===============================
[ 17.  39.]
---- ClTensor ----
</span>
</code>
</pre>
<p>

<h4>Numpy package から取り込み</h4>
<p>
Numpy package has sub packages for random functions, FFT, linear algebra and others these are used frequently, though they are smaller than that of SciPy package. PythonSf utilize them in a positive manner, because it is faster to import numpy than importing scipy.
<p>
You can call them like as &quot;np.random.rand(..)&quot;. But the calling string are too long for frequent usage. So we implement global buffer functions of these numpy sub packages. In passing we modified them to make return a ClTensor instance: not a numpy.ndarray instance.

<h5>random functions</h5>
<p>
The numpy.random module provides functions of radint(..) that returns random integers from the discrete uniform distribution, rand(..) that returns random values between 0 and 1 in a given shape:, randn(..) that returns a sample (or samples) from the standard normal distribution and shuffle(..) that return a modified sequence in-place by shuffling its contents. These functions are very convenient because they can deal with a matrix or vector.
<p>
We have implemented rand(..) function as below.
<pre>
<code>
<span style="color: #9f009f;">
np.source(rand)
In file: pysf\kNumeric.py

def rand(*sqAg):
    if len(sqAg) == 0:
        return        (sf.sc.random.rand(*sqAg))
    else:
        return sf.krry(sf.sc.random.rand(*sqAg))

===============================
None
</span>
</code>
</pre>
<p>
We have also exchanged functions of seed(..), randint, randn(..) and suffle(..). So you can shortly write expressions that utilize functions in NumPy random package as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
# return a randome value in [0,1] range.
seed(0); rand()
===============================
0.548813503927

# return a matrix of that elements are random values in [0,1] range.
seed(0); rand(2,4)
===============================
[[ 0.5488135   0.71518937  0.60276338  0.54488318]
 [ 0.4236548   0.64589411  0.43758721  0.891773  ]]
---- ClTensor ----

# return a matrix of that elements are in the normal distribution
seed(0); randn(2,4)
===============================
[[ 1.76405235  0.40015721  0.97873798  2.2408932 ]
 [ 1.86755799 -0.97727788  0.95008842 -0.15135721]]
---- ClTensor ----

# return a integer type matrix of that elements are integers betwee 0 and 8
randint(9,size=[2,5])
===============================
[[5 6 7 3 1]
 [8 1 1 7 4]]
---- ClTensor ----

# return a floating type matrix of that elements are betwee 0 and 8
~[randint(9,size=[2,5])]
===============================
[[ 1.  0.  5.  2.  4.]
 [ 5.  1.  8.  5.  6.]]
---- ClTensor ----

# return a type matrix of that elements are BF:Bool Field
~[randint(2,size=[2,5]), oc.BF]
===============================
[[0 1 0 0 1]
 [1 1 0 0 0]]
---- ClFldTns:< class 'pysf.octn.BF'> ----
</span>
</code>
</pre>
<p>
You can verify a formula:sin(2θ)==2sin(θ)cos(θ) by numerical experiment as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
# proof/confirm the formulat:sin(2θ)== 2sin(θ)cos(θ)
vc=randn(10); [sin(2θ) for θ in vc] ~== [2 sin(θ) cos(θ) for θ in vc]
===============================
True

# also proof/confirma in complex numbers
# 複素数値でも sin(2θ)== 2sin(θ)cos(θ)
mt=randn(2,10);vc=mt[0,:]+`i mt[1,:];  [sin(2θ) for θ in vc] ~== [2 sin(θ) cos(θ) for θ in vc]
===============================
True
</span>
</code>
</pre>
<p>
To execute the uuper one-liner means <b>you have confirmed ten times that sin(2θ) is same with 2sin(θ)cos(θ) in 6 digits precision for random θ</b>. &quot;~==&quot; is a user defining infix operator and we have assigned nearlyEq(..) function to it in customize.py file. This function returns true if the arguments are same in more than 6 digits precision. (You can't use &quot;==&quot; operator, because computers use floating numbers and there are accidental errors in calculated results so that formulas is not true for &quot;==&quot; operator. It may be no exaggeration to say that we have proved the formula &quot;sin(2θ)==2sin(θcons(θ)&quot; after confirming 10 times in 6 digits precision. Because errors might sneak into the proof with very higher provability.
<p>
You can conveniently use random functions for proofs like this.
<p>
There is a function:shuffle(..) in numpy.random module and it permutates elments of a sequence. However the shuffle function returns None. It updates just contents of a reffed argument. But it is strongly required for one-liners to return the reference too. So we modified the shuffle function as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
np.source(shuffle)
In file: pysf\kNumeric.py

def shuffle(sqAg):
    sf.sc.random.shuffle(sqAg)
    return sqAg

===============================
None
</span>
</code>
</pre>
<p>
So you can use it as blow.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
shuffle(range(10))
===============================
[1, 7, 4, 9, 0, 2, 5, 3, 6, 8]

# comparing： shuffle(..) of NumPy
np.random.shuffle(range(10))
===============================
None

lst=range(10); np.random.shuffle(lst); lst
===============================
[6, 8, 0, 3, 1, 5, 9, 4, 7, 2]
</span>
</code>
</pre>
<br>
<h5>Fast Fourier Transform:FFT</h5>
<p>
(Inverse) Fourier Transform is used frequently in many field. So we should put them in PythonSf global name space. And it is convenient to return a ClTensor instance. So we have modified fft,ifft and fftshift in numpy.fft package.
<p>
Note that fft and ifft in NumPy don't conserve a norm. It maintais spectrum density as Matlab. But we strongly require the FFT that maintains norm in mathematics. So we have implemented nft(..) and inft(..)
<p>
In addition the FFT deals with arbitrary length sequence. Doesn't limit it's length to 2^N.
<p>
We show examples below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
N=7; fft(range(N))
===============================
[ 21.0+0.j          -3.5+7.26782489j  -3.5+2.79115686j  -3.5+0.79885216j
  -3.5-0.79885216j  -3.5-2.79115686j  -3.5-7.26782489j]
---- ClTensor ----

N=7; ifft(fft(range(N)))
===============================
[  2.91830052e-15+0.j   1.00000000e+00+0.j   2.00000000e+00+0.j
   3.00000000e+00+0.j   4.00000000e+00+0.j   5.00000000e+00+0.j
   6.00000000e+00+0.j]
---- ClTensor ----

N=7; nft(range(N))
===============================
[ 7.93725393+0.j         -1.32287566+2.7469796j  -1.32287566+1.05495813j
 -1.32287566+0.30193774j -1.32287566-0.30193774j -1.32287566-1.05495813j
 -1.32287566-2.7469796j ]
---- ClTensor ----

N=7; inft(nft(range(N)))
===============================
[  2.85344905e-15+0.j   1.00000000e+00+0.j   2.00000000e+00+0.j
   3.00000000e+00+0.j   4.00000000e+00+0.j   5.00000000e+00+0.j
   6.00000000e+00+0.j]
---- ClTensor ----

N=7; norm(fft(range(N))) ~== ( sqrt(N) norm(nft(range(N))))
===============================
True
</span>
</code>
</pre>

<!--
2 のべき乗の長さに限りません。
norm の保存
fft,
    ClTensor を返す
-->
<h5>expm,logm, sqrtm, eigvalsh, eigvals, eig, eigh</h5>
<p>
We have modified matrix functions:expm(.), logm(.) sqrtm(.), egvals(.)/eigvalsh(.) and eig(.)/eigh(.). So they return a ClTensor instance as blow.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
t=0.1; expm(`σx t)
===============================
[[ 1.00500417  0.10016675]
 [ 0.10016675  1.00500417]]
---- ClTensor ----

t=0.1; logm( expm(`σx t) )
===============================
[[ -9.02056208e-17   1.00000000e-01]
 [  1.00000000e-01  -9.02056208e-17]]
---- ClTensor ----

t=0.1; sqrtm(`σx t)
===============================
[[ 0.15811388+0.15811388j  0.15811388-0.15811388j]
 [ 0.15811388-0.15811388j  0.15811388+0.15811388j]]
---- ClTensor ----

t=0.1; sqrtm(`σx t)^2
===============================
[[ 0.0+0.j  0.1+0.j]
 [ 0.1+0.j  0.0+0.j]]
---- ClTensor ----

t=0.1; eigvalsh(`σx t)
===============================
[-0.1  0.1]
---- ClTensor ----

t=0.1; eigh(`σx t)
===============================
(ClTensor([-0.1,  0.1]),
ClTensor([[-0.70710678,  0.70710678],
          [ 0.70710678,  0.70710678]]))

t=0.1; mt=`σx t; mt[1,1]=3; eigvals(mt)
===============================
[-0.00332964  3.00332964]
---- ClTensor ----

t=0.1; mt=`σx t; mt[1,1]=3; eig(mt)
===============================
(ClTensor([-0.00332964,  3.00332964]),
ClTensor([[-0.99944614, -0.03327794],
          [ 0.03327794, -0.99944614]]))
</span>
</code>
</pre>
<p>
If you have SciPy functions that are not ufunc, you can customize them to return a ClTensor instance like as upper exmaples for short one-liner expressions.
<p>
By the way, we have implemented pp(.) function to print just only a vector or matrix for easy-to-understand calculated results by suppressing extra zeros as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
t=0.1; pp(sqrtm(`σx t)^2)
[[   0, 0.1]
,[ 0.1,   0]]
-------- pp --
===============================
None
</span>
</code>
</pre>
<br>
<h3>utilize SymPy package</h3>
<p>
SymPy package enable you to deal with symbolic expressions. SymPy is newly developed and is pale before Mathematica,Maxima and others. You might come across a bug, if you write hundreds of SymPy codes. But SymPy is developed to a sufficiently practical level for one-liners.
<p>
You must call ts() function to utilize SymPy at a PythonSf one-liner. The function call executes &quot;import sympy as ts&quot; and assign symbolic variables to `x,`y,`z and `t. So you can manipulate symbolic expressions as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
# solve below equations for x,y variable
# x+y+z = 6
# x-y   = 0
ts(); ts.solve( [`x+`y+`z-6, `x-`y], [`x,`y] )
===============================
{x: -z/2 + 3, y: -z/2 + 3}

# solve below equations for x,y variable
# (x+z) y = 6
# x-y     = 0
ts(); ts.solve( [(`x+`z) `y-6, `x-`y], [`x,`y] )
===============================
[(-z/2 + (z**2 + 24)**(1/2)/2, -z/2 + (z**2 + 24)**(1/2)/2),
 (-z/2 - (z**2 + 24)**(1/2)/2, -z/2 - (z**2 + 24)**(1/2)/2)]
</span>
</code>
</pre>

<h3>calculations with units</h3>
<p>
You can calculte numbers with SI units in PythonSf. We utilize units of sympy.physics.unit. We have assigned units to A`,Ω`,V` and others in customize.py utilizing the extension of name space by &quot;`&quot;. You can use them after calling &quot;ts()&quot;, because we use SymPy. We show some examples below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# Voltage／Current--> Resistance
ts(); V,I=3.0V`, 2  A`; V/I
===============================
1.5*V`/A`

# Voltage／Resistance--> Current
ts(); V,R=3.0V`, 1.5Ω`; V/R
===============================
2.0*A`
</span>
</code>
</pre>
<p>
We have assigned units to f` p` n` u` mili` k` M` G` hour` min` s` ms` us` ns` ps` kg` g` =1, nm` um` mm` cm` m` met met km` inch` feet` mile` C` A` mA` uA` V` mV` uH` F` uF` pF` Ω` kΩ` ohm` Hz` N` J` mLght` in customize.py. You can any hopeful units by adding Python codes at this place.

<h4>Physical constants with units</h4>
<p>
We have assigned below principal physical constants with units in customize.py.
<pre>
<code>
<span style="color: #9f009f;">
<b>Python codes</b>
    #=========== physical constants begin ========================
    # light velosity m/s
    k_c_bq____ = 2.99792458e+8 * ut.m / ut.s            #@:c` --> k__bq__c___

    # planck constant h/2π 1.054571628(53)×10-34 J s 
    k_h_bq__bq____ = 1.054571628e-34 * ut.J * ut.s      #@:h`` --> h/(2π)
    k_h_bq____ = 6.62606896e-034 * ut.J * ut.s          #@:h` -->


    #Boltzman constant   J K^-1。 K is a unit of absolute temparature. Joule/Kelvin
    k_kB_bq____ = 1.380662e-23 * ut.J / ut.K            #@:kB` -->

    #universal constant of gravitation gU` = 6.67259 ×10-11  N` m`^2 `kg-2 
    k_gU_bq____ = 6.67259e-11 * ut.N * ut.m**2 / ut.kg**2 #@:gU` -->
    #gravitational constant gH`  = 9.80665  m s-2 
    k_gH_bq____ = 9.80665 * ut.m / ut.s**2              #@:gH` -->

    #elementary charge eQ`  = 1.6021892 ×10-19  C 
    k_eQ_bq____ = 1.6021892e-19 * ut.C
    #mass of electron eM`  = 9.10938188 ×10^-31  kg 
    k_eM_bq____ = 9.10938188e-31 * ut.kg
    #mass of proton pM`  = 1.67262157 ×10^-27  kg 
    k_pM_bq____ = 1.67262157e-27 * ut.kg
    #mass of hydrogen atom HM` = 1.6735 ×10^-27  kg 
    k_HM_bq____ = 1.6735e-27 * ut.kg
    #number of moles,Avogadro number　 NA`  = 6.02214199 ×10^23  mol-1
    k_NA_bq____ = 6.02214199e+23 / ut.mol
    #molal volume Vm`  = 2.241383 ×10-2  m3mol-1 
    k_Vm_bq____ = 2.241383e-2 * ut.m**3 / ut.mol

    #permeability of vacuume 1.2566370614E-06 == 4`π 1e-7, physical unit N` A`^-2 == henry/meter == weber/(ampere meter)
    k__sMu_0_bq____ = 1.2566370614e-6 * ut.H/ut.m        #@μ0` -->
    k_u0_bq____ = 1.2566370614e-6 *ut.H/ut.m
    # permittivity of vacuum ε0 == 1/(`c^2 4`π 1e-7)==coulomb**2 / (newton * M ** 2) == farad/meter == coulomb/(volt meter)
    k__sEpsilon_0_bq____ = 8.854187816e-12 * ut.F/ut.m  #@:ε0` -->
    k_e0_bq____ = 8.854187816e-12 * ut.F/ut.m

    #=========== physical constants end = ==================================
</span>
</code>
</pre>
<p>
So you can calculate one-liners as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
# E == m c^2 == h ν
# ∴ ν== m c^2/h
# frequency of electron at 4 dimensional space time
ts(); eM` c`^2/h`
===============================
1.23558993864461e+20/s`
</span>
</code>
</pre>

<p>
What units or physical constants are needed dipends largely on your area of specialization. The units and physical constants of Pythonsf are defined by Python codes in customize.py. You can customize the units and physical constants as you want by modifying the Python codes.

<h4>units of a just only number</h4>
<p>
It is convenient and needed to use units consisted of a just only number.
<p>
PythonSf expressions with units is explanatory. &quot;15V` * 1.3A`&quot; means a multiplication of a value of voltage and a value of current. So you can guess it will result wattage from just only the PythonSf expression without any other documents.
<p>
Arguments with SymPy units is called only by SymPy functions and PythonSf basic numeric functions and four operations, exponentiation and composition of them. General Python functions as in NumPy can't deal with the value of SymPy units, although the SymPy unit's value become the null unit dimension eliminating each other. They will return error comments as below. 

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
# set a value with SymPy units to NumPy sin function.
ts(); np.sin( 2pi 50Hz` 0.1s`)
Traceback (most recent call last):
    sniped
AttributeError: sin

# set a value with SymPy units to PythonSf basic numeric sin function
ts();    sin( 2pi 50Hz` 0.1s`)
===============================
2.32806687965e-15
</span>
</code>
</pre>
<p>
It is impossible to set a parameter with units in physics that describe natural law. So PythonSf basic numeric functions except for sqrt(..) and absF(..) will return error comments, if you give a parameter that is not the null dimension eliminating the unit(s) each other.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
# set a parameter with a SymPy unit to PythonSf basic numeric function:sin(..) 
ts();    sin( 2pi 50Hz`      )
Traceback (most recent call last):
  File "C:\Python27\lib\runpy.py", line 162, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "C:\Python27\lib\runpy.py", line 72, in _run_code
    exec code in run_globals
  File "D:\my\vc7\mtCm\sfPP.py", line 2, in <module>
    pysf.sfPPrcssr.start()
  File "pysf\sfPPrcssr.py", line 2776, in start
    __execLine( (" ".join(sys.argv[1:])).strip() )
  File "pysf\sfPPrcssr.py", line 2392, in __execLine
    valStt = eval(ustConvertedAt, globals(), locals() )
  File "<string>", line 1, in <module>
  File "pysf\basicFnctns.py", line 854, in __call__
    return self.m_fn(lstGlbAt['Float'](agAt))
  File "pysf\customize.py", line 750, in Float
    + str(fnAt)
AssertionError: At Float(.), you set physical quantity parameter,the units of which are not cancelled:314.159265358979/s`

ts();    sqrt( 2pi 50Hz`      )
===============================
17.7245385090552/s`**(1/2)

ts();    absF(-2pi 50Hz`      )
===============================
314.159265358979/s`
</span>
</code>
</pre>
<p>
But in engennering there are many functions with parameter(s) that have units. For an example, characteristics of filters can be describe ty funcsions exp(..) and others.
<p>
On the other hands, there are no needs to assign SymPy units as Hz`, if you want just only explanatory expressions. As you many assign just number 1 to Hz`, s` and others, the PythonSf expressions are explanatory. So we have decided to assign just number 1 for units before ts() function is called. Then we can use explanatory PythonSf expressions for arbitrary Python functions. We can calculate as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
      np.sin( 2pi 50Hz` 0.1s`)
===============================
2.32806687965e-15
</span>
</code>
</pre>
<p>
Looking at upper, we implemented ts() function.  Plese read the souce codes of ts() in pysf\customize.py file, if you are interested in this function.

<h4>MKSA:SI unit system and MKSAV unit system</h4>
<p>

<a href="http://physics.nist.gov/Pubs/SP330/sp330.pdf">The written standart of SI unit system</a>explains just only how to use it without reasons. And SI is established by compromise to historical backgrounds.backgrounds. Although most engineers regards A:current and V:voltage or ohm:resistance as base units, SI have decided only A:current as a base unit. So that voltage and resistance value is expressed by a combination of M K S A four basic units. Actually sympy.physics.units implements unit system according to SI standard and calculates a expression with units as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
# resistance * current:R I == voltage:V
import sympy.physics.units as ut; R,I=1.5ut.ohm, 2ut.A; R I
===============================
3.0*m**2*kg/(A*s**3)

# voltage / current:V/I == resistance：ohm
import sympy.physics.units as ut; V,I=3.0ut.V  , 2ut.A; V/I
===============================
1.5*m**2*kg/(A**2*s**3)

# fine structure constant 1
ts(); eQ`^2/(4pi ε0` h`` c`)
===============================
0.00729746834685501*A`*s`**3*V`/(kg`*m`**2)

# fine structure constant 2
ts(); eQ`^2/(4pi ε0` h`` c`) J`/s`/W`
===============================
0.00729746834685501

</span>
</code>
</pre>
<p>
But most engineers can't understance the voltage unit:&quot;m**2*kg/(A*s**3)&quot; and the resistance unit:&quot;m**2*kg/(A**2*s**3)&quot;. Because they have recognized A:current and V:voltage as base units.
でも電圧の単位が「m**2*kg/(A*s**3)」と、また抵抗の単位が「m**2*kg/(A**2*s**3). So the practical unit system should be implemented as MKSAV unit system, not as MKSA unit system. PythonSf have implemented the unit system as MKSAV. You can calculte them as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
# resistance * current:R I == voltage：V
ts(); R,I=1.5Ω`, 2A`; R I
===============================
3.0*V`

# voltage / current:V/I == resistance：ohm: V/A
ts(); V,I=3.0V` , 2A`; V/I
===============================
1.5*V`/A`
</span>
</code>
</pre>
<p>
Do you agree with the claim of MKSAV unit system? Anyway the implementation of unit system is not worth if it is not implemented like as upper expressions.
<p>
However, please note that MKSAV unit system is redundant and you should convert the value by multiplying integer power of W` s`/J` by themselves. You should select mechanical, electro-magenetic, ampere, voltage units. Although it is bit bother, it is the unit system that most of engineers appreciate.
<p>
We show expressions in MKSAV unit system as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
# voltage * current:V I == wattage:W`: A V
ts(); V,I=3.0V` , 2A`; V I
===============================
6.0*A`*V`

# voltage * current:V I == works per a unit time:J`/s`
ts(); V,I=3.0V` , 2A`; V I J`/(W` s`)
===============================
6.0*m`**2*kg`/s`**3

# Force per a unit meter that works between electric wires which saparate 1m --- 1
ts(); u0` A`^2/(2pi m`)
===============================
1.99999999994284e-7*A`*s`*V`/m`**2

# Force per a unit meter that works between electric wires which saparate 1m --- 2
ts(); u0` A`^2/(2pi m`) J`/s`/W`
===============================
1.99999999994284e-7*kg`/s`**2

# Force that works between chages which saparate 1m --- 1
ts(); 1.0C`^2/(4pi e0` 1m`^2)
===============================
8987551789.01297*A`*s`*V`/m`
# Force that works between chages which saparate 1m --- 2
ts(); 1.0C`^2/(4pi e0` 1m`^2) J`/s`/W`
===============================
8987551789.01297*kg`*m`/s`**2

# Electric Field made by charges which separate 1m
ts(); 1.0C`/(4pi e0` 1m`^2)
===============================
8987551789.01297*V`/m`

# Electric Potential made by charges which separate 1m
ts(); 1.0C`/(4pi e0` 1m`)
===============================
8987551789.01297*V`

# Magnetic Flux:Φ made by a 1uH coil with 1A current
ts(); 1.0uH` 1A`
===============================
1.0e-6*s`*V`

# Fine Structure Constant 1
ts(); eQ`^2/(4pi ε0` h`` c`)
===============================
0.00729746834685501*A`*s`**3*V`/(kg`*m`**2)

# Fine Structure Constant 2
ts(); eQ`^2/(4pi ε0` h`` c`) J`/s`/W`
===============================
0.00729746834685501
</span>
</code>
</pre>
<p>
You can see same sexpression in sympy.physics.units:MKSA unit system as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
# voltage * current:V I == wattage
import sympy.physics.units as ut; 3.0 ut.V 2ut.A
===============================
6.0*kg*m**2/s**3

# Force per a unit meter that works between electric wires which saparate 1m
import sympy.physics.units as ut; ut.u0 1.0ut.A^2/(2pi ut.m)
===============================
6.36619772367581e-8*pi*kg/s**2

# Electric Field made by charges which separate 1m
ts(); import sympy.physics.units as ut; 1.0ut.C/(4pi ut.e0 1ut.m^2) 3.14159265359/ts.pi
===============================
8987551787.36877*kg*m/(A*s**3)

# Electric Potential made by charges which separate 1m
ts(); import sympy.physics.units as ut; 1.0ut.C^2/(4pi ut.e0 1ut.m^2) 3.14159265359/ts.pi
===============================
8987551787.36877*kg*m/s**2

# Magnetic Flux:Φ made by a 1uH coil with 1A current
import sympy.physics.units as ut; 1e-6 ut.H ut.A
===============================
1.0e-6*kg*m**2/(A*s**2)

# Fine Structure Constant
ts(); import sympy.physics.units as ut; eQ,h,c=1.6021892e-19 ut.A ut.s, 1.054571628e-34 ut.kg ut.m^2/ut.s, 299792458.0ut.m/ut.s; eQ^2/(4.0 pi ut.e0 h c) 3.14159265359/ts.pi
===============================
0.00729746834552000
</span>
</code>
</pre>
<p>
At Fine Structure Constant, SI:MKSA unit system is more convenient, But it is  not worth, because the units of electric field or potential are kg*m/(A*s**3) or kg*m/s**2. Engineers can't understand them, although they frequently deal with them.
<p>
But PythonSf:MKSAV unit system shows Electric Field/Potenial units with V`/m` ro V`. Engineers can use MKSAV unit system practically. They use MKSAV units.

<a name="■■ グラフ表示"></a>
<h2>■■ Showing Graphs</h2>
<p>
In python, there are paccages showing graphs such as pylab, mayavi. They are great ones that can draw high quality graphs that can be used in research papers.
<p>
But they are too bother to draw graphs. There are no needs of explanatory notes for graphs drawn for yourself, because you have known them. You might not need a scale of a horizontal axis. You needs ways to draw graphs with least pains, because you might want to see the graphs without a moment's delay. So PythonSf have implemented drawing functions: plotGr(..), plotTrajectory(..), plot3dGr(..), renderFaces(..), plotTmCh(..).
<h3>plotGr(..) drawing 2-dimensional graphs</h3>
We have implemented the plotGr(..) function to draw graphs with least pains at any hand. If you give only a function parameter to plotGr(.), it will draw a graph for the default interval:[0,1]. The graph was drawn by lines connected at default 50 points. 
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
plotGr(sin( 2pi `X^2)  )
</span>
</code>
</pre>
<br>
<img src="./jpg/1108/plotGrSinMXP2.jpg">
<p>
If you want a graph drawn on a interval:[-2,3] at 256 points data, you should set parameters to PlotGr(..) as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
plotGr(sin( 2pi `X^2), -2, 3, 256)
</span>
</code>
</pre>
<br>
<img src="./jpg/1108/plotGrSinMXP2_m2p3_s256.jpg">
<p>
You can draw a graph with sequence data such as tuple, list, array and others. Please note that the horizontal scale is len(sequnce date). But there is no problems because you look at the graph that is drawned by yourself withe the one-liner:&quot;plotGr([sin( 2pi `X^2)(t) for t in klsp(-2,2, 128)])&quot;, and you know the horizontal intarbal is [-2,2].
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
plotGr([sin( 2pi `X^2)(t) for t in klsp(-2,2, 128)])
</span>
</code>
</pre>
<br>
<img src="./jpg/1108/plotGrSinMXP2_m2p2_s128.jpg">
<h3>plotTrajectory(..) plotting trajectories</h3>
<p>
If you set plotTrajectory(..) a 2 dimensional position sequence data, it draws a 2 dimensional graph that connects the positions with lines as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
plotTrajectory([(0.9 cos(θ),sin(2θ)) for θ in arsq(0, 256,2pi/256)])
</span>
</code>
</pre>
<br>
<img src="./jpg/1108/plotTrjctryCosSin2.jpg">
<p>
If you set plotTrajectory(..) a 3 dimensional position sequence data, it draws a 3 dimensional graph.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
plotTrajectory([(0.9 cos(θ),sin(2θ), θ) for θ in arsq(0, 256,2pi/256)])
</span>
</code>
</pre>
<br>
<img src="./jpg/1108/plotTrjctryCosSin2θ.jpg">
<h3>plot3dGr(..) rendering 3d graphs</h3>
<p>
If you want to study a 3 dimensional shapes of 2 variables function:f(x,y), you should use plot3DGr(..).
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
plot3dGr(sin(`X) cos(`Y), [-pi,pi],[pi,-pi])
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliner_sin_cos.jpg">
<p>
plot3dGr(..) can render a 4 dimensional shape of a complex value function on complex plain. The shape consists of hight of the complex value and the phase which is rendered as mixed colors of red,green and blue.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
plot3dGr(sin(`X) cos(`X), [-pi,pi],[pi `i,-pi `i])
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliner_sin_cos_cmplx.jpg">
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
plot3dGr(log, [-pi,pi],[pi `i,-pi `i])
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliner_log_cmplx.jpg">
<br>
<h3>renderMtrx(..)/renderMtCplx(..) rendering 3d graphs of data in a matrix</h3>
<p>
You might often want to visualize a distribution in a rectangular arear. Because it is difficult to grasp tendencies just from a bunch of data. You can grasp the tendencies at a glance from 3d visualized graphs 
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
<br>
seed(0);vc=~[range(10)]; renderMtrx(vc^vc + 3 randn(10,10))
</span>
</code>
<br>
<img src="./jpg/1111/oneliner_render_mtrx_vc_vc.jpg">
<p>
You can render a distribution of complex values in a mtraix as a 3d graph where the phase rotations are drawn by mixing rate of RGB colors.
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
<br>
seed(0); vc=~[range(10)]; renderMtCplx(vc^vc+3(randn(10,10)+`i randn(10,10)))
</span>
</code>
<br>
<img src="./jpg/1111/oneliner_render_mtrx_vc_vc_cplx.jpg">
<br>
<br>
<br>

<h3>renderFaces(..)/renderFacesRGB(..) rendering 3 dimensional curved surface</h3>
<p>
You can render a 3 dimentional curved surface by setting renderFaces(.) a matrix parameter where the elements are 3 dimensional position vectors. We show a example below.
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
<br>
# Moebius strip<br>
dct={}; for idx, (u,v) in enmitr(klsp(0,2pi),klsp(-1,1,10)):dct[idx]=((1+0.5v cos(0.5u))cos(u), (1+0.5v cos(0.5u))sin(u), 0.5v sin(0.5u)); renderFaces(dct,blMesh = True)
</span>
</code>
<br>
<img src="./jpg/1111/oneliner_render_moebius_ring.jpg">
<p>
It is convinient to use a dictionary for a matrix where the elements are position vector as the upper example code. Because you don't neet to declare a matrix consistent with element's type. You don't need to think a matrix where elements are position vectors.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
# Klein bottle
//@@
dct,N,M,r={},64,32,5;
for (u,v), index in zip(masq([0,N,2pi/N], [-1,M+1,2pi/M]), mrng(N,M+1) ):
    dct[index]=( (r+cos(u/2) sin(v)-sin(u/2) sin(2v)) cos(u)
                ,(r+cos(u/2) sin(v)-sin(u/2) sin(2v)) sin(u)
                ,sin(u/2) sin(v) + cos(u/2) sin(2*v) )

sf.renderFaces(dct, blMesh = True)
sf.drawAxis()
//@@@
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliner_render_kleins_bottle.jpg">
<p>
You can render a 3 dimentional colored curved surface, if you set renderFacesWithRGG(.) a parameter dictionary matrix where elements are pairs of a position vector and a RGB color value. We show a example below.
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
# Spherical harmonics<br>
m,l=0,2;sy();clAt = ClCplxColor();psCl=λ θ,φ:(λ cplxAg=ss.sph_harm(m,l,φ,θ):(abs(cplxAg) ~[sin(θ)cos(φ),sin(θ)sin(φ),cos(θ)], clAt.GetFltColor(0.99 cplxAg/abs(cplxAg))))();dct={};for idx,(θ,φ) in enmitr(klsp(0,pi),klsp(0,2pi)):dct[idx]=psCl(θ,φ);renderFacesWithRGB(dct)
</span>
</code>
<br>
<img src="./jpg/1111/oneliner_render_harmonic.jpg">
<br>
<br>
<h3>render2dRGB rendering a kkRGB plane of a comple value distribution</h3>
<p>
We have implemented render2dRGB(..) that renders a complex value distribution in a matrix for a complex value function by a way named as kkRGB.
<p>
You shold set parameters as below np.info(render2dRGB). mtrAg is a complex value matrix. it buid up a rectangular jpg picture of which each pixels are corresponding to each complex value elements of the matrix.  The phase angles of the complex ue elements correspond to the mixing rate of RGB colors. And the absolute values of them correspond the brightness of the pixels. If you set a 100x100 matrix then it renders a small 100x100 pixcel picture.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
np.info(render2dRGB)
 render2dRGB(mtrxAg, boundary=1.0, limit=10.0, blReverse=False, blBoth=False,
             fileName='kkRGB', blDisplay=True, blMax=False)

' Render a complex value distribution with kkRGB color for matrix argument
        rendered figure is saved at kkRGB.jpg file as a default
    e.g.
vc=klsp(-3,3,300); f=`X^3+`X^2+`X+1; dct={};for idx,(x,y) in enmitr(vc,vc):dct[idx]=f(x+`i y); render2dRGB(dct)
    '
===============================
None
</span>
</code>
</pre>
<p>
Let render a complex value distribution of a polynomial:`X^3+`X^2+`X+1 by render2dRGB(..) function as below. (render2dRGB(..) function creates kkRGB.jpg file in the current directory using Python Image module and execute the jpg file with start command. In other words, the jpg file is shown by a default program that is associated to the extension name at Windows OS)
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
<br>
vc=klsp(-3,3,300); f=`X^3+`X^2+`X+1; dct={};for idx,(x,y) in enmitr(vc,vc):dct[idx]=f(x+`i y); render2dRGB(dct)
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_render_2d_rgb_xp3_xp2_x_1.jpg">
<p>
The centers of the three faded black dots in the upper view correspond to positions of complex roots in x^3+x^2+x+1 polynomial. Values of the function is 0 at the roots, so their brightness is 0. You can get the roots by below PythonSf expressions.
上の図で中央に分布している三つのぼやけた黒い丸い領域の中心が、多項式 x^3+x^2+x+1 の複素根の位置に対応しています。根の位置で関数値が 0 になるので、その明度も 0 になっています。(この多項式の根は、下の PythonSf 式で求められます。)
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liners</b>
poly1d([1,1,1,1],variable='x')
===============================
   3     2
1 x + 1 x + 1 x + 1

poly1d([1,1,1,1]).roots
===============================
[ -1.00000000e+00+0.j  -7.77156117e-16+1.j  -7.77156117e-16-1.j]
</span>
</code>
</pre>
<p>
The boundary between the four colored area and the center continuously colored center area is a place where absolute value of the function is 1 that are assigned by the default parameter:boundary=1.0.
<p>
The boundary between the white area and the four colored areas is a place where absolute value of the function is 10 that is assigned by the default parameter:limit=10.0. These four colors correspond four areas that are separated the real line and the imaginary line. So the boundaries between red areas and yellow areas are the part where values of the function are positive real numbers and the boundaries between yellow areas and green areas are the part where values of the function are positive imaginary numbers. You might be able to understand phase changes more easily by four colored areas than by vague continuous RGB rendering. For example, from the upper kkRGB graphic you can easily look that a contour and iso-phase lines of complex analytic function are orthogonal. (Complex analytic functions have this property generally.)
<p>
You can render a complex value distribution of a polynomial x^3+x^2+x+1 by plot3dGr(..) function in short as below. But you might be able to image the complex value distribution by render2dRGB(..) more easily.
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
<br>
plot3dGr(`X^3+`X^2+`X+1, [-3,3],[3`i,-3`i])
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_render_mt_cplx_xp3_xp2_x_1.jpg">
<br>
<p>
You can render a Mandelbrot set by render2dRGB(..) as below.
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf block</b>
<br>
//@@
N=512;
def check(c,z=0,k=0):
    return k>500 and 500 or abs(z) < 2 and check(c,z^2+c,k+1) or k;

dct={};
for idx,(x,y) in enmasq((-2,N,4/N),(2`i,N,-4`i/N)):
    dct[idx]=check(x+y);

def convertTo4cplxVl(inAg):
    return inAg==500 and 0.1+0j or inAg>30 and 1+0j  or inAg>10 and 1j or inAg>5 and -1+0j or -1j

for idx in mrng(N,N):
    dct[idx]=convertTo4cplxVl(dct[idx]);

render2dRGB(dct)
//@@@

</span>
</code>
</pre>
<img src="./jpg/1111/oneliners_render_2d_mandelbrot.jpg">
<br>
<h3>plotTmCh(..):plotting a time chart</h3>
<p>
You can plot time charts of row data in a matrix by setting plotTmCh(..) the matrix parameter. Let plot a time chart of actions of the below 1 bit D/A converter.
<pre>
<code>
ΔΣ DA converter                   in >= 2**15 --> 1
                                    in <  2**15 --> 0
   16  +┌───┐  +   ┌──┐    ┌────────┐    1           
→─／─┤Adder ├─→○┤z^-1├┬─┤Digtal      1bit├┬─／───／＼／＼／＼／─┬────
    ┌─┤      │   -↑└──┘│  │Comparator  D/A ││                          │
    │ -└───┘    └────┘  └────────┘│                        ─┴─
    │                  integrator                      │                        ─┬─ C/s
    └─────────────────────────┘                          │
                                                                                    ┴  
             Δ            Σ                                                        =
 A:入力                  B:intergrator:countor             C:output: 1 or -1
</code>
</pre>
<p>
The below PythonSf one-liner plots variations over time at A,B,C points in the uuper 1bit D/A convertoer on a time-chart after calculating them.
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf one-liner</b>
<br>
N=256;f=λ sg,ds,out:(λ dsAg=ds+sg-out*2^15:[sg,dsAg,1 if dsAg>0 else -1])();mt=kzrs(3,N); mt[:,0]=(0,0,0);for i in range(N-1):mt[:,i+1]=f(2^15 sin(2pi i/N),*mt[:,i][1:]);plotTmCh(mt)
</span>
</code>
<br>
<img src="./jpg/1111/oneliner_plottmch_1bit_da.jpg">
<h3>Implementing graph functions by users</h3>
<p>
It is easy to implement graph functions by users. Because there are graphic packages like as pylab in Python.
PythonSf でのグラフ表示関数はユーザー側でも簡単に実装可能です。pylab のようなグラフ表示パッケージがあるのですから。上に述べたグラフ表示関数も全てソースを公開しています。下のワンライナーで、plotTmCh(..) 関数のソースを見れます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.source(plotTmCh)
In file: pysf\vsGraph.py

def plotTmCh(vctMtrxAg):
    """' plot time chart for vector,array or matrix dictionary data
    '"""
    import pylab as pb
    def __plotTmChX(vctMtrxAg):
        n = len(vctMtrxAg)
        lstYAt = [None]*(2*n)
        lstYAt[0::2] = vctMtrxAg
        lstYAt[1::2] = vctMtrxAg
        lstYAt = [vctMtrxAg[0]]+lstYAt+[vctMtrxAg[-1]]

        lstXAt = [None]*(2*(n+1))
        lstXAt[0::2] = range(n+1)
        lstXAt[1::2] = range(n+1)

        maxAt = max(vctMtrxAg)
        minAt = min(vctMtrxAg)
        pb.plot(lstXAt, lstYAt)

        if maxAt != minAt:
            lstAxisAt = list(pb.axis())
            meanAt = float(maxAt + minAt)/2
            lstAxisAt[2] = minAt + (minAt - meanAt)*0.2 # set Y axis min
            lstAxisAt[3] = maxAt + (maxAt - meanAt)*0.2 # set Y axis max
            pb.axis(lstAxisAt)

    assert '__getitem__' in dir(vctMtrxAg)
    if isinstance(vctMtrxAg, dict) or '__len__' in dir(vctMtrxAg[0]):
        if isinstance(vctMtrxAg, list):
            assert not('__getitem__' in dir(vctMtrxAg[0][0]))
            colSizeAt = len(vctMtrxAg)
        elif isinstance(vctMtrxAg, dict):
            lstAt = vctMtrxAg.keys()
            lstAt.sort()
            shapeAt = lstAt[-1]
            shapeAt = (shapeAt[0]+1, shapeAt[1]+1)
            assert shapeAt[0]*shapeAt[1] == len(lstAt),\
                "dictionary vctMtrxAg index is not alined" + str(objarAg)

            krAt = kzrs(shapeAt)
            for index in sf.mrng(*shapeAt):
                krAt[index] = vctMtrxAg[index]

            vctMtrxAg = krAt
            colSizeAt = shapeAt[0]
        else:
            assert isinstance(vctMtrxAg, sf.sc.ndarray)
            assert len( vctMtrxAg.shape ) == 2

            colSizeAt = vctMtrxAg.shape[0]

        for i, elmAt in enumerate(vctMtrxAg):
            # don't use subplot(,,0) not to shift upper
            pb.subplot(colSizeAt, 1, i+1) 
            __plotTmChX(elmAt)
    else:
        __plotTmChX(vctMtrxAg)

    pb.show()

===============================
None

</span>
</code>
</pre>
<p>
グラフ表示関数の実装なんて大変だと思われるかもしれません。でも VPython または Matplotlib パッケージを使っているので、PythonSf のグラフ表示関数は数十行で記述できてしまうものばかりです。これらは全てソースまで公開しています。上の np.source(..) により PythonSf ワン･ライナーでソースを見ることも可能です。必要なグラフ表示機能はユーザーによって異なります。ぜひともユーザー側でのグラフ表示関数の実装にも挑戦してみてください。それらができたら customize.py または sfCrrntIn.py ファイルに書いてやるだけで、PythonSf 式として利用できるようになります。
<a name="■■ 積分:quadR(..), quadC(..), quadAn(..)"></a>
<h2>■■ 積分:quadR(..), quadC(..), quadAn(..)</h2>
<p>
Python の数値積分では scipy.integrate.quad が有名です。でも、この quad(..) 関数は、積分値と、その推測誤差の tuple pair を返してくれます。計算誤差まで返してくれるのは、一見良さそうですが、グラフを描かせたりするときは積分値のみを取り出す必要があり、ワンライナーで短く書くには返って不都合です。
<p>
また複素数値関数や調和関数の積分も行えるようにしたいので、PythonSf では計算誤差を返さない、積分値のみを返す quadR, quadC, quadAn 関数を用意しています。
<h3>quadR </h3>
<p>
quadR(実数値関数, 下限、上限) と引数を与えることで数値積分を計算します。下限・上限値には無限大：sy.inf を指定することも可能です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# pi 
#∫ sin(x) dx == 2
# 0
quadR(sin, 0,pi)
===============================
2.0

# scipy.integrate quad による積分
sy(); si.quad(sin, 0,pi)
===============================
(2.0, 2.220446049250313e-14)

# ∞ 範囲の積分
# ∞
#∫ exp(-x^2) dx == π^0.5
#-∞
# SciPy の quad(..) であり計算誤差の推定値も含めた計算結果を返す
sy();si.quad(exp(-`X^2), -sy.inf, sy.inf)
===============================
(1.7724538509055159, 1.4202636756658795e-08)

# PythonSf の quadR(..) であり積分値の計算結果のみを返す。誤差は返さない。
quadR(exp(-`X^2), -np.inf, np.inf)
===============================
1.77245385091

# 参考 π^0.5
sqrt(pi)
===============================
1.77245385091

print '%1.20f'%sqrt(pi)
1.77245385090551590000
-------------------------------
None
</span>
</code>
</pre>

<h3>quadC </h3>
<p>
quadC(複素数値関数, 下限、上限) と引数を与えることで、複素数値関数の数値積分を計算します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# Fourier Transform function value
~[quadC(exp(2pi `i ν `X) exp(-`X^2), -np.inf, np.inf) for ν in arsq(0,5,1/5)]
===============================
[ 1.77245385+0.j  1.19432452+0.j  0.36539667+0.j  0.05075766+0.j
  0.00320135+0.j]
---- ClTensor ----

# Fourier Transform function of exp(-X^2)
F_f=λ f:( quadC(exp(-2pi `i ν `X) exp(-X^2),-np.inf, np.inf) ).real
Waring: don't use assignment at last sentence.We ignore the assignment.
===============================
<function <lambda> at 0x0213A070>
not picklable

F_f=λ f:( quadC(exp(-2pi `i f `X) exp(-`X^2),-np.inf, np.inf) ).real;F_f(3)
===============================
1.32810429321e-13

# フーリエ変換された関数の実数値分布のグラフ表示
F_f=λ f:( quadC(exp(-2pi `i f `X) exp(-`X^2),-np.inf, np.inf) ).real; plotGr(F_f,-2,2)
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/quad_c_exp.jpg">

<h3>quadAn </h3>
<p>
quadAn(.)に、quadAn(複素領域を定義域とする関数, [複素数値のリスト]) 被積分関数と直線で結んだ積分経路を与えることで、その積分経路に沿った積分値を計算します。下に例を示します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
quadAn(log, [1,`i,-1,-`i,1])
===============================
((-1.1102230246251565e-16-6.283185307179586j), 3.238303350943406e-09, 3.238303350943406e-09)

quadAn(log, [1,`i,-1,-`i,1])[0] ~== (-2 pi `i)
===============================
True
</span>
</code>
</pre>
<p>
quadAn(..) のときは、予測される積分計算誤差も実数部、虚数部ともに返しています。
<br>
<br>
<a name="kOde:常微分方程式"></a>
<h3>kOde:常微分方程式</h3>
<p>
SciPy の integrate パッケージには ode(..) 関数が備わっています。でも時不変な系についても t を明示的に記述せねばならないなど使い方が少しばかり面倒です。ワン･ライナーでは ode(..) を使えません。
<p>
そこで kOde(..) 関数を作りました。大部分の場合で kOde(..) の方が使いやすいでしょう。下のように使います。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.info(kOde)

 kOde(f, x0, t, N=50)

' time independent Runge Kutta integral by scipy.integrate.ode.

kOde(f, x0, t, N=50)
  f:a dynamic equation that may return a vector or list
  x0: a initial codition value that may be a scalar,vector or list
  t: integrating time [0,t]
  N: returning data size

  f doesn't include t term unlike scpy.integrate.ode(..)

  e.g.

  kOde(~[-2 `X `Y, -`X], [1,2], 2s`,10)
  ===============================
  [[  4.63620997e-01   1.86108060e+00]
   [  2.23487176e-01   1.79540724e+00]
   [  1.09764092e-01   1.76345232e+00]
   [  5.44058566e-02   1.74768585e+00]
   [  2.70894588e-02   1.73985328e+00]
   [  1.35187020e-02   1.73594893e+00]
   [  6.75396145e-03   1.73399941e+00]
   [  3.37618618e-03   1.73302515e+00]
   [  1.68817038e-03   1.73253807e+00]
   [  8.44242482e-04   1.73229450e+00]]
  ---- ClTensor ----

        snipped
</span>
</code>
</pre>
<p>
上の式で ~[-2 `X `Y, -`X] は下の常微分方程式を意味します。
<pre>
  d  | x |  == |  -2 x y |  
 ---(|   |)    |         |
  dt | y |     |  -x     | 
</pre>
<p>
 `X, `Y は加減乗除べき乗算が可能な恒等関数であり、~[-2,`X `Y, -`X] はベクトル関数です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
~[-2 `X `Y, -`X](2,3)
===============================
[-12.  -2.]
---- ClTensor ----
</span>
</code>
</pre>
 <p>
 kOde(..) を使えば、二次元での N 体問題を解くワンライナーを次のように記述できます。D=2 が二次元を意味しています。inV=[....] に設定する初期位置・速度パラメータの数より、粒子数 N が決まります。
<p>
getFV(v,i,k) 関数は、位置・速度パラメータ群ベクトル v に対して、 i 番目と k 番目の粒子の間に働く力を求める関数です。(λ r=krry(v[D k:D (k+1)])-krry(v[D i:D (i+1)]):r/norm(r)^3 if norm(r)!=0 else ~[0,0])() は closure 関数の記述と呼び出しです。i 番目と k 番目の粒子の間の距離 r を定める let 文の役割をデフォルト引数機能使って実装しています。λ 式中では assign 文を使えないので、このようなテクニックを使います。
<p>
sumFc(v,j) は、位置・速度パラメータ群ベクトル v に対して、j 番目の粒子に働く力を、 getFV(v,j,k) を足し合わせることで求めています。
<p>
粒子数 N 個によって変わる軌跡の色を設定するために、複素数の位相による色指定法：ClCplxColor() を使っています。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
D=2;inV=[-0.97m`,0.243, 0.97,-0.243, 0,0, 1,1,  -0.466m`/s`,-0.432, -0.466,-0.432, 0.932,0.864, 0,0]; N=len(inV)//(2D) ; getFV=λ v,i,k:(λ r=krry(v[D k:D (k+1)])-krry(v[D i:D (i+1)]):r/norm(r)^3 if norm(r)!=0 else ~[0,0])(); sumFc=λ v,j:sum([getFV(v,j,k) for k in range(N) if j!=k]); fnc= λ *v: np.r_[v[D N:],(~[sumFc(v,j) for j in range(N)]).r]; mt=kOde(fnc,inV, 2 s`,400); cl=ClCplxColor(); for k in range(N):plotTrajectory(mt[:,D k:D (k+1)],color=cl.GetFltColor(exp(`i 2pi k/N)))

</span>
</code>
<br>
<img src="./jpg/1111/one_liner_n_bodey_2d.jpg">
<p>
三次元での N 体問題を解くワンライナーは下の様に書けます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
D=3;inV=[-0.97m`,0.243,0, 0.97,-0.243,0, 0,0,1, 1,1,1,  -0.466m`/s`,-0.432,0, -0.466,-0.432,0, 0.932,0.864,0, 0,0,0]; N=len(inV)//(2D) ; getFV=λ v,i,k:(λ r=krry(v[D k:D (k+1)])-krry(v[D i:D (i+1)]):r/norm(r)^3 if norm(r)!=0 else ~[0,0])(); sumFc=λ v,j:sum([getFV(v,j,k) for k in range(N) if j!=k]); fnc= λ *v: np.r_[v[D N:],(~[sumFc(v,j) for j in range(N)]).r]; mt=kOde(fnc,inV, 2 s`,400); cl=ClCplxColor(); for k in range(N):plotTrajectory(mt[:,D k:D (k+1)],color=cl.GetFltColor(exp(`i 2pi k/N)))

</span>
</code>
<br>
<img src="./jpg/1111/one_liner_n_bodey_3d.jpg">
<br>
<br>
<a name="■■ 行列演算 2"></a>
<h2>■■ 行列演算 2</h2>
<p>
Python Sf における、少し高度な行列演算について説明します。
<h3>~[ リスト内包表記 ] によるベクトル・行列生成</h3>
~[...] による行列生成はリスト内包表記にも使えます。生成される要素が int, float, complex のときは ClTensor インスタンスを、それ以外のときは ClFldTns インスタンスを生成します。ClFldTns により、行列・ベクトル演算要素を環にまで広げられます。下のようなぐあいです。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# ~[ リスト内包表記 ] によるベクトル
~[k^2 for k in range(5)]
===============================
[  0.   1.   4.   9.  16.]
---- ClTensor ----

# ~[ リスト内包表記 ] による行列生成
~[[k j for k in range(5)] for j in range(4)]
===============================
[[  0.   0.   0.   0.   0.]
 [  0.   1.   2.   3.   4.]
 [  0.   2.   4.   6.   8.]
 [  0.   3.   6.   9.  12.]]
---- ClTensor ----

# ~[ リスト内包表記 ] による Zp(5) 要素の行列生成
~[[Z5(k j) for k in range(5)] for j in range(4)]
===============================
[[Z5(0) Z5(0) Z5(0) Z5(0) Z5(0)]
 [Z5(0) Z5(1) Z5(2) Z5(3) Z5(4)]
 [Z5(0) Z5(2) Z5(4) Z5(1) Z5(3)]
 [Z5(0) Z5(3) Z5(1) Z5(4) Z5(2)]]
---- ClFldTns:< class 'sfCrrntIni.Z5'> ----

# ~[ リスト内包表記 ] によって生成された、Zp(5) 要素の行列によるベクトルの変換
~[[Z5(k j) for k in range(5)] for j in range(4)] range(3,3+5)
mt=~[[Z5(k j) for k in range(5)] for j in range(4)]; mt range(3,3+5)
===============================
[Z5(0) Z5(0) Z5(0) Z5(0)]
---- ClFldTns:< class 'sfCrrntIni.Z5'> ----

mt=~[[Z5(k j) for k in range(5)] for j in range(4)]; mt range(2,2+5)
===============================
[Z5(0) Z5(0) Z5(0) Z5(0)]
---- ClFldTns:< class 'sfCrrntIni.Z5'> ----
</span>
</code>
</pre>
<h3>テンソル</h3>
<p>
N x M 行列を越えて、N x M x L などの多次元のテンソルも扱えます。それらとベクトルとの積演算も可能です。次のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
ls=range(3); ~[ [[x+y+z for x in ls] for y in ls] for z in ls]
===============================
[[[ 0.  1.  2.]
  [ 1.  2.  3.]
  [ 2.  3.  4.]]

 [[ 1.  2.  3.]
  [ 2.  3.  4.]
  [ 3.  4.  5.]]

 [[ 2.  3.  4.]
  [ 3.  4.  5.]
  [ 4.  5.  6.]]]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
# 3x3x3Tensor * 3Vector
ls=range(3); tns=~[ [[x+y+z for x in ls] for y in ls] for z in ls]; tns ls
===============================
[[  5.   8.  11.]
 [  8.  11.  14.]
 [ 11.  14.  17.]]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
# 3Vector * 3x3x3Tensor * 3Vector
ls=range(3); tns=~[ [[x+y+z for x in ls] for y in ls] for z in ls]; ls tns ls
===============================
[ 30.  39.  48.]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
# テンソルどうしの積：Γ`__[j,k,i]  Γ`__[i,p,q]
ls=range(3); Γ`__=~[ [[x+y+z for x in ls] for y in ls] for z in ls]; Γ`__ Γ`__
===============================
[[[[  5.   8.  11.]
   [  8.  11.  14.]
   [ 11.  14.  17.]]

  [[  8.  14.  20.]
   [ 14.  20.  26.]
   [ 20.  26.  32.]]

  [[ 11.  20.  29.]
   [ 20.  29.  38.]
   [ 29.  38.  47.]]]


 [[[  8.  14.  20.]
   [ 14.  20.  26.]
   [ 20.  26.  32.]]

  [[ 11.  20.  29.]
   [ 20.  29.  38.]
   [ 29.  38.  47.]]

  [[ 14.  26.  38.]
   [ 26.  38.  50.]
   [ 38.  50.  62.]]]


 [[[ 11.  20.  29.]
   [ 20.  29.  38.]
   [ 29.  38.  47.]]

  [[ 14.  26.  38.]
   [ 26.  38.  50.]
   [ 38.  50.  62.]]

  [[ 17.  32.  47.]
   [ 32.  47.  62.]
   [ 47.  62.  77.]]]]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
# Einstein 既約による縮約：Γ`__[j,k,k]  Γ`__[m,k,k]
ls=range(3); Γ`__=~[ [[x+y+z for x in ls] for y in ls] for z in ls]; ~[ [sum([Γ`__[j,k,k] Γ`__[m,k,k] for k in ls]) for j in ls] for m in ls]
===============================
[[ 20.  26.  32.]
 [ 26.  35.  44.]
 [ 32.  44.  56.]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
テンソル演算は手計算では大変すぎて簡単には扱えませんでした。でも PythonSf を使えば、上のようにテンソル演算も簡単であり実用的に使えます。
<h3>ベクトル・行列同士の ^ 演算子とベクトル外積</h3>
<p>
スカラー値への ^ 演算子の適用はべき乗演算子の意味でしたが、ベクトルや行列の組への ^ 演算子の適用はダイアディック・ベクトル積などのテンソル演算の意味にしています。下のような具合です。
<pre>
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
~[1,2,3]^[4,5,6]
===============================
[[  4.   5.   6.]
 [  8.  10.  12.]
 [ 12.  15.  18.]]
---- ClTensor ----

~[1,2,3]^~[4,5,6]^~[7,8,9]
===============================
[[[  28.   32.   36.]
  [  35.   40.   45.]
  [  42.   48.   54.]]

 [[  56.   64.   72.]
  [  70.   80.   90.]
  [  84.   96.  108.]]

 [[  84.   96.  108.]
  [ 105.  120.  135.]
  [ 126.  144.  162.]]]
---- ClTensor ----

`σx ^ `σz
===============================
[[[[ 0.  0.]
   [ 0. -0.]]

  [[ 1.  0.]
   [ 0. -1.]]]


 [[[ 1.  0.]
   [ 0. -1.]]

  [[ 0.  0.]
   [ 0. -0.]]]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
ベクトルの外積演算は Levi-Civita tensor とベクトルとの積によって計算できます。その他にも複数の方法が使えます。
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# Levi-Civita tensor `εL とベクトルとの積演算による外積
a,b=~[1,2,3],~[4,5,6]; -a `εL b
===============================
[-3.  6. -3.]
---- ClTensor ----

# Numpy cross 関数による外積
np.cross([1,2,3],[4,5,6])
===============================
[-3  6 -3]

# ^ 演算子による外積
a,b=~[1,2,3],~[4,5,6]; a^b - b^a
===============================
[[ 0. -3. -6.]
 [ 3.  0. -3.]
 [ 6.  3.  0.]]
---- ClTensor ----

# Wedge 積関数 `Λ(..) による外積
a,b=~[1,2,3],~[4,5,6]; `Λ(a,b)
===============================
[[ 0. -3. -6.]
 [ 3.  0. -3.]
 [ 6.  3.  0.]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
三次元だけで使うときは np.cross(..) が良いのかもしれません。
<p>
私自身は a^b-b^a や `Λ(a,b) による外積演算が優れていると思います。任意の N 次元ベクトルにも使えるからです。計算結果をベクトルではなくテンソルにしておいたほうが、外積の数学的・物理学的な意味が明確になるからです。このときは三次元ベクトルどうしの外積が 3x3 反対称行列になってしまいますが、こちらの方が本来の数学的・物理学的な意味を表しています。
<p>
とくに外積の拡張としての Wedge 積関数:`Λ(..) が微分形式に慣れた方に便利だと思います。任意個数、任意次元のベクトルについて Wedge 積を計算できます。ただし行列を引数としたときまでは実装してありません。誤った計算値になります。御注意ください。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
a,b=[1,2,3,4],[5,6,7,8]; `Λ(a,b)
===============================
[[  0.  -4.  -8. -12.]
 [  4.   0.  -4.  -8.]
 [  8.   4.   0.  -4.]
 [ 12.   8.   4.   0.]]
---- ClTensor ----

a,b,c=[1,2,3,4],[5,6,7,8],[9,10,11,12]; `Λ(a,b,c)
===============================
[[[ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]]

 [[ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]]

 [[ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]]

 [[ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]]]
---- ClTensor ----

# 四次元 Zp(3) ベクトルの外積
a,b=~[1,2,3,4,Z3],~[5,6,7,8,Z3]; `Λ(a,b)
===============================
[[Z3(0) Z3(2) Z3(1) Z3(0)]
 [Z3(1) Z3(0) Z3(2) Z3(1)]
 [Z3(2) Z3(1) Z3(0) Z3(2)]
 [Z3(0) Z3(2) Z3(1) Z3(0)]]
---- ClTensor ----

# 下の Pauli 行列の Wedge 積の計算値は誤りです。行列引数はサポートしていません。
`Λ(`σx,`σz)
===============================
[[[[ 0. -1.]
   [-1.  0.]]

  [[ 1.  0.]
   [ 0. -1.]]]


 [[[ 1.  0.]
   [ 0. -1.]]

  [[ 0.  1.]
   [ 1.  0.]]]]
---- ClTensor ----
</span>
</code>
</pre>

<h3>ベクトル分布関数</h3>
<p>
PythonSf の基本関数は加減乗除べき乗算と関数合成が可能です。このような関数を要素とする ClFldTns ベクトルは __call__(..) method を備えており、ベクトル分布関数として扱えます。そのベクトル分布関数は数値微分できます。grad,div,rot を計算できます。次のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>

# ベクトル分布関数
f=~[`X^2 + `Y^2, `X `Y,`Z `X]; f(1,2,3)
===============================
[ 5.  2.  3.]
---- ClTensor ----

# ベクトル分布関数の数値微分インスタンスの (1,2,3) 位置におけるあたい
f=~[`X^2 + `Y^2, `X `Y,`Z `X]; `div(f)(1,2,3)
===============================
4.0

# 3 変数関数の (1,2,3) における grad 数値微分
`grad(λ x,y,z:x^2+y^2+z^2)(1,2,3)
===============================
[ 2.  4.  6.]

# `div(f) が三変数関数であることは分からないので、dim=3 と明示的に指定する。
# λ x,y,z:... ならば三変数引数だと分かるのですが ~[`X ... `Z] 関数では、引数の数が PythonSf には分かりません。
f=~[`X^2 + `Y^2, `X `Y,`Z `X]; `grad(`div(f),dim=3)(1,2,3)
===============================
[  4.00000000e+00  -1.11022302e-08   0.00000000e+00]
---- ClTensor ----

# rotation
f=~[`X^2 + `Y^2, `X `Y,`Z `X]; `rot(f)(1,2,3)
===============================
[[ 0.  2. -3.]
 [-2.  0.  0.]
 [ 3.  0.  0.]]
---- ClTensor ----

# Jacobian
f=~[`X^2 + `Y^2, `X `Y,`Z `X]; ∂J(f)(1,2,3)
===============================
[[ 2.  4.  0.]
 [ 2.  1.  0.]
 [ 3.  0.  1.]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
rot(..) 関数の結果がベクトルではなく反対称テンソルであることに違和感を抱く方がいるかもしれません。でも敢えて反対称テンソルを返しています。テンソルを返すのならば、二次元や、四次元でも、一般の N 次元でも rot(..) の結果を返せるからです。また反対称テンソルにすることで、rot(..) の数学的・物理的意味が明確になるとも思います。

<h3>ClTensor と nd.array, sequence の組み合わせ演算</h3>
<p>
Two temp four operations between a numpy.ndarray instance and a ClTensor instance result in a ClTensor instance.
np.ndarray と ClTensor の加減乗除算は ClTensor インスタンスになります。np.ndarray インスタンスと ClTensor インスタンスを組み合わせた四則演算は ClTensor 側に落ち着くように PythonSf は作られています。られています
<h3>ufunc</h3>
<p>
とくに SciPy の 非 ufunc:universal function の行列やベクトルを扱う関数のときに注意が必要です。ClTensor インスタンスを引数として与えても、np.ndarray インスタンスが返ってきてしまうからです。それが嫌で fft バッファ関数を設けたりしています。ufunc ならば ClTensor インスタンスを引数にすれば、ClTensor 値が帰ってくるのですが、SciPy の全ての関数が ufunc に統一されてはいません。
<pre>
<code>
<span style="color: #9f009f;">
整数／実数／複素数 PythonSf 行列／ベクトル式
===============================
値文字列
---- ClTensor ----


非整数・非実数・非複素数 PythonSf 行列／ベクトル式
===============================
値文字列
---- ClFldTns:< class 'pysf.octn.BF'> ----
</span>
</code>
</pre>
<!--
# ベクトルの連結
np.r_[~[1,2,3],~[4,5,6,7]]
===============================
[ 1.  2.  3.  4.  5.  6.  7.]
<== universal function ではない。np.ndarray インスタンスになっている
list(~[1,2,3])+list(~[4,5,6,7])
===============================
[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0]
<== こっちは、式の値はリスト・インスタンス
dict(`σx)
===============================
{0.0: 1.0, 1.0: 0.0}
ravel()
`σx.r
===============================
[ 0.  1.  1.  0.]
---- ClTensor ----
Levi-Civita テンソル
    wedge 積:`Λ
grad ∇
rot
`rot(~[`X^2 + `Y^2, `X `Y])(1,2)
`rot(~[`X^2 + `Y^2, `X `Y,`Z `X])(1,2,3)
`rot(~[`X^2 + `Y^2, `X `Y,`Z `X, `i `T])(1,2,3,4)
`rot(~[`X^2 + `Y^2, `X `Y,`Z `X, `i `T `X])(1,2,3,4)
`div(~[`X^2 + `Y^2, `X `Y,`Z `X, `i `T `X])(1,2,3,4)
    反対称テンソル値を返す

テンソル演算
seed(0);tns=randint(10,size=(3,3,3)
<h3>quadGN, quadN, quadVctN </h3>
sinm/cosm
expm
['eigvalsh', 'eigvals', 'eig', 'eigh']

<br>
-->
<a name="■■ 代数系"></a>
<h2>■■ 代数系</h2>
<p>
PythonSf は八元数、整数の剰余体：Zp(N), GF(2^8), 置換群：Sn(N) といった代数系も扱えます。一般体の係数からなる多項式も扱えます。その多項式の加減乗除算、整数べき乗算、剰余算も可能です。また ClFldTns クラスは一般の体や環の行列・ベクトル演算も扱えます。これぐらいあれば学部程度（数学課を除く）の代数には十分だと思います。以下これらを見ていきましょう。
<p>
これらの代数系のソースは全て公開してあります。興味の有る方はそちらも追ってみてください。できたら御自分に必要な代数系に修正・拡張してみてください。全て Python で書かれている小さなプログラムたちですから簡単です。
<h3>整数剰余体：Zp(N)</h3>
<p>
素数 p の剰余体:Zp は、整数を素数:p の剰余演算により range(p-1)：[0,1, ... ,p-1] の整数に mapping したときに得られる体です。体ですから加減乗除算が可能です。<!--PythonSf には octn.py モジュール(oc の global name で import 済みです。) に Zp(.) class factory 関数が実装してあり整数剰余体の演算が可能です。-->素数 5 に対して %p 演算は下のような性質を持ちます。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# 和演算における 3 の逆元
p=5; -3%p
===============================
2

# 整数 0,1, ... , 9 を素数 5 の剰余体に mapping します
p=5; [ x%p for x in range(10)]
===============================
[0, 1, 2, 3, 4, 0, 1, 2, 3, 4]

# 整数 0,1, ... , 9 を素数 5 の剰余体の「和の逆元」に mapping します
p=5; [ (-x)%p for x in range(10)]
===============================
[0, 4, 3, 2, 1, 0, 4, 3, 2, 1]

# 整数 0,1, ... , 9 を素数 5 の剰余体の「積の逆元」に mapping します
p=5; [ (x^(p-2))%p for x in range(10)]
===============================
[0, 1, 3, 2, 4, 0, 1, 3, 2, 4]

# %p が和に対して一貫性があることを確認する
N=10; seed(0); p=5; [ (x%p+y%p)%p==(x+y)%p for x,y in randint(-99,99, size=[N,2])]
===============================
[True, True, True, True, True, True, True, True, True, True]

# %p が積に対して一貫性があることを確認する
N=10; seed(0); p=5; [ ((x%p)*(y%p))%p==(x*y)%p for x,y in randint(-99,99, size=[N,2])]
===============================
[True, True, True, True, True, True, True, True, True, True]
</span>
</code>
</pre>
<p>
標準配布の sfCrnntIni.py には Z2,Z3,Z4,Z5,Z7 の剰余体／環が定義してあります。上の演算を下のように Z5 で書き直せます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# 和演算における 3 の逆元
-Z5(3)
===============================
Z5(2)

# 整数 0,1, ... , 9 を素数 5 の剰余体に mapping します
[ Z5(x) for x in range(10)]
===============================
[0, 1, 2, 3, 4, 0, 1, 2, 3, 4]

# 整数 0,1, ... , 9 を素数 5 の剰余体の「和の逆元」に mapping します
[-Z5(x) for x in range(10)]
===============================
[0, 4, 3, 2, 1, 0, 4, 3, 2, 1]

# 整数 0,1, ... , 9 を素数 5 の剰余体の「積の逆元」に mapping します
p=5; [ Z5(x)^(p-2) for x in range(10)]
===============================
[0, 1, 3, 2, 4, 0, 1, 3, 2, 4]

# %p が和に対して一貫性があることを確認する
N=10; seed(0); [ Z5(x)+Z5(y)==Z5(x+y) for x,y in randint(-99,99, size=[N,2])]
===============================
[True, True, True, True, True, True, True, True, True, True]

# %p が積に対して一貫性があることを確認する
N=10; seed(0); [ Z5(x)*Z5(y)==Z5(x*y) for x,y in randint(-99,99, size=[N,2])]
===============================
[True, True, True, True, True, True, True, True, True, True]
</span>
</code>
</pre>
<p>
Zp(N) は体であり、加減乗除算に関連した多くの代数式が実数のときと同じように成り立ちます。例えば 1/a + 1/b == (a+b)/(a b) の等式が 0 ではない任意の Z5 要素についてなりたちます。下の PythonSf 式で実験確認できます。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
a,b=Z5(2),Z5(3); 1/a + 1/b == (a+b)/(a b)
===============================
True

<b>PythonSf ワンライナー</b>
N=10; seed(0); [ 1/a + 1/b == (a+b)/(a b) for a,b     in ~[randint(1,5, size=[N,2]), Z5] ]
===============================
[True, True, True, True, True, True, True, True, True, True]
</span>
</code>
</pre>
<p>
Zp(N) は可換体であり、行列演算についても実数のときと同様な代数式が多く成り立ちます。下のように 2x2 行列の逆行列の公式が Z5 でも成り立っていることを実験確認できます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
N=1 ; seed(0); [ 1/~[[a,b],[c,d]] == ~[[d,-b],[-c,a]]/(a d - b c) for a,b,c,d in ~[randint(1,5, size=[N,4]), Z5] ]
===============================
[ClTensor([[ True,  True],
       [ True,  True]], dtype=bool)]

<b>PythonSf ワンライナー</b>
N=4 ; seed(0); [ 1/~[[a,b],[c,d]] == ~[[d,-b],[-c,a]]/(a d - b c) for a,b,c,d in ~[randint(1,5, size=[N,4]), Z5] if a d - b c != 0]
===============================
[ClTensor([[ True,  True],
       [ True,  True]], dtype=bool), ClTensor([[ True,  True],
       [ True,  True]], dtype=bool), ClTensor([[ True,  True],
       [ True,  True]], dtype=bool)]
</span>
</code>
</pre>
<p>
Zp(N) は要素が有限なので、虱潰しに全部を調べてやることで、上の関係がなりたつことを証明することも可能です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
vc=~[0,1,2,3,4,Z5]; [ 1/~[[a,b],[c,d]] == ~[[d,-b],[-c,a]]/(a d - b c) for a,b,c,d in mitr(vc,vc,vc,vc) if a d - b c != 0]
===============================
[ClTensor([[ True,  True],

    snip

       [ True,  True]], dtype=bool), ClTensor([[ True,  True],
       [ True,  True]], dtype=bool)]
</span>
</code>
</pre>
<h3>四元数・八元数</h3>
<p>
PythonSf は八元数を扱えます。八元数クラス ClOctonion は octn.py モジュールで定義してあるのですが、標準配布の sfCrrntIni.py ファイルによりグローバル変数 Oc に assign し直してあり、 Oc(...) だけで八元数を生成できます。
<p>
八元数は複素数、四元数を含んでいます。この複素数、四元数は加減乗除算に対して閉じています。ですので、Oc(...) の引数に二つの要素だけを指定したときは複素数のような二要素表記になり、上位の六個の 0 要素は八元数値の表記であってもマスクされます。同様に四つの要素で八元数を生成したときは、四要素表記にしてあります。具体的には次のような生成・演算・表記となります。ですから八元数:Oc クラスといっても、Oc(...) は四元数や複素数も対象にできるクラスです。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# 八元数の生成
Oc(1,2,3,4,5,6,7,8)
===============================
Oc(1, 2, 3, 4, 5, 6, 7, 8)

# 八元数の積と和
Oc(1,2,3,4,5,6,7,8) Oc(9,0,1,2,3,4,5,6), Oc(1,2,3,4,5,6,7,8)+Oc(9,0,1,2,3,4,5,6)
===============================
(Oc(-124, 20, 32, 44, 24, 60, 80, 76), Oc(10, 2, 4, 6, 8, 10, 12, 14))

# 八元数：複素数の生成
Oc(1,2)
===============================
Oc(1, 2)

# 八元数：複素数の積と和と、比較のための複素数の積
Oc(1,2) Oc(3,4), Oc(1,2)+Oc(3,4), (1+2j) (3+4j)
===============================
(Oc(-5, 10), Oc(4, 6), (-5+10j))

# 八元数：四元数の生成
Oc(1,2,3,4)
===============================
Oc(1, 2, 3, 4)

# 八元数：四元数の積と和
Oc(1,2,3,4) Oc(5,6,7,8), Oc(1,2,3,4)+Oc(5,6,7,8)
===============================
(Oc(-60, 12, 30, 24), Oc(6, 8, 10, 12))
</span>
</code>
</pre>
<p>
四元数は体ですが積演算の可換性が保証されなくなります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
a,b=Oc(1,2,3), Oc(4,5,6); a b, b a
===============================
(Oc(-24, 13, 18, -3), Oc(-24, 13, 18, 3))
</span>
</code>
</pre>
<p>
八元数になると結合律が成り立たなくなり、体でさえなくなります。でも逆元は存在しますし、分配率は成り立ちます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# 八元数で結合律が成り立たない例
(Oc(0,1) Oc(0,0,1)) Oc(0,0,0,0,1), Oc(0,1) (Oc(0,0,1) Oc(0,0,0,0,1))
===============================
(Oc(0, 0, 0, 0, 0, 0, 0, 1), Oc(0, 0, 0, 0, 0, 0, 0, -1))

# 八元数でも逆元が存在することの確認実験
N=10; seed(0);[ (Oc(x) Oc(x)^-1) ~== 1 for x in randn(N,8)]
===============================
[True, True, True, True, True, True, True, True, True, True]

# 八元数でも分配率が成り立つことの確認実験
N=10; seed(0);[ (a (b+c)) ~== (a b + a c) for a,b,c in randn(N,3,8)]
===============================
[True, True, True, True, True, True, True, True, True, True]
</span>
</code>
</pre>

<h3>O2,O3,O4,O5,O7: Zp(N) の Cayley/Dickson 構成</h3>
<p>
実数を複素数、四元数、八元数に拡張していく方法は<a href="http://ja.wikipedia.org/wiki/ケーリー＝ディクソンの構成法">「Cayley/Dickson の構成法」</a>と呼ばれます。この構成法の適用により、実数以外の体でも四元数や八元数に似た演算を可能にできます。PythonSf では環・体：Z2,Z3,Z4,Z5,Z7 に Cayley/Dickson の構成法を適用した環代数クラス O2,O3,O4,O5,O7 を標準配布の sfCrrntIni.py に定義してあります。これらのクラスを使った次のような演算が可能です。 
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# Z2 複素数の積
O2(0,1) O2(0,1)
===============================
O2(Z2(1))

# Z3 四元数の積
O3(0,1,2) O3(1,2,3,4)
===============================
O3(1, 0, 1, 2)

# Z5 四元数の積の逆元
O5(1,2,4,4)^-1
===============================
O5(3, 4, 3, 3)

# Z7 八元数の積の逆元
O7(1,2,3,4,5,6,7,8)^-1
===============================
O7(1, 5, 4, 3, 2, 1, 0, 6)

# Z7 八元数の積の逆元が本当に逆元であることを確認する
O7(1,2,3,4,5,6,7,8) O7(1, 5, 4, 3, 2, 1, 0, 6)
===============================
O7(Z7(1))
</span>
</code>
</pre>
<p>
具体的に、O3 四元数の性質を少し詳しく考えて見ましょう。代数学で「有元体は可換体である」すなわち「非可換な有限体は存在しない」ことが解っています。一方で O3 四元数の積には下のように非可換な組み合わせが存在します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# O3 四元数積の非可換な例
a,b=(O3(0, 0, 0, 1), O3(0, 0, 1, 0)); a b, b a
===============================
(O3(0, 2), O3(0, 1))
</span>
</code>
</pre>
<p>
ですから、O3 四元数は体にはなれないはずです。体のどんな性質が壊れてくるのでしょうか。一番壊れやすい箇所は積の逆元の存在でしょう。0 因子が紛れ込んできていると推測されます。実際にも下のように O3 四元数の 0 因子を虱潰し法で列挙させられます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# O3 四元数積の 0 因子全てを列挙する
ls=range(3); lO=[ O3(x) for x in mitr(ls,ls,ls,ls)]; [(x,y) for x,y in mitr(lO,lO) if x!=0 and y!=0 and x y == 0 ]
===============================
[(O3(0, 1, 1, 1), O3(0, 1, 1, 1)), ..... ]
# いっぱいありすぎるので、二番目以降を省略しました
</span>
</code>
</pre>
<p>
八元数となると虱潰し法での全部の組み合わせを調べようとすると時間がかかりすぎるようになります。そのときはランダム・データを使っての数値実験が便利です。例えば O3 八元数には結合律がいっぱいありそうだが、O2 八元数では結合律が成り立たなそうなことが下の PythonSf 式より実験的に解ります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# O3 八元数は ランダムに選んだ三つの値の組に対して結合律が成り立たない。
seed(0); N=1   ; [(x,y,z) for x,y,z in randint(3, size=[N,3,8]) if O3(x) (O3(y) O3(z)) != (O3(x) O3(y)) O3(z)]
===============================
[(ClTensor([0, 1, 0, 1, 1, 2, 0, 2], dtype=int), ClTensor([0, 0, 0, 2, 1, 2, 2, 0], dtype=int), ClTensor([1, 1, 1, 1, 0, 1, 0, 0], dtype=int))]


# O2 八元数は ランダムに選んだ 1000 組の値全てに対して結合律が成り立つ。
seed(0); N=1000; [(x,y,z) for x,y,z in randint(2, size=[N,3,8]) if O2(x) (O2(y) O2(z)) != (O2(x) O2(y)) O2(z)]
===============================
[]
</span>
</code>
</pre>
<p>
その他にも「O2 四元数／八元数の積演算が可換である」など、O2,O3,O4,O5,O7 環代数系には様々の性質があります。ぜひとも御自分の手で操作して色々と遊んでみてください。

<p>
O2,O3,O4,O5,O7 は圏論での具体例の検討に便利です。ベクトル空間からベクトル空間への morphing 関数を、行列よりも簡単に作れます。有限代数系であり、虱潰しによる検証が可能です。その上 O2,O3,O4,O5,O7 代数系は部分的に予測のつく性質を備えているからです。これらの性質を使って圏論での functor や natural transformation といった関数群たちの具体例を容易に作れるからです。
<h3>oc.RS: GF(2^8) 有限体</h3>
<p>
バイト値に対して加減乗除べき乗算を可能にする GF(2^8) 有限体を pysf\octn.py モジュールで RS クラスとして実装してあります。その原始多項式は、CD や DVD での Reed-Solomon Code で使われているものを使っています。下のような具合です。 
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.info(oc.RS)
 RS(inAg)

' GF(2^8) for primitive polynomial:x^8 + x^4 + x^3 + x^2 + 1:0x1d
RS.m_lstPwrStt has exponent values
e.g;; oc.RS.m_lstPwrStt
[1, 2, 4, 8, 16, 32, 64, 128, 29, 58, ... 173, 71, 142]

oc.RS(0x12) + oc.RS(0x43)
===============================
0x51

oc.RS(0x12) - oc.RS(0x43)
===============================
0x51

oc.RS(24) oc.RS(31)
===============================
0x15

oc.RS(24)/oc.RS(31)
===============================
0xd7

oc.RS(2)^8
===============================
0x1d

oc.RS(2)^-8
===============================
0x83

~[ [1,2],[3,4], oc.RS]^-1
===============================
[[0x02 0x01]
 [0x8f 0x8e]]

oc.RS.m_lstPwrStt.index(24)
===============================
28

oc.RS.m_lstPwrStt.index(31)
===============================
113

hex(oc.RS.m_lstPwrStt[28+113])
===============================
0x15
'


Methods:

  inv  --  ' Return inverse instance '
===============================
None
</span>
</code>
</pre>
<p>
oc.RS インスタンスを要素とする行列やベクトルも、下のように殆ど数値のときと同様に扱えます。Reed-Solomon 符号などを考えるとき oc.RS は便利に使えます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# oc.RS インスタンスを要素とする 2x2 行列
~[ [1,2],[3,4], oc.RS]
===============================
[[0x01 0x02]
 [0x03 0x04]]
---- ClFldTns:< class 'pysf.octn.RS'> ----

# oc.RS インスタンスを要素とする、長さ 2 のベクトル
RS=oc.RS; ~[RS(5), RS(6)]
===============================
[0x05 0x06]
---- ClFldTns:< class 'pysf.octn.RS'> ----

# oc.RS インスタンスでの行列とベクトルの積
RS=oc.RS; mt,vc = ~[RS(5), RS(6)],~[ [1,2],[3,4], RS]; mt vc
===============================
[0x0f 0x12]
---- ClFldTns:< class 'pysf.octn.RS'> ----

# oc.RS インスタンスでの逆行列
~[ [1,2],[3,4], oc.RS]^-1
===============================
[[0x02 0x01]
 [0x8f 0x8e]]
---- ClFldTns:< class 'pysf.octn.RS'> ----

</span>
</code>
</pre>
<h3>`1,`0: oc.BF ブール体</h3>
<p>
Z2 とは独立して、ブール体クラス BF を pysf\ocnt.py モジュールに実装してあります。ブール体を使う頻度は高いので customize.py で `1,`0 に BF(1),BF(0) インスタンスを対応させてあります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
type(`1)
===============================
<class 'pysf.octn.BF'>

np.info(oc.BF)
 BF(inAg)

' Bool Field: data member is 1 or 0
    `1 * `0 = `0   # and
    `1 * `1 = `1
    `0 * `0 = `0

    `1 + `0 = `1   # xor
    `1 + `1 = `0
    `0 + `0 = `0
'


Methods:

  inv  --  ' inverse BF(1) '
===============================
None
</span>
</code>
</pre>
<a name="■■ 多項式"></a>
<h2>■■ 多項式</h2>

<h3>np.poly1d: Numpy 整数・実数・複素数係数の多項式</h3>
<p>
高校数学で出てくる整数・実数・複素数係数の多項式は Numpy の poly1d クラスで扱うのが便利です。下のような計算ができます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# 多項式インスタンスの生成
p=np.poly1d; p([1,2,3,4])
===============================
   3     2
1 x + 2 x + 3 x + 4

# 多項式インスタンスどうしの割り算
p=np.poly1d; p([1,2,3,4])/p([4,5,6])
===============================
(poly1d([ 0.25  ,  0.1875]), poly1d([ 0.5625,  2.875 ]))

# 一次単項多項式 x の定義と、その演算
p=np.poly1d; x=p([1,0]); (x^3+ 4 x^2 + 5)^2
===============================
   6     5      4      3      2
1 x + 8 x + 16 x + 10 x + 40 x + 25

# 項多項式の微分
p=np.poly1d; x=p([1,0]); (x^3+ 4 x^2 + 5).deriv()
===============================
   2
3 x + 8 x

# 多項式の積分
p=np.poly1d; x=p([1,0]); (x^3+ 4 x^2 + 5).integ()
===============================
      4         3
0.25 x + 1.333 x + 5 x

p=np.poly1d; x=p([1,0]); ((x^3+ 4 x^2 + 5)^2 /(x^2+x+1))
===============================
(poly1d([  1.,   7.,   8.,  -5.,  37.]), poly1d([-32., -12.]))

# 多項式割り算の商
p=np.poly1d; x=p([1,0]); ((x^3+ 4 x^2 + 5)^2 /(x^2+x+1))[0]
===============================
   4     3     2
1 x + 7 x + 8 x - 5 x + 37

# 多項式の根
p=np.poly1d; p([1,2,3,4]).roots
===============================
[-1.65062919+0.j         -0.17468540+1.54686889j -0.17468540-1.54686889j]

# 複素数係数の多項式
p=np.poly1d; p([1,2+5j,3,4])
===============================
   3            2
1 x + (2 + 5j) x + 3 x + 4

# 複素数係数の多項式の根
p=np.poly1d; p([1,2+5j,3,4]).roots
===============================
[-1.73932579-5.4296024j   0.32545721+0.88631641j -0.58613142-0.45671402j]

# 一次単項多項式 x で定義した関数のグラフ
p=np.poly1d; x=p([1,0]); f=(x^3+ 4 x^2 + 5)^2; plotGr(f, -5,2)
</span>
</code>
</pre>
<img src="./jpg/1111/oneliners_float_coef_plnml.jpg">
<a name="general_field_polynomials"></a>
<h3>一般体係数の多項式</h3>
<p>
学部数学になると Zp(N) など様々の可換体の値を係数とする多項式を扱う必要がでてきます。np.poly1d では、そんなのは扱えません。PythonSf では pysf\octn.py モジュールに一般体係数の多項式クラス Pl が定義してあるので、Zp(N) などの可換体係数多項式を扱えます。下のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.info(oc.Pl)
 Pl(*sqAg, **kwDctAg)

' polynomial for algebraic coefficients

usages:
    import octn as oc
    oc.Pl(1,2,3,4)                  # a integer coefficient polynomial
    =============================== # int type is estimated from paramters
    1x^3+2x^2+3x+4

    lst=[1,2,3,4];oc.Pl(lst)        # can use sequence argment too
    ===============================
    1x^3+2x^2+3x+4

    oc.Pl(1,2,3,4, variable='D')    # assign polynomial variable string
    ===============================
    1D^3+2D^2+3D+4

    oc.Pl(1,2,3,4,       oc.BF)     # assgin bool field coefficient
    ===============================
    x^3+x                           # 0 suppressed

    oc.Pl(1,2,3,4, dtype=oc.BF)     # assgin bool field coefficient with dtype key word
    ===============================
    x^3+x                           

    oc.Pl(1,2,3,`1)                 # assign type estimating from argments
    =============================== # ;;type(sum([1,2,3,`1]))   #== oc.BF
    x^3+x+1

    P=oc.Pl; P([1,2,3,4],Z3)
    ===============================
    Z3(1)x^3+Z3(2)x^2+Z3(1)

    P=oc.Pl; P([5,6,7,8],Z3)
    ===============================
    Z3(2)x^3+Z3(1)x+Z3(2)

    P=oc.Pl; P([1,2,3,4],Z3) + P([5,6,7,8],Z3)  # add
    ===============================
    Z3(2)x^2+Z3(1)x

    P=oc.Pl; P([1,2,3,4],Z3) - P([5,6,7,8],Z3)  # subtract
    ===============================
    Z3(2)x^3+Z3(2)x^2+Z3(2)x+Z3(2)

    P=oc.Pl; P([1,2,3,4],Z3) * P([5,6,7,8],Z3)  # multiply
    ===============================
    Z3(2)x^6+Z3(1)x^5+Z3(1)x^4+Z3(1)x^2+Z3(1)x+Z3(2)

    P=oc.Pl; P([1,2,3,4],Z3) / P([5,6,7,8],Z3)  # divide and (quotient,residual)
    ===============================
    (Pl(Z3(2)), Pl(Z3(2)x^2+Z3(1)x))

    P=oc.Pl; P([1,2,3,4],Z3) % P([5,6,7,8],Z3)  # residual
    ===============================
    Z3(2)x^2+Z3(1)x

    P=oc.Pl; P([1,2,3,4],Z3) // P([5,6,7,8],Z3) # quotient
    ===============================
    Z3(2)

    P=oc.Pl; P([1,2,3,4],Z3)^3                  # exponent
    ===============================
    Z3(1)x^9+Z3(2)x^6+Z3(1)

    P=oc.Pl; P([1,2,3,4],Z3)(P([5,6,7,8],Z3))   # composition
    ===============================
    Z3(2)x^9+Z3(2)x^6+Z3(2)x^4+Z3(2)x^3+Z3(2)x^2+Z3(2)x+Z3(2)
</span>
</code>
</pre>

<h3>ブール代数体とブール体係数多項式</h3>
<p>
CRC 多項式など、ブール体係数の多項式は使う頻度が高いので、 customize.py の中で oc.Pl を継承したブール体専用の多項式クラス PB を定義してあり、それを使って `P ラベルに単項一次式を割り当ててあります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
type(`P)
===============================
<class 'pysf.customize.PB'>

np.source(PB)
In file: pysf\customize.py

class PB(oc.Pl):
    """' BF:Bool Field `P polynomial '"""
    def __init__(self, *sqAg):
        oc.Pl.__init__(self, dtype = oc.BF, variable='`P', *sqAg)

===============================
None
</span>
</code>
</pre>
`P を使うことで、教科書に書いてある多くのブール体系数多項式をエディタ上で計算できるようになります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# ブール体係数多項式における商と余りの計算
(`P^5+1)/(`P+1)
===============================
(Pl(`P^4+`P^3+`P^2+`P+1), Pl(0))

# ブール体係数多項式における商の計算
(`P^5+1)//(`P+1)
===============================
`P^4+`P^3+`P^2+`P+1

# ブール体係数多項式における剰余の計算
(`P^5+1)%(`P^2+1)
===============================
`P+1
</span>
</code>
</pre>
<p>
`P を使えば、`P^3+`P+1 ブール体係数多項式が既約多項式であること、すなわち 1 以外の多項式では割り切れないことを下のように虱潰し証明できます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# `P^3+`P+1 が既約多項式であることの虱潰し証明 
# 二次までのブール体係数多項式全ての内から(0 を除く)、剰余多項式が 0 になるものを列挙する ==> 1 のみ
ls=[`0,`1]; [ x for x in mitr(*[ls]*3) if PB(x) !=0 and (`P^3+`P+1)%PB(x) ==0]
===============================
[(BF(0), BF(0), BF(1))]
</span>
</code>
</pre>

<!--
BF:Bool Field:`1,`0
    `P 多項式
Zp(N)
-->
<a name="■■ 無限長数列と itertools"></a>
<h2>■■ 無限長数列と itertools</h2>
<p>
Python には builtin itertools モジュールがあり無限長シーケンスを扱えます。でも それは無限繰り返し処理のためのモジュールであり、無限長数列のためのモジュールではありません。ですから unsubscriptable であり、数列を扱うのに必須な [..] によるインデックスを使えません。
<p>
でも [..] によるインデックスは __getitem__(..) を実装するだけで使えるようになります。__iter__(..) method を前提とすれば、その実装は簡単です。実際 tn.idx クラスとして実装してあります。その tn.idx を itertools の各関数に適用したものを pysf\tlRcGn.py に実装してあります。pysf.tlRcGn モジュールは tn のラベルに割り当ててあります。これにより次のような PythonSf 式計算が可能になります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.info(tn)
'
extended itertools usages:

tn.count(3)[1:10]
===============================
[4, 5, 6, 7, 8, 9, 10, 11, 12]

(tn.imap(lambda x:x^2, tn.count(10) )[1:10])
===============================
[121, 144, 169, 196, 225, 256, 289, 324, 361]

tn.cycle(xrange(3))[1:10]
===============================
[1, 2, 0, 1, 2, 0, 1, 2, 0]

tn.repeat('s',100)[1:10]
===============================
['s', 's', 's', 's', 's', 's', 's', 's', 's']

tn.repeat(True)[1:10]
===============================
[True, True, True, True, True, True, True, True, True]

tn.repeat(`1)[1:10]
===============================
[BF(1), BF(1), BF(1), BF(1), BF(1), BF(1), BF(1), BF(1), BF(1)]

tn.izip(range(100), xrange(3,100))[1:10]
===============================
[(1, 4), (2, 5), (3, 6), (4, 7), (5, 8), (6, 9), (7, 10), (8, 11), (9, 12)]

tn.izip(range(100), xrange(3,100), tn.count() )[1:10]
===============================
[(1, 4, 1), (2, 5, 2), (3, 6, 3), (4, 7, 4), (5, 8, 5), (6, 9, 6), (7, 10, 7), (8, 11, 8), (9, 12, 9)]

(tn.ifilter(lambda x:x%2==0, tn.count(10) )[1:10])
===============================
[12, 14, 16, 18, 20, 22, 24, 26, 28]

(tn.ifilter(None, tn.count() )[1:10])
===============================
[2, 3, 4, 5, 6, 7, 8, 9, 10]

(tn.ifilterfalse(lambda x:x%2==0, tn.count(10) )[1:10])
===============================
[13, 15, 17, 19, 21, 23, 25, 27, 29]

(tn.ifilterfalse(None, tn.count() )[0])
===============================
0

tn.islice(tn.count(),1,30,3 )[3:10]
===============================
[10, 13, 16, 19, 22, 25, 28]

tn.startmap(lambda *tplAg:sum(tplAg), tn.izip(range(15), range(3,100)) )[1:10]
===============================
[5, 7, 9, 11, 13, 15, 17, 19, 21]
'
===============================
None
</span>
</code>
</pre>
<p>
pi/4 == 1 - 1/2 + 1/5 - 1/7 + ... + (-1)^n 1/(2n+1) ... の公式を使って、少し PythonSf の tn の itertools で遊んでみましょう。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# pi/4 となる無限長数列のインデックス 10 までの数列
ts();  tn.imap(λ n:(-`1r)^n 1/(2n+1), tn.count() )[:10]
===============================
[1, -1/3, 1/5, -1/7, 1/9, -1/11, 1/13, -1/15, 1/17, -1/19]

# 上の無限長数列のインデックス 50 までの和
ts(); sum(tn.imap(λ n:(-`1r)^n 1/(2n+1), tn.count() )[:50])
===============================
850151369116051611488718369170287588082/1089380862964257455695840764614254743075

# pi/4 と、上の無限長数列のインデックス 50 までの和の浮動小数点値
ts(); pi/4, float(sum(tn.imap(λ n:(-`1r)^n 1/(2n+1), tn.count() )[:50]))
===============================
(0.7853981633974483, 0.7803986631477526)

# atan(.) の 1 における厳密値
ts(); ts.atan(1)
===============================
pi/4

#atan の Taylor 展開
ts(); ts.series(ts.atan(`x),`x,n=20)
===============================
x - x**3/3 + x**5/5 - x**7/7 + x**9/9 - x**11/11 + x**13/13 - x**15/15 + x**17/17 - x**19/19 + O(x**20)

</span>
</code>
</pre>
<!--
無限長数列
print tn.count(3)[1:10]
#print (it.imap(lambda x:x^2, fcount(10) )[1:10])
print (tn.imap(lambda x:x^2, tn.count(10) )[1:10])
print tn.cycle(xrange(3))[1:10]
print tn.repeat('s',100)[1:10]
print tn.repeat(True)[1:10]
print tn.repeat(`1)[1:10]
print tn.izip(range(100), xrange(3,100))[1:10]
print tn.izip(range(100), xrange(3,100), tn.count() )[1:10]
print (tn.ifilter(lambda x:x%2==0, tn.count(10) )[1:10])
print (tn.ifilter(None, tn.count() )[1:10])
print (tn.ifilterfalse(lambda x:x%2==0, tn.count(10) )[1:10])
#print (ffilterfalse(None, it.count() )[1:10])  # infinite loop finding 1:9 false
print (tn.ifilterfalse(None, tn.count() )[0])
print tn.islice(tn.count(),1,30,3 )[3:10]
print tn.startmap(lambda *tplAg:sum(tplAg), tn.izip(range(15), range(3,100)) )[1:10]
#print          (lambda *tplAg:sum(tplAg), tn.tee(range(15), 3) )
print "=========================="
print tn.chain(range(3), tn.count(10) )[1:10]
Python には builtin itertools モジュールがあり無限長シーケンスを扱えます。でも unsubscriptable であり、[..] によるインデックスを使えません。__getitem__
    __getitem__ を実装してあり、[..] によるインデックス
    スライスを扱えるようにしてあります

正則連分数への分解ルーチン
    理由もデバッガなりで変化の様子を追跡してみれば解る
//@@
ts()
def f(x,M=10):
    ls=[]
    for _ in range(M):
        inAt = ts.floor(x)
        ls.append(inAt)
        x =  1 /(x-inAt)

    return ls

#print f(ts.pi, 30)
print f(ts.pi, 242)
//@@@
上のルーチンをワン･ライナーで
<== ls[0] に x を入れる
N=100; ts(); x=ts.pi; ls=[x];for _ in range(N):ls.append(ts.floor(ls[0])) or ls.insert(0,1/(ls[0]-ls[-1])) or ls.pop(1); ls[1:]
===============================
[3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2, 2, 2, 1, 84, 2, 1, 1, 15, 3, 13, 1, 4, 2, 6, 6, 99, 1, 2, 2, 6, 3, 5, 1, 1, 6, 8, 1, 7, 1, 2, 3, 7, 1, 2, 1, 1, 12, 1, 1, 1, 3, 1, 1, 8, 1, 1, 2, 1, 6, 1, 1, 5, 2, 2, 3, 1, 2, 4, 4, 16, 1, 161, 45, 1, 22, 1, 2, 2, 1, 4, 1, 2, 24, 1, 2, 1, 3, 1, 2, 1, 1, 10]
ts();ts.exp(1)
ts();ts.floor( ts.E )

N=100; ts(); x=ts.E; ls=[x];for _ in range(N):ls.append(ts.floor(ls[0])) or ls.insert(0,1/(ls[0]-ls[-1])) or ls.pop(1); ls[1:]
===============================
[2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, 1, 1, 10, 1, 1, 12, 1, 1, 14, 1, 1, 16, 1, 1, 18, 1, 1, 20, 1, 1, 22, 1, 1, 24, 1, 1, 26, 1, 1, 28, 1, 1, 30, 1, 1, 32, 1, 1, 34, 1, 1, 36, 1, 1, 38, 1, 1, 40, 1, 1, 42, 1, 1, 44, 1, 1, 46, 1, 1, 48, 1, 1, 50, 1, 1, 52, 1, 1, 54, 1, 1, 56, 1, 1, 58, 1, 1, 60, 1, 1, 62, 1, 1, 64, 1, 1, 66, 1]

N=100; ts(); x=ts.E; ls=[x];for _ in range(N):ls.append(ts.floor(ls[0])) or ls.insert(0,1/(ls[0]-ls[-1])) or ls.pop(1); reduce(λ x,y:`1r/x + y,ls[1:][::-1], `1r)
===============================
13823891428306770374331665289458907890372191037173036666131/5085525453460186301777867529962655859538011626631066055111

exp(1)-13823891428306770374331665289458907890372191037173036666131/5085525453460186301777867529962655859538011626631066055111
===============================
0.0
N=30 ; ts(); x=ts.E^2; ls=[x];for _ in range(N):ls.append(ts.floor(ls[0])) or ls.insert(0,1/(ls[0]-ls[-1])) or ls.pop(1); ls[1:]
===============================
[7, 2, 1, 1, 3, 18, 5, 1, 1, 6, 30, 8, 1, 1, 9, 42, 11, 1, 1, 12, 54, 14, 1, 1, 15, 66, 17, 1, 1, 18]

N=30 ; ts(); x=ts.sqrt(3); ls=[x];for _ in range(N):ls.append(ts.floor(ls[0])) or ls.insert(0,1/(ls[0]-ls[-1])) or ls.pop(1); ls[1:]
===============================
[3**(1/2), oo, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan]
-->
<a name="■■ その他"></a>
<h2>■■ その他</h2>
<p>
Python は開かれた言語です。パッケージやモジュールを import することで、数値計算の他にも多様な処理が可能になります。それらの多くはワンライナーで実行可能です。以下それらの便利な処理を見ていきましょう。
<h3>Python テスト・コードの実行</h3>
<p>
短い Python コードをテスト実行したくなることがよくあります。Python の全てを頭の中に入れるのは無理だからです。皆様は Python で下のように書けるのをご存知でしょうか。これらの動作結果をデバッガなどを立ち上げることなく、思いつくままにエディタ上で確認できてしまいます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# == 演算子の一括比較
a,b,c=1+1,2+0,3-1; a==b==c
===============================
True

# != の一括比較は無理
a,b,c=1+1,2+0,3+1; a!=b!=c
===============================
False

# <= 演算子の一括比較
a,b,c=1  ,2  ,3  ; a<=b<=c
===============================
True

<b>PythonSf ワンライナー</b>
# 整数／実数の hash 値 
x=124; hash(x), hash(124.0),hash(124.1)
===============================
(124, 124, -924195431)

<b>PythonSf ワンライナーたち</b>
# ベクトルのリストのような和 1
np.r_[~[1,2,3],~[4,5,6,7]]
===============================
[ 1.  2.  3.  4.  5.  6.  7.]

# ベクトルのリストのような和 2
np.r_[np.array([1,2,3]), 0, 0, np.array([4,5,6])]
===============================
[1 2 3 0 0 4 5 6]

# ellipsis 演算: ...
arange(3*4).reshape(3,4)[..., :2]
===============================
[[0 1]
 [4 5]
 [8 9]]

<b>PythonSf ワンライナーたち</b>
# 実数に対する %,// 演算
pi%1
===============================
0.14159265359

pi//1
===============================
3.0

# 負の実数に対する %,// 演算
-2.345% 1
===============================
0.655

-2.345//1
===============================
-3.0

# 複素数では、虚数側は元の値のまま
(pi+`i 3.456 )%1
===============================
(0.14159265359+3.456j)

</span>
</code>
</pre>
<h3>カレンダ表示</h3>
<p>
予定を検討するときなどで特定月のカレンダーを見たいことが良くあります。PythonSf があれば、次のワン･ライナーで指定した年月の曜日を打ち出せます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
import calendar as cl; cl.prmonth(2011, 8)
    August 2011
Mo Tu We Th Fr Sa Su
 1  2  3  4  5  6  7
 8  9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28
29 30 31
===============================
None
</span>
</code>
</pre>
<p>
予定表も書き込めるカレンダーを欲しいときは、下のように w,l のキーワード引数に空き幅を指定します。
<pre>
<code>
<span style="color: #9f009f;">
import calendar as cl; cl.prmonth(2011, 8, w=11, l=2)
                                    August 2011

   Monday     Tuesday    Wednesday    Thursday     Friday     Saturday     Sunday

      1           2           3           4           5           6           7

      8           9          10          11          12          13          14

     15          16          17          18          19          20          21

     22          23          24          25          26          27          28

     29          30          31

===============================
None
</span>
</code>
</pre>
<p>
毎月の業務メモのテンペレートの一行目に、このカレンダー・ワンライナーを置いておくのも便利ではないでしょうか。

<h3>zip,tar の解凍</h3>
<p>
python には zipfile, tarfile といったファイルの圧縮・解凍のための package が備わっています。それらを利用すれば、エディタ上でファイルの圧縮・解凍操作が可能です。

<pre>
<code>
<span style="color: #9f009f;">
# 雛形
import tarfile as tr;tr.open('', 'r').extractall()
import tarfile as tr;tr.open('', 'r').list()
import tarfile as tr;tr.open('D:/lng/msysgit/bin/sfepy/gmsh/gmsh-2.5.0-source.tgz', 'r').list()

# 解凍　ワン・ライナーの例
import tarfile as tr;tr.open('D:/lng/msysgit/bin/sfepy/gmsh/gmsh-2.5.0-source.tgz', 'r').extractall()

# 雛形;;ss='';import tarfile as tr;tr.open(ss, 'r').list()
ss='D:/lng/msysgit/bin/sfepy/gmsh/gmsh-2.5.0-source.tgz';import tarfile as tr;tr.open(ss, 'r').list()

</span>
</code>
</pre>

<h3>電源回路の電圧と電流</h3>
<p>
<pre>
Vi         Rs         Vx
───|>|-─MWMW───┬───┐
                      │      │
                    ─┴─    ≧
                    ─┬─ C  ≦Rl
                      │      │
───────────┴───┘
</pre>
<p>
上のようなシリーズ・レギュレータ回路の電流・電圧値を正確に計算した経験のある方は少ないと思います。整流ダイオードのために系が非線形なってしまい、まともに取り扱うのが面倒だからです。でも常微分方程式のソルバー： kOde(..) を使えば、下のように簡単に計算できてしまいます。
<p>
電圧 Vi,Vx と抵抗、コンデンサの間には下のような関係があります。
<pre>
<span style="color: #9f009f;">
<b>関係式</b>
C dVx/dt = (Vi-Vx)/Rs - Vx/Ri  if Vi > Vx
C dVx/dt =            - Vx/Ri  if Vi < Vx
 
 dVx/dt = ((Vi-Vx)/Rs - Vx/Rl)/C  if Vi > Vx
 dVx/dt = (           - Vx/Rl)/C  if Vi < Vx
</span>
</code>
</pre>
これだけ分っていれば、kOde(..) で上の系の挙動をシミュレーション計算できます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
# 出力電圧:Vx<br>
sy(); f0=50Hz`; f=7V` absF(sin(2pi f0 `T)); C,Rs,Rl=1000uF`, 1Ω`,33Ω`;mt=kOde(λ t,Vx:[1,((f(t)-Vx)/Rs-Vx/Rl)/C if f(t)>=Vx else (-Vx/Rl)/C],[0,0],100ms`,256); plotGr(mt[:,1])
</span>
</code>
<br>
<img src="./jpg/1111/oneliner_powe_vx.jpg">
<br>
<br>
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
# 入力電流<br>
sy(); f0=50Hz`; f=7V` absF(sin(2pi f0 `T)); C,Rs,Rl=1000uF`, 1Ω`,33Ω`;mt=kOde(λ t,Vx:[1,((f(t)-Vx)/Rs-Vx/Rl)/C if f(t)>=Vx else (-Vx/Rl)/C],[0,0],100ms`,256); plotGr([(f(t)-Vx)/Rs if f(t)>=Vx else 0 for t,Vx in mt])

</span>
</code>
<br>
<img src="./jpg/1111/oneliners_power_vi.jpg">
<br>
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
# 入力電流:Vi と出力電圧:Vx<br>
sy(); f0=50Hz`; f=7V` absF(sin(2pi f0 `T)); C,Rs,Rl=1000uF`, 1Ω`,33Ω`;mt=kOde(λ t,Vx:[1,((f(t)-Vx)/Rs-Vx/Rl)/C if f(t)>=Vx else (-Vx/Rl)/C],[0,0],100ms`,256); plotGr([(f(t)-Vx)/Rs if f(t)>=Vx else 0 for t,Vx in mt]);plotGr(mt[:,1],color=red)
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_power_vi_vx.jpg">
<p>
縦軸が電圧値と電流値の両方を兼ねています。単位が異なります。物理的には許されません。でも自分だけが見るグラフならば、意味が分っていますから許されるでしょう。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
# 最大突入電流:Vi<br>
sy(); f0=50Hz`; f=7V` absF(cos(2pi f0 `T)); C,Rs,Rl=1000uF`, 1Ω`,33Ω`;mt=kOde(λ t,Vx:[1,((f(t)-Vx)/Rs-Vx/Rl)/C if f(t)>=Vx else (-Vx/Rl)/C],[0,0],100ms`,256); plotGr([(f(t)-Vx)/Rs if f(t)>=Vx else 0 for t,Vx in mt])
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_power_vi_max.jpg">
<p>
最大突入電流を計算するため、入力電圧関数を sin(.) ではなく cos(.) にしました。
<br>
シリコンの 0.6V 分も含めた計算も簡単です。λ式を二重に使い、キーワード引数を O'Caml などの let 文の代わりにしています。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
sy(); f0=50Hz`; f=λ t:(λ v=7V` cos(2pi f0 t):v-0.6V` if v>0.6V` else 0)(); C,Rs,Rl=1000uF`, 1Ω`,33Ω`;mt=kOde(λ t,Vx:[1,((f(t)-Vx)/Rs-Vx/Rl)/C if f(t)>=Vx else (-Vx/Rl)/C],[0,0],100ms`,256); plotGr([(f(t)-Vx)/Rs if f(t)>=Vx else 0 for t,Vx in mt])
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_power_06v.jpg">
<br>


<a name="Laplace 演算子:`s および遅延演算子 z^-1"></a>
<a name="■■ Laplace 演算子:`s および遅延演算子 z^-1"></a>
<h2>■■ Laplace 演算子:`s および遅延演算子 z^-1</h2>
<p>
PythonSf には、ラプラス演算子 s に対応する有理関数クラスの単項式 `s が備わっています。`s は z 変換の単項式としても扱えます。。これを使えばアナログ・フィルタ、デジタル・フィルタの挙動が短い PythonSf ワン･ライナー式で簡単に計算できます。Matlab,Mathematica など他の数学ソフトでは、ここまで簡単には計算できないと思います。以下の one-liners を見てやってください。

<h3>`s を使った LCR 回路の検討</h3>
<p>
    標準配布の PythonSf に備わっている `s を使えば、回路の Laplace 演算子を使った式を扱えます。そのボード線図、インパルス応答、インディシャル応答が簡単に求められます。この `s を使って下の L C R を組み合わせた回路の動作を検討してみましょう。
<pre>
<code>
<span style="color: #9f009f;">
<b>L C R 回路</b>
                      11mH       10Ω
            Vi ──∩∩∩∩ ─WMWM─┐ ──→ Vo
                                    │   
                                  ─┴─ 
                                  ─┬─ 
                                    │1uF
                                    │
                                    Ξ   

</span>
</code>
</pre>
<p>
コイル L は微分要素であり、その Lapalace 演算子表現は L `s です。C は積分要素であり、その Laplace 演算子表現は 1/(C `s) です。ですから L C R 三つを直列につないだときの impedence の Laplace 演算子表現 (L `s + 1/(C `s) + R) となります。
<p>
ですから、上の回路の電圧伝達関数 Vo/Vi は下のように PythonSf 式で計算できます。この伝達関数を何回か再利用するため、ファイル変数 G としてカレント・ディレクトリに残すことも、下の PythonSf 式の G:= ... の式で行わせています。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
L,C,R=1000uH`, 1uF`, 10Ω`; G:=1/(C `s)/(L `s + 1/(C `s) + R)
===============================
        
       1e+09
-------------------
 2
s + 1e+04 s + 1e+09
</span>
</code>
</pre>
<p>
この伝達関数 G が どんなものか Python に備わっている自己ドキュメント機能を使って調べてみましょう。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# G は どんなクラス？ ----- ClRtnl クラス
=:G; type(G)
===============================
&lt;class 'pysf.rational.ClRtnl'&gt;

# ClRtnl はどんなメソッドを備えている？
np.info(ClRtnl)
 ClRtnl(numerAg, denomAg=1, variable='s')

' Ratianal Function class
    The highest coefficient of demoninator is always 1
'


Methods:

  getAnRspns  --  
  getDgRspns  --  
  deriv  --  Return the derivative of this rational funciton.
  plotDgGnPh  --  
  getAnImpls  --  
  plotBode  --  
  getRtnlOfRtnl  --  
  getDgImpls  --  
  plotAnRspns  --  
===============================
None

# G が保持しているデータは？ ---- 分母と分子の多項式
=:G; vars(G)
===============================
{'m_plNumer': poly1d([  1.00000000e+09]), 'm_plDenom': poly1d([  1.00000000e+00,   1.00000000e+04,   1.00000000e+09])}

</span>
</code>
</pre>
<p>
G は plotBode(..) 関数を備えています。この関数で Bode 線図を描きます。名前から Bode 線図を描かせる関数だと分かります。どんな使い方をするのでしょうか調べましょう。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# ClRtnl:plotBode 関数の使い方を調べる
=:G; np.info(G.plotBode)
 plotBode(lowerFreq, higherFreq=None)

'  plot Bode diagram using matplotlib
    Default frequency width is 3 decades
'
===============================
None
</span>
</code>
</pre>
<p>
Bode 線図を描かせるには周波数範囲を指定してやる必要があるようです。伝達関数 G は m_plDenon: poly1d 多項式のインスタンスを備えています。ならば、その根が判れば Bode 線図の周波数範囲も決まります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:G; G.m_plDenom.roots
===============================
[-5000.+31224.98999199j -5000.-31224.98999199j]
</span>
</code>
</pre>
<p>
上の計算結果:分母多項式の根は 3kHz 周波数近辺に共振することを示しています。ならば その二桁下 10Hz から二桁上 100kHz の範囲の周波数でボード線図を描けば良さそうです。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:G; G.plotBode(10Hz`, 100k` Hz`)
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_lcr_bode.jpg">
<br>
<p>
plotAnImpls(..) 関数を使って、上の回路のインパルス応答を見てみましょう。グラフの時間表示範囲は 3kHz より判断して、時間の範囲は 0 -- 2ms としましょう。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:G; plotGr(G.getAnImpls( 2ms`))
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_lcr_impulse.jpg">
<br>
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:G; G.()
</span>
</code>
</pre>
<p>
インパルス応答の次は plotAnRspns(..) メソッドを使ってステップ応答を見てみましょう。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:G; G.plotAnRspns( 2ms`)
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_lcr_inditial.jpg">
<br>
<p>
今度は上の回路に 1kHz 正弦波を入力したときの応答をみてみましょう。
1kHz 正弦波関数は sin(2pi 1k` Hz` `T) と記述できます。(0,2ms) の区間を 256 等分したベクトル・データは klsp(0,2ms`,256) で作れます。これを引数にして sin(2pi 1k` Hz` `T)(klsp(0,2ms`,256) を計算してやれば、ikHz 正弦波の 2ms までの 256 点のベクトル・データが得られます。このデータを上の .getAnRspns(..) の二番目の引数に与えれやれば、上の回路に正弦波入力を与えたときの応答が得られます。 
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:G;G.plotAnRspns(2ms`,sin(2pi 1k` Hz` `T)(klsp(0,2ms`, 256)))
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_lcr_sin_1khz_rspns.jpg">
<br>
<p>
コンデンサ 1uF に充電が完了するまでの時間:初期の 0.5ms までは L C 共振成分が見られますが、それ以後は 1kHz の正弦波になっています。
<p>
ちなみに、矩形波入力を入れたときは次のような応答波形になります
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:G;G.plotAnRspns(2ms`,[(λ t:-1-2np.floor(2 (-0.5+ t 1k` Hz` -int(t 1k` Hz`)) ))(x) for x in klsp(0,2ms`, 256)])
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_lcr_square_wave_1khz_rspns.jpg">
<br>
<p>
上の PythonSf 式で矩形波を作っている λ t:-1-2np.floor(2 (-0.5+ t 1k` Hz` -int(t 1k` Hz`)) ) が少しく技巧的です。こんなのは、すらすらとは出てこないでしょう。矩形波を表す関数を手続き的にプログラムするべきかもしれません。実際には下のような順序で導出しています。こっちは関数プログラミング的な導出方だと思います。こちらの方が数学的思考に集中できます。手続き的なプログラム作成に伴うデバッグが入らないからです。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
plotGr(λ t: t-int(t 1k` Hz`), 0,10ms`)
plotGr(λ t: t 1k` Hz` -int(t 1k` Hz`), 0,10ms`)
plotGr(λ t: np.floor(2 (-0.5+ t 1k` Hz` -int(t 1k` Hz`)) ), 0,10ms`)
plotGr(λ t: np.floor(2 (-0.5+ t 1k` Hz` -int(t 1k` Hz`)) ), 0,2.5ms`)
plotGr([(λ t: np.floor(2 (-0.4+ t 1k` Hz` -int(t 1k` Hz`)) ))(x) for x in klsp(0,2ms`, 256)])
plotGr([(λ t: np.floor(2 (-0.5+ t 1k` Hz` -int(t 1k` Hz`)) ))(x) for x in klsp(0,2ms`, 256)])
plotGr([(λ t: 1+2np.floor(2 (-0.5+ t 1k` Hz` -int(t 1k` Hz`)) ))(x) for x in klsp(0,2ms`, 256)])
plotGr([(λ t:-1-2np.floor(2 (-0.5+ t 1k` Hz` -int(t 1k` Hz`)) ))(x) for x in klsp(0,2ms`, 256)])
</span>
</code>
</pre>

<h3>F 行列と RIAA 回路</h3>
<pre>
<code>
<span style="color: #9f009f;">
<b>RIAA 回路</b>
         R1:82kΩ                R3:1kΩ               
────WMWM───┬──────WMWM────┬────
                  │                        │        
                  ≧                        │        
                  ≦R2:12kΩ                │        
                  │                        │        
                ─┴─                    ─┴─      
                ─┬─ C1:0.027uF         ─┬─ C2:8200pF
                  │                        │        
─────────┴────────────┴────

</span>
</code>
</pre>
ここでは二端子網回路の F 行列を使って、上の RIAA 回路の電圧伝達関数を計算します。
<p>
標準配布 PythonSf の sfCrrntIni.py には、直列接続または並列接続の二端子網回路の F 行列を返す Fs(.) と Fp(.) が実装されています。これを使えば、上の RIAA 回路の R1 直列抵抗や R1 + 1/(C1 `s) 並列要素の F 行列は下のように計算できます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
R1=82kΩ`;  Fs(R1)
===============================
[[ClRtnl([ 1.],[ 1.]), ClRtnl([ 0.],[1])],
       [ClRtnl([-82000.],[ 1.]), ClRtnl([ 1.],[ 1.])]]
---- ClFldTns:< class 'pysf.rational.ClRtnl'> ----

R2,C1=12kΩ`,0.027uF`; Fp(R2+1/(C1 `s))
===============================
[[ClRtnl([ 1.],[ 1.]),
        ClRtnl([ -8.33333333e-05,   0.00000000e+00],[  1.00000000e+00,   3.08641975e+03])],
       [ClRtnl([ 0.],[1]), ClRtnl([ 1.],[ 1.])]]
---- ClFldTns:< class 'pysf.rational.ClRtnl'> ----
</span>
</code>
</pre>
<p>
RIAA 回路の要素ごとに F 行列が求められるのならば、それを掛け合わせてやれば RIAA 回路の F 行列が計算できます。下のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
R1,R2,R3,C1,C2=82kΩ`,12kΩ`,1kΩ`,0.027uF`,8200pF`;  Fp(1/(C2 `s)) Fs(R3) Fp(R2+1/(C1 `s)) Fs(R1)
===============================
[[ ClRtnl([  7.36633333e-04,   9.93395062e+00,   3.08641975e+03],[  1.00000000e+00,   3.08641975e+03]),
        ClRtnl([ -8.88333333e-09,  -1.08641975e-04,   0.00000000e+00],[  1.00000000e+00,   3.08641975e+03])],
       [ ClRtnl([ -8.98333333e+04,  -2.56172840e+08],[  1.00000000e+00,   3.08641975e+03]),
        ClRtnl([  1.08333333e+00,   3.08641975e+03],[  1.00000000e+00,   3.08641975e+03])]]
---- ClFldTns:< class 'pysf.rational.ClRtnl'> ----
</span>
</code>
</pre>
<p>
F 行列が定まれば、その電圧伝達関数は -F[1,0] F[0,1]/F[0,0] + F[1,1] で計算できます。下のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
R1,R2,R3,C1,C2=82kΩ`,12kΩ`,1kΩ`,0.027uF`,8200pF`;F=Fp(1/(C2 `s)) Fs(R3) Fp(R2+1/(C1 `s)) Fs(R1);(-F[1,0] F[0,1]/F[0,0] + F[1,1])
===============================
           3             2
     1358 s + 1.257e+07 s + 3.88e+10 s + 3.991e+13
-------------------------------------------------------
 4             3             2
s + 1.966e+04 s + 9.696e+07 s + 1.543e+11 s + 3.991e+13


R1,R2,R3,C1,C2=82kΩ`,12kΩ`,1kΩ`,0.027uF`,8200pF`;F=Fp(1/(C2 `s)) Fs(R3) Fp(R2+1/(C1 `s)) Fs(R1);(-F[1,0] F[0,1]/F[0,0] + F[1,1]).plotBode(1Hz`,100k` Hz`)
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_riaa_bode.jpg">
<br>
<p>
F 行列以外に Z 行列 Y 行列 などを返す関数を作ってやれば任意トポロジーの伝達関数を計算できるようになると思いますが、そこまでは実装していません。回路のプロのどなたか、この実装をしてみませんか。理屈さえわかっていれば、それらの実装は簡単です。Fs(.), Fp(.) 関数は下のような超が付くほどの簡単な実装で済んでいます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.source(Fs)
In file: sfCrrntIni.py

Fs = lambda Z:sf.krry__(*[[1.0,0.0],[-Z*1.0,1.0], sf.ClRtnl])

===============================
None

<b>PythonSf ワンライナー</b>
np.source(Fp)
In file: sfCrrntIni.py

Fp = lambda Z:sf.krry__(*[[1.0,-1.0/Z],[0.0,1.0], sf.ClRtnl])

===============================
None
</span>
</code>
</pre>

<h3>`s を使った z 変換</h3>
<p>
`s を作っているクラス ClRtnl には、デジタル・フィルタ向けのインパルスも応答関数：getDgImpls(..)、ステップ応答・一般応答関数：getDgRspns(.;)、ゲイン・位相表示関数：plotDgGnPh(..) も備えています。ですから下のような z 変換を使った算計処理が可能です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# FIR インパルス応答
z_=1/`s; (z_^1 + 2z_^2+ 3z_^3).getDgImpls()[:10]
===============================
[ 0.  1.  2.  3.  0.  0.  0.  0.  0.  0.]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
# FIR ステップ応答
z_=1/`s; (z_^1 + 2z_^2+ 3z_^3).getDgRspns()[:10]
===============================
[ 0.  1.  3.  6.  6.  6.  6.  6.  6.  6.]

<b>PythonSf ワンライナー</b>
# IIR ステップ応答
z=`s; ((z +1)/(z^1 + 2z^2+ 3z^3)).getDgImpls()[:10]
===============================
[ 0.          0.          0.33333333  0.11111111 -0.18518519  0.08641975
  0.00411523 -0.03155007  0.01966164 -0.00259107]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
# IIR ゲイン・位相図の描画
z=`s; (z^-1 + 2z^-2+ 3z^-3).plotDgGnPh()
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_dgtl_fltr_gain_phase.jpg">
<br>
<p>
<!--
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
              ┌───┬───┬──────┐  ──→ Vo
              │      │      │            │
            ─┴─    ⊃      ≧ -225Ω     ≧RL
            ─┬─    ⊃      ≦            ≦ 1Ω
              │1uF   ⊃1H    │            │
              │      │      │            │
              └───┼───┘            │
                      │                    │
                    ┌┴┐                  │
                    │Sg│                  │
                    └┬┘                  │
                      │                    │
                      Ξ                    Ξ

<b>PythonSf ワンライナー</b>
L,C,R, RL=1e6uH`, 1uF`, -225Ω`, 1Ω`;Gs=L `s + R + 1/(C `s); (RL/(RL+Gs)).plotAnRspns(100ms`, [1V`,-1V`]+[0V`]*256)

<b>PythonSf ワンライナー</b>
L,C,R, RL=1e6uH`, 1uF`, -225Ω`, 1Ω`;Gs=L `s + R + 1/(C `s); (RL/(RL+Gs)).m_plDenom.roots
===============================
[ 112.+993.70820667j  112.-993.70820667j]

<b>PythonSf ワンライナー</b>
L,C,R, RL=1e6uH`, 1uF`, -225Ω`, 1Ω`;Gs=L `s + R + 1/(C `s); (RL/(RL+Gs)).plotBode(0.01Hz`, 10Hz`)

L,C,R, RL=1e6uH`, 1uF`, -225Ω`, 1Ω`;Gs=L `s + R + 1/(C `s); plotBode(RL/(RL+Gs), 0.01Hz`, 10Hz`)

</span>
</code>
</pre>
impedence 計算
Bode 線図
根軌跡
F 行列
-->

<!--
<h2>Reed Solomon Code</h2>
GF(2^8) 係数多項式のインスタンスも picka le であり、ファイル変数にできる。
RS:GF(2^8)
<== 8bit データに加減乗除べき乗算を適用できる。
α=oc.RS(2); (`X-α^0) (`X-α^1) (`X-α^2) (`X-α^3)
===============================
<pysf.basicFnctns.ClAfOp object at 0x027F4630>
下の多項式で割り切れるようなデータのみにしてある
α,P=oc.RS(2), oc.Pl([1,0], oc.RS); (P-α^0) (P-α^1) (P-α^2) (P-α^3)
===============================
0x01x^4+0x0fx^3+0x36x^2+0x78x+0x40
# random 128 byte data の多項式
seed(0); G=oc.RS;α,P=G(2), oc.Pl([1,0], G); vc:=sum( ~[ g P^k for k,g in enumerate( randint(256, size=128) )])
===============================
0x45x^127+0x31x^126+0x30x^125+0x55x^124+0x75x^123+0x8dx^122+0xcfx^121+0x17x^120+0xbax^119+0xe3x^118+0x94x^117+0x8fx^116+0x4ex^115+0xe8x^114+0xb4x^113+0x64x^112+0xccx^111+0x83x^110+0xf4x^109+0x7fx^108+0x2fx^107+0xc4x^106+0x06x^105+0x44x^104+0xcbx^103+0x54x^102+0xaax^101+0x79x^100+0x8cx^99+0x35x^98+0x63x^97+0x8ex^96+0x80x^95+0x5bx^94+0x52x^93+0xaex^92+0x0bx^91+0x77x^90+0x66x^89+0x23x^88+0x39x^87+0xa9x^86+0xe7x^85+0x41x^84+0x01x^83+0x78x^82+0x1fx^81+0xbax^80+0x2ax^79+0x69x^78+0x84x^77+0x4fx^76+0x11x^75+0xf4x^74+0xe8x^73+0x26x^72+0x85x^71+0x35x^70+0xa4x^69+0x80x^68+0x80x^67+0x22x^66+0x1cx^65+0xb7x^64+0x72x^63+0xcbx^62+0xfex^61+0xa3x^60+0x97x^59+0xf4x^58+0xcax^57+0x1fx^56+0x20x^55+0x7fx^54+0xb9x^53+0x09x^52+0xc1x^51+0x20x^50+0xa7x^49+0x8ex^48+0x93x^47+0x93x^46+0x1dx^45+0xf3x^44+0xb1x^43+0xd8x^42+0x63x^41+0x52x^40+0xc0x^39+0xafx^38+0x4fx^37+0xfex^36+0xc5x^35+0xf3x^34+0xd0x^33+0x73x^32+0x94x^31+0x09x^30+0x48x^29+0x4dx^28+0x19x^27+0xa5x^26+0x51x^25+0x58x^24+0xaex^23+0x57x^22+0x27x^21+0xe6x^20+0xc1x^19+0x3ax^18+0x8cx^17+0x58x^16+0xd8x^15+0x46x^14+0x57x^13+0x24x^12+0xf2x^11+0x15x^10+0xd3x^9+0x09x^8+0x67x^7+0xc3x^6+0xfbx^5+0x43x^4+0xc0x^3+0x75x^2+0x2fx+0xac

copy _dt.pvl vc.pvl /y

# f(α^0) == f(α^1) == f(α^2) == f(α^3) == 0
seed(0); G=oc.RS;α,P=G(2), oc.Pl([1,0], G); =:vc; f=vc P^4 +  0x3dP^3+0x24P^2+0xe9P+0x02; [f(α^k) for k in range(10)]
===============================
[RS(0x00), RS(0x00), RS(0x00), RS(0x00), RS(0x89), RS(0x63), RS(0x5f), RS(0x26), RS(0x57), RS(0x77)]

seed(0); G=oc.RS;α,P=G(2), oc.Pl([1,0], G); =:vc; f=vc P^4 +  0x3dP^3+0x24P^2+0xe9P+0x02; f(α^0) == f(α^1) == f(α^2) == f(α^3) == 0
===============================
True

-->


<a name="■■ 置換群：Sn(N)"></a>
<h2>■■ 置換群：Sn(N)</h2>
<p>
置換群 Sn(N) を実装しました。ただし群論に詳しくない素人の愚直な実装であり、計算時間を短くする対策が入っていません。N が 10 を超えた Sn(N) 置換群全体を iterate 処理させると計算に何時間もかかってしまいます。でも N が 8 ぐらいまでならば Sn(8) 全部を実用的に iterate することもできます。これぐらいまでの処理でも多くの有限群の性質を確認できます。これならば学部での群論の勉強には十分だと考えています。
<p>
標準配布の sfCrrntIni.py には置換群インスタンスのクラス：Sb、巡回置換インスタンスを返す関数 Cy、置換群インスタンスを要素とする frozenset クラス：kfs(..)、群生成関数：grp(..) をグローバル変数として定義し直してあるので、PythonSf 式で直接に使えます。
また標準配布のディレクトリには置換群の集合インスタンス SS2,SS3,SS4,SS5、交代群の集合インスタンス SA3,SA4 のファイル変数を置いてあります。
これぐらい用意されていれば初等的な群論の検討には不便ないでしょう。
<p>
数学ソフトに詳しい方は「GAP を使えよ」と仰ると思います。同意します。複雑な群論の処理、大規模な対象を扱うときは GAP を使うべきです。でも Sn(8) ぐらいまでの小規模な群までならば、vim などから PythonSf 式で扱える Sb, Cy, ksf, grp のほうが便利です。以下の PythonSf 式による群の扱いを見てください。
<h3>Sn(N) 置換群と Sb, Cy, group kfs</h3>
<p>
以下有限置換群 Sn(N) を扱う Sb,Cy,group,kfs といったクラスや関数の詳細を見ていきます。
<h4>Sb 置換クラス</h4>
<p>
Sb(...) は 0 から n までの整数を並べ替えたシーケンスを引数に与えることで置換インスタンスを作ります。この並べ替えたシーケンス引数は、多変数引数として与えます。またリストあるいはタプル引数でも与えられます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# 多変数引数
Sb(1,3,2,0)
===============================
Sb(1,3,2,0)

# リスト引数
x=[1,3,2,0]; Sb(x)
===============================
Sb(1,3,2,0)

# タプル引数
x=(1,3,2,0); Sb(x)
===============================
Sb(1,3,2,0)
</span>
</code>
</pre>
<p>
Sb インスタンスどうしの掛け算と Sb インスタンスへの整数べき乗算が可能です。長さの異なる Sb インスタンスの積も可能です。下のような PythonSf 式として置換インスタンスの計算を扱えます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# Sb インスタンスどうしの積
a,b=Sb(1,3,2,0), Sb(3,0,2,1); a b
===============================
Sb(0,1,2,3)

# Sb インスタンスの 2 乗
Sb(1,3,2,0)^2
===============================
Sb(3,0,2,1)

# Sb インスタンスの -1 乗：逆元
Sb(1,3,2,0)^-1
===============================
Sb(3,0,2,1)

# Sb インスタンスの  2 乗
Sb(1,3,2,0)^-2
===============================
Sb(1,3,2,0)

# Sb インスタンスの  3 乗：単位元に戻る
Sb(1,3,2,0)^3
===============================
Sb(0,1,2,3)

# 異なる長さの Sb インスタンスの積
Sb(1,3,2,0) Sb(1,3,2,0,4)
===============================
Sb(3,0,2,1,4)

# 異なる長さの Sb インスタンスの積 2
Sb(1,3,2,0) Sb(1,4,2,0,3)
===============================
Sb(3,4,2,1,0)

# 巡回群リストの生成
a=Sb(1,3,2,0); [a^k for k in range(4)]
===============================
[Sb(0,1,2,3), Sb(1,3,2,0), Sb(3,0,2,1), Sb(0,1,2,3)]

# 長い Sb インスタンス
seed(0);Sb(shuffle(range(20)))
===============================
Sb(16,9,19,10,2,11,15,13,4,7,0,18,1,17,5,8,3,6,12,14)
</span>
</code>
</pre>
<h4>Cy 巡回置換関数</h4>
<p>
Cy(..) 関数は巡回置換 Sb(..) インスタンスを返します。Sb(..) のときとは違って、必要な整数の組み合わせだけを引数に与えれば済むので、置換群の PythonSf 式の記述が簡単になることが多くあります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
Cy(1,2,3)
===============================
Sb(0,2,3,1)

Cy(1,3)
===============================
Sb(0,3,2,1)

Cy(1,3) Sb(range(10))
===============================
Sb(0,3,2,1,4,5,6,7,8,9)

# cyclic 属性
Sb(16,9,19,10,2,11,15,13,4,7,0,18,1,17,5,8,3,6,12,14).cyclic
===============================
Cy(0,16,3,10) Cy(1,9,7,13,17,6,15,8,4,2,19,14,5,11,18,12)

Cy(0,16,3,10) Cy(1,9,7,13,17,6,15,8,4,2,19,14,5,11,18,12)
===============================
Sb(16,9,19,10,2,11,15,13,4,7,0,18,1,17,5,8,3,6,12,14)

# 巡回群と互換の積
(Cy(0,2) Cy(2,4) Cy(4,1) Cy(1,8)).cyclic
===============================
Cy(0,2,4,1,8)

# 巡回群と Sn(N)
# Sn(4) == group([Cy(0,1),Cy(1,2),Cy(2,3)}
=:SS4; SS4 == group([Cy(0,1),Cy(1,2),Cy(2,3)])
===============================
True
</span>
</code>
</pre>

<h4>集合クラス：kfs</h4>
<p>
Sb インスタンスを要素とする置換群の集合を扱うとき、その集合は frozenset の方が望ましいことが多くあります。関数で引き渡した先で変更されないことが保証されます。set のときのように copy/deep_copy に注意を払わなくて済むからです。そして置換要素の集合としての群は kfs:frozenset で扱うことに統一しておかないと、== 演算子での判断が面倒になってしまいます。
<p>
でも frozenset のスペルは PythonSf 式の one-liner 記述には長すぎます。そこで frozenset を継承した kfs クラスを設けました。ついでに kfs 集合の union(..) は + 演算子で可能にしました。kfs 集合の meet(..) は * 演算子で可能にしました。

<p>
ついでに frozenset を iterate するとき、その繰り返し順序が判らないと困ることが多いので sortedList:sl プロパティを設けて、sort 済みのリストを返すようにしました。これでデバッグが楽になります。ループ処理ごとに、どのインスタンスをを処理しているのかが判るからです。kfs(..) 集合をプリントするときも sorted 済みの結果で表示します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# Sb インスタンスよりなる kfs 集合の生成
kfs([Sb(0,1), Sb(2,1,0)])
===============================
kfs([Sb(0,1), Sb(2,1,0)])

# 巡回群集合の生成
a=Sb(1,3,2,0); kfs( [a^k for k in range(4)] )
===============================
kfs([Sb(0,1,2,3), Sb(1,3,2,0), Sb(3,0,2,1)])

# 集合の和：union
a=Sb(1,3,2,0); b,c=kfs( [a^k for k in range(4)] ), kfs([Sb(0,1), Sb(2,1,0)]); b+c
===============================
kfs([Sb(0,1), Sb(2,1,0), Sb(0,1,2,3), Sb(1,3,2,0), Sb(3,0,2,1)])

# 集合の積：meet
a=Sb(1,3,2,0); b,c=kfs( [a^k for k in range(4)] ), kfs([Sb(0,1), Sb(3,0,2,1)]); b*c
===============================
kfs([Sb(3,0,2,1)])
</span>
</code>
</pre>
<p>
ただし kfs クラスの要素にできるのは sort 可能なインスタンスに限られます。最後の結果をコンソールに質力するときに sort 作業がなされるからです。ですから整数・実数・複素要素値のベクトルや行列を要素とするkfs 集合は作れません。コンソールに出力するときの sorting でエラーになります。下のような具合です
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
kfs([~[1,2],~[3,4]])
===============================
The truth value of an array with more than one element is ambiguous. Use a.any() or a.all() at excecuting:kfs([krry__(*[1,2]),krry__(*[3,4])])

<b>PythonSf ブロック実行</b>
//@@
a=kfs([~[1,2],~[3,4]])
print a+5
//@@@
Traceback (most recent call last):
  File "__tempConverted.py", line 9, in <module>
    print a+5
  File "D:\my\vc7\mtCm\pysf\ptGrp.py", line 432, in __str__
    return "kfs(" + str(self.sl) + ")"
  File "D:\my\vc7\mtCm\pysf\ptGrp.py", line 357, in __getattr__
    return sorted((self))
ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
</span>
</code>
</pre>

<p>
置換群の集合インスタンス SS2,SS3,SS4,SS5、交代群の集合インスタンス SA3,SA4 のファイル変数を、標準配布のカレント・ディレクトリに置いてあります。 これらは kfs クラスのインスタンスです。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
=:SS3; SS3
===============================
kfs([Sb(0,1,2), Sb(0,2,1), Sb(1,0,2), Sb(1,2,0), Sb(2,0,1), Sb(2,1,0)])

=:SA3; SA3
===============================
kfs([Sb(0,1,2), Sb(1,2,0), Sb(2,0,1)])
</span>
</code>
</pre>
<p>
群論の剰余類・共役類などを扱うのを容易にするため、kfs 集合インスタンスと 置換要素との積を可能にしています。同様な意味で kfs 集合インスタンスと要素との和も可能にしています。もちろん置換群の kfs 集合インスタンスと置換群要素の和演算は無意味でありエラーになります。でも整数集合などでは意味がある分野もあるでしょう。次のような PythonSf 式計算ができます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# 置換集合と置換の積
a=Sb(1,3,2,0); SG=kfs( [a^k for k in range(4)] ); g=Sb(3,2,1,0); SG g 
===============================
kfs([Sb(0,2,3,1), Sb(1,2,0,3), Sb(3,2,1,0)])

# 共役集合の計算 1
a=Sb(1,3,2,0); SG=kfs( [a^k for k in range(4)] ); g=Sb(3,2,1,0); g SG g^-1 
===============================
kfs([Sb(0,1,2,3), Sb(2,1,3,0), Sb(3,1,0,2)])

# 共役集合の計算 2
a=Sb(1,3,2,0); SG=kfs( [a^k for k in range(4)] ); g=Sb(3,2,1,0); g^-1 SG g 
===============================
kfs([Sb(0,1,2,3), Sb(2,1,3,0), Sb(3,1,0,2)])

# 整数集合と整数の積
kfs([1,2,3]) 4
===============================
kfs([4, 8, 12])

# 整数とタプルの集合と整数の積
kfs([1,  (2,3)]) 4
===============================
kfs([4, (2, 3, 2, 3, 2, 3, 2, 3)])

# 整数集合と整数の積
kfs([1,2,3]) + 4
===============================
kfs([5, 6, 7])
</span>
</code>
</pre>
<p>
一つだけ kfs 要素が Sb インスタンスであることを前提としているのが / 演算子です。ksf 集合を、その部分集合で割ることで左剰余類群の集合を返します。この機能は kfs 要素が Sb 以外であると旨く働きません。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:SS3,SA3; SS3/SA3
===============================
kfs([Sb(0,1,2), Sb(0,2,1)])
</span>
</code>
</pre>

<h4>群生成関数：group(..)</h4>
<p>
group(..) 関数の引数に Sb インスタンスのリスト or タプル or セットを与えると、その Sb インスタンスたちによって生成される群の kfs 集合を返します。下のような PythonSf 式が使えます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# group({ Sb(1,0), Cy(range(N)}) による Sn(N) 置換群全体集合の生成
N=3; group({Sb(1,0),Cy(range(N))})
===============================
kfs([Sb(0,1,2), Sb(0,2,1), Sb(1,0,2), Sb(1,2,0), Sb(2,0,1), Sb(2,1,0)])

# group({ Sb(1,0), Cy(range(4)}) による置換群全体集合が Sn(4) であることの確認 
=:SS4; N=4; group({Sb(1,0),Cy(range(N))}) == SS4
===============================
True
</span>
</code>
</pre>
<p>
group(..) 関数は、全ての積の組み合わせで作られる集合を作ります。それにより集合の新たな要素が追加されなくなるまでリカーシブに新たに集合を作り直します。ですから Sn(N):N が 10 以上の長い Sb インスタンスを group(..) に渡してやると、それ返す集合要素数は n! となるかも知れません。そうなると一時間でも計算が終わらなくなるでしょう。ご注意ください。

<h3>交換子群</h3>
<p>
PythonSf 有限群論の最後に交換子群を実際に計算してみます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# SN(3) の交換子積の集合
SS=:SS3; {x y x^-1 y^-1 for x,y in mitr(SS,SS)}
===============================
set([Sb(0,1,2), Sb(1,2,0), Sb(2,0,1)])

# SN(3) の交換子群:交換子積の集合と同じ
SS=:SS3; group([x y x^-1 y^-1 for x,y in mitr(SS,SS)])
===============================
kfs([Sb(0,1,2), Sb(1,2,0), Sb(2,0,1)])

# SN(4) の交換子積の集合
SS=:SS4;   kfs([x y x^-1 y^-1 for x,y in mitr(SS,SS)])
===============================
kfs([Sb(0,1,2,3), Sb(0,2,3,1), Sb(0,3,1,2), Sb(1,0,3,2), Sb(1,2,0,3), Sb(1,3,2,0), Sb(2,0,1,3), Sb(2,1,3,0), Sb(2,3,0,1), Sb(3,0,2,1), Sb(3,1,0,2), Sb(3,2,1,0)])

# SN(4) の交換子群:交換子積の集合と同じ
SS=:SS4; group([x y x^-1 y^-1 for x,y in mitr(SS,SS)])
===============================
kfs([Sb(0,1,2,3), Sb(0,2,3,1), Sb(0,3,1,2), Sb(1,0,3,2), Sb(1,2,0,3), Sb(1,3,2,0), Sb(2,0,1,3), Sb(2,1,3,0), Sb(2,3,0,1), Sb(3,0,2,1), Sb(3,1,0,2), Sb(3,2,1,0)])

# SN(4) の交換子群は交代群：An(4) になる
SS=:SS4; =:SA4; group([x y x^-1 y^-1 for x,y in mitr(SS,SS)]) == SA4
===============================
True

# An(4) の交換子群
SS       =:SA4; group([x y x^-1 y^-1 for x,y in mitr(SS,SS)])
===============================
kfs([Sb(0,1,2,3), Sb(1,0,3,2), Sb(2,3,0,1), Sb(3,2,1,0)])
</span>
</code>
</pre>

<a name="■■ PythonSf を使った遊び"></a>
<h2>■■ PythonSf を使った遊び</h2>
<p>
PythonSf を使うということは、Ramanujan 級の計算能力を得られたということです。この能力を使えば様々の分野で数学を使った遊びが可能になります。以下、その遊びの幾つかを見ていきましょう。

<h3>PythonSf でおっぱい曲面</h3>
<code>
<span style="color: #9f009f;">
<b>元の Maxima の式</b>
<br>
plot3d((1/8)*(6*exp(-(((2/3)*abs(x) - 1)^2 + ((2/3)*y)^2) - (1/3)*((2/3)*y + (1/2))^3) + (2/3)*exp(-%e^11*( (abs((2/3)*x) - 1)^2 + ((2/3)*y)^2)^2) + (2/3)*y - ((2/3)*x)^4),
<br>
http://www.rainbowseeker.jp/xoops/modules/newbb/viewtopic.php?topic_id=369&forum=10&noreadjump=1

<br>
<br>
<b>PythonSf ワンライナー</b>
<br>
x,y,e=`X,`Y,exp(1); plot3dGr((1/8)*(6*exp(-(((2/3)*absF(x) - 1)^2 + ((2/3)*y)^2) - (1/3)*((2/3)*y + (1/2))^3) + (2/3)*exp(-e^11*( (absF((2/3)*x) - 1)^2 + ((2/3)*y)^2)^2) + (2/3)*y - ((2/3)*x)^4),klsp(-3,3,100))
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_oppai.jpg">
<br>
<p>
絶対値関数は Python に備わっている abs(..) 関数ではなく、PythonSf が用意している加減乗除べき乗算と関数合成が可能な absF(..) 関数を使います。
abs(..) 関数は python 文法に組み込まれており、これを呼び出すと引数オブジェクトの __abs__(self) method が呼び出されるからです。
<p>
なお左乳首が赤いのは意識してプログラムしたわけではありません。plot3dGr(..) は最初に出てくる最大値の位置に赤い丸を、最小値の位置に緑の丸を追加するため、左乳首の位置に赤い丸が置かれてしまいました。
<h3>Fermat's Last Theorem</h3>
<p>
<a href="http://ja.wikipedia.org/wiki/フェルマーの最終定理">フェルマーの最終定理</a>:「n>=3 のとき x^n+y^n=z^n を満たす 0 でない自然数の組み合わせは存在しない」という定理は有名です。近年この問題は肯定的に証明されたようですが、素人に解る証明ではないでしょう。
<p>
単純な別証明なんて作れませんが、x^n + y^n よりは小さいが できるだけ近い z^n は存在するはずです。その z^n と x^n+y^n の差分がどんな分布をしているのか見てみましょう。n=3 のとき その分布は下の PythonSf ワン・ライナー式で計算できます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
N,n=16 ,3; ls=range(N); krry([ [(x^n+y^n)-((x^n+y^n+10^-9)^(1/n)//1)^n for x in ls] for y in ls], int)
===============================
[[  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]
 [  0   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1]
 [  0   1   8   8   8   8   8   8   8   8   8   8   8   8   8   8]
 [  0   1   8  27  27  27  27  27  27  27  27  27  27  27  27  27]
 [  0   1   8  27   3  64  64  64  64  64  64  64  64  64  64  64]
 [  0   1   8  27  64  34 125 125 125 125 125 125 125 125 125 125]
 [  0   1   8  27  64 125  89  47 216 216 216 216 216 216 216 216]
 [  0   1   8  27  64 125  47 174 126  72  12 343 343 343 343 343]
 [  0   1   8  27  64 125 216 126  24 241 181 115  43 512 512 512]
 [  0   1   8  27  64 125 216  72 241 127   1 332 260 182  98   8]
 [  0   1   8  27  64 125 216  12 181   1 272 134 531 453 369 279]
 [  0   1   8  27  64 125 216 343 115 332 134 465 315 153 700 610]
 [  0   1   8  27  64 125 216 343  43 260 531 315  81 550 376 190]
 [  0   1   8  27  64 125 216 343 512 182 453 153 550 298  28 659]
 [  0   1   8  27  64 125 216 343 512  98 369 700 376  28 575 287]
 [  0   1   8  27  64 125 216 343 512   8 279 610 190 659 287 918]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
上の値分布は規則性を感じます。でも その規則を明晰には述べられません。N を 50 にまで広げて、その分布を三次元グラフとして表示してみましょう。
<p>
上の行列数値で感じたものに近い規則性があると思います。皆様は如何でしょうか。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
N,n=50,3; ls=range(N); renderMtrx(krry([ [(x^n+y^n)-((x^n+y^n+10^-9)^(1/n)//1)^n for x in ls] for y in ls], int))
</span>
</code>
</pre>
<img src="./jpg/1111/oneliners_fermas_last_theorem.jpg">
<br>
<h3>random 行列</h3>
<p>
[0,1] 区間上のランダム値を返す rand(..) 関数, 平均値 0 分散 1 の正規分布ランダム値を返す randn(..) 関数、指定された範囲の整数値を返す randint(..) は、行列データも返せるので、手軽に様々な数値実験が可能です。その幾つかを示してみます。直感とは異なることも幾つかあるでしょう。ぜひとも、御自分の手で、様々の別パラメータ値で再実験をしてみてください。
<h4>一次元の酔歩</h4>
<p>
1000 点の正規分布ノイズによる一次元の酔歩:Random Walk を下のように可視化できます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
#一次元の酔歩
N=1000; seed(0); lst=[0]; for v in randn(N):lst.append(lst[-1]+v); plotGr(lst)
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliner_1d_random_walk_normal.jpg">
<p>
上の図は株価変動に似ています。でもランダムなノイズによる Random Walk なのに変化に傾向性があるのが気になります。上の図を株価のグラフとして見せられたら、値下がりのトレンドにあると見なしてしまいます。
<p>
Numpy の random 関数に誤りがありトレンドが出やすくなっているのでしょうか。それとも本当にランダムであっても上のグラフ程度のトレンドは簡単に現れるものなのでしょうか。
<p>
分からんときに何かを変えてやると別の視点から見れることが多くあります。1000 点の一様ノイズによる一次元の酔歩:Random Walk を見てみましょう
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
N=1000; seed(0); lst=[0]; for v in rand(N)-0.5:lst.append(lst[-1]+v); plotGr(lst)
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliner_1d_random_walk_uniform.jpg">
<p>
より変動が激しくなりました。これでもトレンドが伺えます。
<p>
もっと自然なランダム・データを使って、トレンドが出てくるかみれば、上のトレンドのようなものがランダムなデータにも出てくるか見えてくるはずです。円周率 1000 桁をランダムなデータとして Random Walk を描かせて見ましょう。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ブロック</b>
//@@
strData=(
"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679"
+"8214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196"
+"4428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273"
+"7245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094"
+"3305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912"
+"9833673362440656643086021394946395224737190702179860943702770539217176293176752384674818467669405132"
+"0005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235"
+"4201995611212902196086403441815981362977477130996051870721134999999837297804995105973173281609631859"
+"5024459455346908302642522308253344685035261931188171010003137838752886587533208381420617177669147303"
+"5982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989" 
)

lst=[0]
#;; 4.5 == sum(range(10))/10
for ch in strData:lst.append(lst[-1]+int(ch)-4.5); plotGr(lst)
//@@@
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliner_1d_random_walk_circle_ratio.jpg">
<p>
円周率にランダムではないなんらかの傾向性があれば誰かが発表しているはずですが、そんな話は見られません。上の 1000 点の円周率のデータは、自然なランダム・データだと思ってよいでしょう。
<p>
この円周率データによる一次元の酔歩:Random Walk でもトレンドのようなものが見られます。どうも株価でトレンドといっているものにはランダムであることに起因する偶然なものも多くありそうです。
<p>
皆様も seed(.) の引数値を変えるなどしてランダム・データによるトレンドの具合の変化を、自分で体験してみてください。

<h4>二次元／三次元の酔歩</h4>
<p>
二次元、三次元の酔歩も容易に描けます。下のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 二次元の酔歩
N=1000; seed(0); lst=[~[0,0]]; for vc in randn(N,2):lst.append(lst[-1]+vc); plotTrajectory(lst)
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliner_2d_random_walk_normal.jpg">
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 三次元の酔歩
N=1000; seed(0); lst=[~[0,0,0]]; for vc in randn(N,3):lst.append(lst[-1]+vc); plotTrajectory(lst)
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliner_3d_random_walk_normal.jpg">
<p>
こんな図を見ていると、昔顕微鏡下の花粉の動きを生物としての動きと誤解したのも納得できます。

<h3>抵抗値のばらつき</h3>
<p>
民生用の電子機器で使っている抵抗の大多数が、 3σ で 5% の精度のものです。1kΩ の抵抗を 10 個持ってきたら、その抵抗値のばらつきは正規分布に従うはずであり、以下のような具合になるはずです。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
N=10; r,R=0.05, 1kΩ`; seed(0); R (1+ r/3 randn(N))
===============================
[ 1029.40087243  1006.66928681  1016.31229974  1037.34821999  1031.1259665
   983.71203534  1015.83480696   997.47737986   998.2796858   1006.84330837]
---- ClTensor ----
</span>
</code>
</pre>
<p>
ちなみに 5% 以上の誤差になるものは、1000 個の抵抗のうちで 2 個ぐらいです。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
N=1000; r,R=0.05, 1kΩ`; vc=R (1+ r/3 randn(N)); len([ x for x in vc if x&lt;0.95R or 1.05R&lt;x])
===============================
2
</span>
</code>
</pre>
10% 以上の誤差になるものは1000000 個の抵抗持ってきても 0 個です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
N=1000000; r,R=0.05, 1kΩ`; vc=R (1+ r/3 randn(N)); len([ x for x in vc if x&lt;0.9 R or 1.1 R&lt;x])
===============================
0
</span>
</code>
</pre>
<p>
以上の計算より、5% 3σ 精度の抵抗値は、500 個に一個程度 5% を超えるものがある。でも 100 万個の抵抗をもってきても 10% を超える誤差のものは出てこないといえます。
<p>
ちなみに、5% 抵抗を合成してやると、抵抗の誤差同士が打ち消しあって より少ない抵抗値のばらつきになります。
<p>
下の回路の合成抵抗値は並列接続で半分になり直接接続で倍になるので、全体としては　1kΩ　に戻ります。
<pre>
           1kΩ               1kΩ 
       ┌─WMWM─┐      ┌─WMWM─┐
   ──┤        ├───┤        ├─
       │  1kΩ  │      │  1kΩ  │      
       └─MWMW─┘      └─MWMW─┘
</pre>
<p>
この回路の抵抗値 1kΩ のばらつき具合：標準偏差は下のようにシミュレーション計算できます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
N=1000; r,R=0.05, 1kΩ`; seed(0); vc=[ (vc1~+vc2)+(vc3~+vc4) for vc1,vc2,vc3,vc4 in R (1+ r/3 randn(N,4))]; sqrt( sum([ (x-sum(vc)/N)^2 for x in vc ])/(N-1) )<br>
===============================<br>
8.31846294487<br>
</span>
</code>
<p>
元の標準偏差 1kΩ, 5%, 3σ から定まる抵抗値のばらつきぐあい 50/3 の半分程度のばらつきぐあいになりました。

<h3>四次元立方体の三次元への投影図</h3>
<p>
「四次元立方体を三次元に射影する」ことを PythonSf で行います。でも最初からでは難しいので「三次元立方体を二次元に射影する」ことを行ってから、それを四次元に拡張する手順を踏みます。
<p>
PythonSf での one-liners を使って思考の螺旋階段を上っていく様子がよく分かる例だと思います。

<h4>三次元立方体を二次元に射影する</h4>
<p>
三次元立方体の頂点は下の PythonSf 式で表現できます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
# 三次元立方体の頂点<br>
ls=[-1,1]; [ ~[x,y,z] for x,y,z in mitr(ls,ls,ls)]<br>
===============================<br>
[ClTensor([-1., -1., -1.]), ClTensor([-1., -1.,  1.]), ClTensor([-1.,  1., -1.]), ClTensor([-1.,  1.,  1.]), ClTensor([ 1., -1., -1.]), ClTensor([ 1., -1.,  1.]), ClTensor([ 1.,  1., -1.]), ClTensor([ 1.,  1.,  1.])]<br>
</span>
</code>
<p>
下の one-liner の方が、八個の頂点が分かりやすいですね。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 2^3:八個の頂点
ls=[-1,1]; ~[ [x,y,z] for x,y,z in mitr(ls,ls,ls)]
===============================
[[-1. -1. -1.]
 [-1. -1.  1.]
 [-1.  1. -1.]
 [-1.  1.  1.]
 [ 1. -1. -1.]
 [ 1. -1.  1.]
 [ 1.  1. -1.]
 [ 1.  1.  1.]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
座標軸の原点一箇所から放出される光線が立方体の各頂点を通って平面と交わる点を求めることで、立方体を平面に射影できます。そのため Z 軸に垂直な射影される平面を想定します。その Z 軸との交点は 12 の位置にあるものとしましょう。
<p>
原点一箇所から放出される光線が、上で作った立方体の八個の頂点を通って平面に射影されるよう、 その立方体をZ 軸方向に 6 だけ平行移動させます。下の PythonSf 式を使って、カレント・ディレクトリの mt.pvl ファイルに、その頂点の座標値を残します。
。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
ls=[-1,1]; mt:= ~[ ~[x,y,z] for x,y,z in mitr(ls,ls,ls)]+ ~[0,0,6]
===============================
[[-1. -1.  5.]
 [-1. -1.  7.]
 [-1.  1.  5.]
 [-1.  1.  7.]
 [ 1. -1.  5.]
 [ 1. -1.  7.]
 [ 1.  1.  5.]
 [ 1.  1.  7.]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
[0,0,0] 原点から放射された光線が、上で求めた八つの頂点を通って、上で想定した Z 軸に垂直な平面で交わったと想定し、その平面と直線の交点座標を求めましょう。
<p>

「Z 軸に直行し [0,0,12] で交わる平面」と「原点と ~[x,y,z] 点を通った直線」が交わる点の座標を求めます。
<pre>
<code>
(t ~[x,y,z])[2] == 12  for ∃t
t z == 12
∴
t = 12/z    for z ∈ {5,7}

ゆえに平面との交点の座標は下の PythonSf 式で計算できる
12/z ~[x,y,z]
</code>
</pre>

<p>
具体例で再度考えましょう。「Z 軸に直行し [0,0,12] で交わる平面」と「原点と ~[-1,-1,7] 点を通った直線」が交わる点の座標は次の PythonSf 式で求められます。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
12/7 ~[-1,-1,17]
===============================
[ -1.71428571  -1.71428571  29.14285714]
---- ClTensor ----
</span>
</code>
</pre>
<p>
ですから、上で作った立方体の八つの頂点を通る、座標軸の原点から射出されて光線は下の八つの点で平面と交わります。この点は mt2dCube の名前のファイル変数で保存します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:mt; mt2dCube:=~[ v 12/v[2] for v in mt]
===============================
[[ -2.4         -2.4         12.        ]
 [ -1.71428571  -1.71428571  12.        ]
 [ -2.4          2.4         12.        ]
 [ -1.71428571   1.71428571  12.        ]
 [  2.4         -2.4         12.        ]
 [  1.71428571  -1.71428571  12.        ]
 [  2.4          2.4         12.        ]
 [  1.71428571   1.71428571  12.        ]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
ファイル変数 mt, mt2dCube それぞれ八つの座標位置を人間に分かりやすいように、下の PytthonSf 式を使って図示します。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
mt,mt2=:mt,mt2dCube; for v0,v1 in combinate(mt,2):plotTrajectory([v0,v1]); for v0,v1 in combinate(mt2,2):plotTrajectory([v0,v1],color=red);
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_projection_of_cubic2plane.jpg">
<br>
<p>
上の図で赤い部分が立方体の射影図です。

<h4>四次元立方体を三次元に射影する</h4>
<p>
三次元の立方体を平面に射影することと殆ど同様に、四次元立方体を四次元の超平面：三次元空間に射影できます。
<p>
四次元立方体の 2^4:16 個の頂点を、第４の 軸方向に 6 だけ平行移動させたときの頂点の座標をファイル変数 mt に残します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
ls=[-1,1]; mt:= ~[ ~[x,y,z,t] for x,y,z,t in mitr(ls,ls,ls,ls)]+ ~[0,0,0,6]
===============================
[[-1. -1. -1.  5.]
 [-1. -1. -1.  7.]
 [-1. -1.  1.  5.]
 [-1. -1.  1.  7.]
 [-1.  1. -1.  5.]
 [-1.  1. -1.  7.]
 [-1.  1.  1.  5.]
 [-1.  1.  1.  7.]
 [ 1. -1. -1.  5.]
 [ 1. -1. -1.  7.]
 [ 1. -1.  1.  5.]
 [ 1. -1.  1.  7.]
 [ 1.  1. -1.  5.]
 [ 1.  1. -1.  7.]
 [ 1.  1.  1.  5.]
 [ 1.  1.  1.  7.]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
第四の軸に直行し [0,0,0,12] で交わる超平面に、原点と立方体の頂点を通る直線が交わる座標を求め、ファイル変数 mt3dCube に残します。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:mt; mt3dCube:=~[ v 12/v[3] for v in mt]
===============================
[[ -2.4         -2.4         -2.4         12.        ]
 [ -1.71428571  -1.71428571  -1.71428571  12.        ]
 [ -2.4         -2.4          2.4         12.        ]
 [ -1.71428571  -1.71428571   1.71428571  12.        ]
 [ -2.4          2.4         -2.4         12.        ]
 [ -1.71428571   1.71428571  -1.71428571  12.        ]
 [ -2.4          2.4          2.4         12.        ]
 [ -1.71428571   1.71428571   1.71428571  12.        ]
 [  2.4         -2.4         -2.4         12.        ]
 [  1.71428571  -1.71428571  -1.71428571  12.        ]
 [  2.4         -2.4          2.4         12.        ]
 [  1.71428571  -1.71428571   1.71428571  12.        ]
 [  2.4          2.4         -2.4         12.        ]
 [  1.71428571   1.71428571  -1.71428571  12.        ]
 [  2.4          2.4          2.4         12.        ]
 [  1.71428571   1.71428571   1.71428571  12.        ]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
四次元での超平面：すなわち三次元空間に射影された四次元立方体の三次元図を下の PythonSf 式で描きます。

<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
mt=:mt3dCube; [plotTrajectory([v0[:3],v1[:3]])for v0,v1 in combinate(mt,2) if norm(v0-v1)~==4.8  or norm(v0-v1)~==(2*1.71428571)]
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_projection_of_cubic3plane.jpg">
<br>
<p>
五次元立方体を四次元超平面に射影し、その四次元立体をさらに三次元空間に射影したときの頂点の位置も次の PythonSf 式で描けます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
ls=[-1,1]; mt= ~[ v for v in mitr(*[ls]*5)]+ ~[0,0,0,0,6];mt=~[ v 12/v[4] for v in mt][:,:-1]+[0,0,0,6]; mt=~[ v 12/v[3] for v in mt][:,:-1];plotPt(mt); drawAxis()
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_projection_of_cubic5point1.jpg">
<br>
<br>
<img src="./jpg/1111/oneliners_projection_of_cubic5point2.jpg">
<br>
<p>
こんな図形は自分の手で回転させ様々の方向から見てみないと分かりにくいと思います。ぜひ上の one-liner で御自分のコンピュータで動かしマウスで動かしてみてください。
<p>
ここで行った立方体を平面に、四次元立方体を三次元に射影する PythonSf 式たちは、プログラム・コードを書いているのではなく、数式を書き連ねていると言ったほうが近いと思います。プログラム・コード記述の苦しさが殆どありません。面倒なプログラム・デバッグもありません。数学思考に集中できます。途中までの計算結果を見ながら PythonSf 式を書き連らねているだけです。

<a name="■■ 正規表現"></a>
<h2>■■ 正規表現</h2>
<p>
Python の正規表現は使いにくすぎます。Perl でのような正規表現を使いまくるコードを書く気にはなれません。正規表現をコンパイルしてから チェックする文字列に match(...) させ group(..) で取り出すなんて面倒なことをしてられません。そこで kre.py 正規表現改良モジュールを作りました。正規表現にマッチング・インスタンスを「対象文字列 / 正規表現」と割り算演算子で返すようにしました。部分文字列を「%(序数)」mod 演算子で返すようにしました。「対象文字列 / 正規表現%0」で正規表現にマッチした文字列を返すようにしました。
<p>
PythonSf では krgl('正規表現文字列') でコンパイル済みの正規表現インスタンスを作ります。これで対象文字列を割ってやれば、正規表現処理されたマッチング・インスタンスができます。これを %0 でわれば、マッチする文字列が帰ります。次のような具合です。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
'abcdefg'/krgl('[c-e]*')%0
===============================
cde

'abcdefghijkl'/krgl('([c-e]*).*([g-i]+)')%0
===============================
abcdefghi

'abcdefghijkl'/krgl('([c-e]+).*([g-i]+)')%1
===============================
cde

'abcdefghijkl'/krgl('([c-e]*).*([g-i]+)')%2
===============================
i
</span>
</code>
</pre>
<p>
PythonSf 正規表現クラス krgl を使えばワンライナーで実用的なことが様々にできます。次のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# pysf ディレクリとにあるファイルのうち k で始まるファイル名のものを列挙します
rg,wlk=krgl('^k'),os.walk('./pysf'); `print( [(path,[f for f in files if f/rg%0]) for path,dir,files in wlk] )
[('./pysf',
  ['kcommon.py',
   'kcommon.pyc',
   'kmayavi.py',
   'kmayavi.pyc',
   'kmayaviPy.bak',
   'kNumeric.bak',
   'kNumeric.py',
   'kNumeric.pyc',
   'kNumericPy.bak',
   'kre.py',
   'kre.pyc'])]
===============================
None

# PythonSf の実行時に定まっているグローバル変数の中から plot で始まるものを列挙する
# PythonSf のグローバル変数で不正確に記憶している名称を探すのに便利です
rg=krgl('^plot'); [ s for s in globals().keys() if s/rg%0]
===============================
['plot3dGr', 'plotTmCh', 'plot3d', 'plotPt', 'plotBode', 'plotTrajectory', 'plot2d', 'plot3dRowCol', 'plotGr', 'plotDgGnPh']

# SymPy モジュールのグローバル変数全体から fact を含むものを列挙する
# kre.se.I 引数を追加することで大文字／小文字を区別させない
import sympy as md; rg=krgl('fact',kre.se.I); [ s for s in vars(md).keys() if s/rg%0]
===============================
['factorint', 'factorial2', 'cofactors', 'factorial', 'factor_', 'factor', 'factortools', 'FallingFactorial', 'primefactors', 'factor_list', 'RisingFactorial', 'facts']
</span>
</code>
</pre>
<p>
このように kre.py の正規表現クラス krgl 使えば、 Perl でのような正規表現の活用の仕方が可能になります。
<!--
rg=krgl('^m'); [ s for s in globals().keys() if s/rg%0]

rg=krgl('^render'); [ s for s in globals().keys() if s/rg%0]

rp3=λ x:norm(x[:2])^2;mt=kOde(λ *x:[x[2],x[3],-x[0]/rp3(x),-x[1]/rp3(x)], [1,0, 0,1.2], 50s`,1000)[:,:2]; plotTrajectory(zip(mt[:,0],mt[:,1]))
rp3=λ x:norm(x[:2])^3;mt=kOde(λ *x:[x[2],x[3],-x[0]/rp3(x),-x[1]/rp3(x)], [1,0, 0,1.2], 50s`,1000)[:,:2]; plotTrajectory(zip(mt[:,0],mt[:,1]))
<== [-x/r^3, -y/r^3] であり、1/r^2 に比例する引力
rp3=λ x:norm(x[:2])^2.5;mt=kOde(λ *x:[x[2],x[3],-x[0]/rp3(x),-x[1]/rp3(x)], [1,0, 0,1.2], 50s`,1000)[:,:2]; plotTrajectory(zip(mt[:,0],mt[:,1]))
-->`
<a name="■■ PythonSf Octernion と Cayley/Dickson construction"></a>
<h2>■■ PythonSf Octernion と Cayley/Dickson construction</h2>
<p>
PythonSf では Oc(...) を使うことで、四元数、八元数を扱えます。Cayley/Dicson 構成法：八元数操作を Zp(N) 有元体に適用してやることで、非可換または結合率の成り立たない有限代数系が使えるようになります。
<p>
PythonSf には八元数:Octornion:oc.Oc を備えており、非可換な代数での挙動、結合率さえ成り立たない代数での挙動を簡単にコンピュータ上で実行させ試してみることができりす。八元数 oc.Oc だといっても、上側の数値が 0 のときは、それを表示しないので、引数を四つ以下に限定にしてやれば quaternion としての動作になります。引数を二つ以下に限定してやれば複素数の動作になります。

<pre>
<code>
<span style="color: #9f009f;">
Oc(1,2,3,4,5) Oc(5,0,7)
===============================
Oc(-16, -18, 22, 34, 25, 0, -35, 0)

Oc(1,2,3,4) Oc(5,6,7,8)
===============================
Oc(-60, 12, 30, 24)

Oc(1,2    ) Oc(5,6    )
===============================
Oc(-7, 16)
</span>
</code>
</pre>
<p>
この oc.Oc の八元数演算の実装は、愚直に積と和の組み合わせ演算だけでなされています。ですから oc.Oc に 実数以外の体インスタンスを渡してやれば、その一般体の上で、八元数の加減乗除算が実行されてしまいます。すなわち一般体複素数、一般体四元数、一般体八元数の演算が行われるように代数系を拡張できてしまいます。
<p>
体の八元数化による体代数系の拡張は<a href="http://en.wikipedia.org/wiki/Cayley?Dickson_construction">Cayley_Dickson_construction
</a>,<a href="http://ja.wikipedia.org/wiki/ケーリー＝ディクソンの構成法">「ケーリー＝ディクソンの構成法」として知られています。</a>
<p>
ケーリー＝ディクソンの構成法の良いところは拡張された代数系の挙動の予測が付けやすいことです。足し算については、元の体代数系のベクトル足し算になります。積演算については、四元数にしてやることで非可換な代数系が得られます。八元数にしてやることで結合律さえ成り立たない代数系が得られます。
<p>
このケーリー＝ディクソンの構成法を Zp(N) に適用してやれば、簡単に非可換であったり結合律が成り立たない有限な代数系を作れます。そして有限：小規模な代数系ならばコンピュータで虱潰しに調べ上げられるので便利です。といっても、実際にそのようなプログラムを 0 から作り上げるのは普通の人間では月単位の仕事になってしまうでしょう。でも PythonSf ならば八元数の要素を Zp(N) 要素にしてやるだけで、それを実装できしまいます。
<p>
ClOctonion による「ケーリー＝ディクソンの構成法」の適用は、まだ実験的な実装段階です。Compatibility のない仕様変更が将来なされる可能性があります。
<!--
ただし、この代数系の拡張は Python の duck typing の上で動いてしまっている実装になっています。加減乗除べき乗算を Zp(N) 側で行うのか、Octonion 側で行うのかは実装に依存します。八元体のクラス実装がよほど旨くないと、八元数のクラスと一般体のクラスを直行的に組み合わせるようなことは、どこかで問題を起こします。理想を言えば Caley-Dickson 構成法だけをとりだし Monad として実装しておき、任意の Ring と組み合わせられるようにしておくべきです。その Cayley-Dicson Monad には自然数構造を備えなければなりません。自然数との加減乗算とべき乗算を備えなければなりません。そこまでやっても、使いこなせる方が どれぐらいいるのか？ 実際には Zp(N) 側で Octonion に合わせた加減乗除算にしてやらねばなりません。PythonSf の Zp(N) は、そのような Octonion に合わせた実装になっています。それ以外の代数系についても ケーリー＝ディクソンの構成法を適用できるようにするためには注意深い見直しが必要です。Coverage100% のテストぐらいは必須です。まだ その段階にありません。
-->
<h5>O3:Z3 四元数</h5>
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 非可換な例
O3(1,2,3,0) O3(2,1,0,1)
===============================
Oc(0, 2, 1, 1)

O3(2,1,0,1) O3(1,2,3,0)
===============================
Oc(0, 2, 2, 1)

# 非可換な例を虱潰しに挙げる
lst=[0,1,2]; mi=list( mitr(*([lst]*4)) ); [(tpL,tpR) for tpL,tpR in mitr(mi,mi) if O3(tpL) O3(tpR) != O3(tpR) O3(tpL)]
たくさん
# 可換な例を虱潰しに挙げる
lst=[0,1,2]; mi=list( mitr(*([lst]*4)) ); [(tpL,tpR) for tpL,tpR in mitr(mi,mi) if O3(tpL) O3(tpR) == O3(tpR) O3(tpL)]
たくさん

# 積演算の逆元
1/O3(1,0,2,3) 
===============================
(2, 0, 2, 0)
# 逆元が存在しない例
1/O3(1,1,2,3) 
    snipped
ZeroDivisionError: Square value is 0 at ClOctonion:inv().

# ゼロ因子の例
O3(0,1,1,1) O3(2,0,1,2)
===============================
0
# ゼロ因子を虱潰しに挙げる
# λ x: O3(0,1,1,1) x の Kernel
#     積の単位元は含まれていない
ls=range(3); [ tpl for tpl in mitr(*[ls]*4) if O3(0,1,1,1) O3(tpl) == 0]
===============================
[(0, 0, 0, 0), (0, 1, 1, 1), (0, 2, 2, 2), (1, 0, 2, 1), (1, 1, 0, 2), (1, 2, 1, 0), (2, 0, 1, 2), (2, 1, 2, 0), (2, 2, 0, 1)]

# λ x: O3(0,1,1,1) x の Kernel は積演算について閉じている
ls=range(3); lst=[ tpl for tpl in mitr(*[ls]*4) if O3(0,1,1,1) O3(tpl) == 0]; [ O3(x) O3(y) in lst for x,y in mitr(lst,lst)]
===============================
[True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]

# λ x: O3(0,1,1,1) x の Kernel は和演算について閉じている
ls=range(3); lst=[ tpl for tpl in mitr(*[ls]*4) if O3(0,1,1,1) O3(tpl) == 0]; [ O3(x)+O3(y) in lst for x,y in mitr(lst,lst)]
===============================
[True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]

# この小さい環の世界でも非可換性は残っている
ls=range(3); lst=[ tpl for tpl in mitr(*[ls]*4) if O3(0,1,1,1) O3(tpl) == 0]; [ O3(x) O3(y) == O3(y) O3(x)in lst for x,y in mitr(lst,lst)]
===============================
[True, True, True, True, True, True, True, True, True, True, True, True, False, False, False, False, False, False, True, True, True, False, False, False, False, False, False, True, False, False, True, False, False, True, False, False, True, False, False, False, True, False, False, False, True, True, False, False, False, False, True, False, True, False, True, False, False, True, False, False, True, False, False, True, False, False, False, False, True, False, True, False, True, False, False, False, True, False, False, False, True]


</span>
</code>
</pre>

<h5>O3,O5 圏論操作</h5>
<p>
下の fO5toO3 は O5 から O3 への自然変換とみなせる
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
fO5toO3 = fCT(λ x:O3(x.m_tpl), O5, O3); fO5toO3(O5(1,2,3,4)) 
===============================
(1, 2, 0, 1)

fO5toO3 = fCT(λ x:O3(x.m_tpl), O5, O3); fO5toO3.dom, fO5toO3.cod
===============================
((<class 'sfCrrntIni.O5'>,), (<class 'sfCrrntIni.O3'>,))

fO5toO3 = fCT(λ x:O3(x.m_tpl), O5, O3); fO5toO3(O3(1,2,6,4)) 
Traceback (most recent call last):
  File "C:\Python27\lib\runpy.py", line 162, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "C:\Python27\lib\runpy.py", line 72, in _run_code
    exec code in run_globals
  File "D:\my\vc7\mtCm\sfPP.py", line 2, in <module>
    pysf.sfPPrcssr.start()
  File "pysf\sfPPrcssr.py", line 2739, in start
    __execLine( (" ".join(sys.argv[1:])).strip() )
  File "pysf\sfPPrcssr.py", line 2355, in __execLine
    valStt = eval(ustConvertedAt, globals(), locals() )
  File "<string>", line 1, in <module>
  File "sfCrrntIni.py", line 155, in _
    + str(sqAg[k])
  File "sfCrrntIni.py", line 37, in Assert
    raise sf.ClAppError(strAg)
pysf.sfFnctns.ClAppError: Error at CT:__call__(..) input type check:(1, 2, 0, 1)


</span>
</code>
</pre>
<p>
product, sum も非自明な自然変換に使える
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
sum(O3(1,2,3,4))
===============================
1
product(O3(1,2,3,4))
===============================
0

product(O3(1,2,1,4))
===============================
0
<== 八元数での product になっている。下のようにせねばならない。

product(O3(1,2,1,4)[:4])
===============================
2

</span>
</code>
</pre>
<h5>Z3 八元数</h5>
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 結合律が成り立たない整数八元数の例
O=oc.Oc; a,b,c=O(1,2,3,4,5),O(2,1,4,5,6),O(3,4,1,6,7); str((a b) c), str(a (b c))
===============================
('(-426, -279, 12, -323, -366, -4, 52, 12)', '(-426, -279, 12, -323, -366, -12, 44, -28)')

# 結合律が成り立たない Zp(3) 八元数の例
O=oc.Oc; a,b,c=O(~[1,2,3,4,5,Z3]),O(~[2,1,4,5,6,Z3]),O(~[3,4,1,6,7,Z3]); str((a b) c), str(a (b c))
===============================
('(0, 0, 0, 1, 0, 2, 1, 0)', '(0, 0, 0, 1, 0, 0, 2, 2)')
</span>
</code>
</pre>

<a name="■■ Category Theory"></a>
<h2>■■ Category Theory</h2>
<p>
標準配布のカレント・ディレクトリの sfCrrntIni.py ファイルには圏論を扱うための dom, cod を扱えるようにする CT クラス、関数 fCT(..) が実装されています。圏論で頻出する monoid 構造を扱うため：即ち二項関数を扱うための関数 f2CT(..) も設けてあります。また~% user 演算子を関数合成操作に割り当ててあります。さらに Z2,Z3,Z4,Z5,Z5 有限体クラス、 O2,O3,O4,O5,O7 有限八元数クラスを設けてあり、圏論における様々の実例を実際に計算できる PythonSf one-liner 式で表現できます。
<h3>CT: a class defining input parameter types and output parameter types</h3>
<p>
クラス CT は関数の入出力パラメータのタイプを指定するクラスです。Python でも、C や Java 言語での float function(int) のような、関数の型指定を可能にします。CT(int,float) で int 引数の float 出力の関数型指定を行うクラスのインスタンスを作ります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
CT(int, float)
===============================
<sfCrrntIni.CT object at 0x0222EDD0>
</span>
</code>
</pre>
<p>
このインスタンスに対し関数を渡してやると、int 引数を与えて、float 結果を返すことを確認する作業が追加された関数を返します。int を与えて float が返る動作をしているときは、下のように普通の動作をします。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
ct=CT(int, float); f=ct(λ x:x+1.5); f(3)
===============================
4.5
</span>
</code>
</pre>
<p>
でも、入力パラメータまたは出力結果の型が指定と異なるとき、次のように例外が発生します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
ct=CT(int, float); f=ct(λ x:x+1.5); f(3.1)
Traceback (most recent call last):
  File "C:\Python27\lib\runpy.py", line 162, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "C:\Python27\lib\runpy.py", line 72, in _run_code
    exec code in run_globals
  File "D:\my\vc7\mtCm\sfPP.py", line 2, in <module>
    pysf.sfPPrcssr.start()
  File "pysf\sfPPrcssr.py", line 2741, in start
    __execLine( (" ".join(sys.argv[1:])).strip() )
  File "pysf\sfPPrcssr.py", line 2357, in __execLine
    valStt = eval(ustConvertedAt, globals(), locals() )
  File "<string>", line 1, in <module>
  File "sfCrrntIni.py", line 230, in _
    + str(sqAg[k])
  File "sfCrrntIni.py", line 85, in Assert
    raise sf.ClAppError(strAg)
pysf.sfFnctns.ClAppError: Error at CT:__call__(..) input type check:3.1
</span>
</code>
</pre>
<p>
入力引数や戻り値の型は、リストで型を指定することで複数の引数値に対応させます。また型指定には集合や True/False 値を返す関数を使うことも可能です。下のような具合です
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
ct=CT([int, float,{7,8,9},λ x:isinstance(x,complex)], complex); f=ct(λ x,y,z,t:x+y+z+6+1.5j); f(3,4.1, 7, 2j)
===============================
(20.1+1.5j)

ct=CT([int, float,{7,8,9},λ x:isinstance(x,complex)], complex); f=ct(λ x,y,z,t:x+y+z+6+1.5j); f(3,4.1, 5, 2j)
Traceback (most recent call last):
  File "C:\Python27\lib\runpy.py", line 162, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "C:\Python27\lib\runpy.py", line 72, in _run_code
    exec code in run_globals
  File "D:\my\vc7\mtCm\sfPP.py", line 2, in <module>
    pysf.sfPPrcssr.start()
  File "pysf\sfPPrcssr.py", line 2741, in start
    __execLine( (" ".join(sys.argv[1:])).strip() )
  File "pysf\sfPPrcssr.py", line 2357, in __execLine
    valStt = eval(ustConvertedAt, globals(), locals() )
  File "<string>", line 1, in <module>
  File "sfCrrntIni.py", line 230, in _
    + str(sqAg[k])
  File "sfCrrntIni.py", line 85, in Assert
    raise sf.ClAppError(strAg)
pysf.sfFnctns.ClAppError: Error at CT:__call__(..) input type check:5
、その constructor で
</span>
</code>
</pre>
<p>
上の CT クラスによる型指定機能は、圏論の dom/cod を明示するのに役立ちます。でもワン・ライナーで使うには CT クラスのインスタンスを毎度作らねばならず面倒です。なので下のような fCT(...) 関数を設けてあります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.source(fCT)
In file: sfCrrntIni.py

def fCT(f, inputTypeOrSqTypeAg=None, outTypeAg=None):
    ctAt = CT(inputTypeOrSqTypeAg, outTypeAg)
    return ctAt(f)

===============================
None
</span>
</code>
</pre>
<p>
下のように使います。ちなみに type がデフォルトの None で指定されているときは、型チェックを行わないことを意味します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
f=fCT(λ x:x+1, Z3); f(Z3(2))
===============================
Z3(0)

f=fCT(λ x:x+1.5, int); f(0)
===============================
1.5
</span>
</code>
</pre>
<p>
圏論で頻出する monoid のために二項関数の型指定を行う f2CT(..) も sfCrrntIn.py に実装しています。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.source(f2CT)
In file: sfCrrntIni.py

def f2CT(f, ty=None, tyOut=None):
    # comment
    if ty==None and tyOut==None:
        return fCT(f,[None,None],tyOut)
    elif ty!=None and tyOut==None:
        return fCT(f, [ty,ty], ty)
    else:
        # ty!=None and tyOut!=None:
        return fCT(f, [ty,ty], tyOut)

===============================
None
</span>
</code>
</pre>
<p>
下のように使います。ちなみに f2CT(..) のときは、戻り値の型をデフォルト None のままにしておくことは、戻り値の型が入力値の型と同じであることを意味しています。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
f=f2CT(λ x,y:x+y, Z3); f(Z3(1), Z3(2))
===============================
Z3(0)

f=f2CT(λ x,y:x+y, Z3); f.dom, f.cod
===============================
((<class 'sfCrrntIni.Z3'>, <class 'sfCrrntIni.Z3'>), (<class 'sfCrrntIni.Z3'>,))

f=f2CT(λ x,y:x+y+0.5, int, float); f(1, 2)
===============================
3.5

f=f2CT(λ x,y:x+y, int, float); f(1, 2)
Traceback (most recent call last):
  File "C:\Python27\lib\runpy.py", line 162, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "C:\Python27\lib\runpy.py", line 72, in _run_code
    exec code in run_globals
  File "D:\my\vc7\mtCm\sfPP.py", line 2, in <module>
    pysf.sfPPrcssr.start()
  File "pysf\sfPPrcssr.py", line 2741, in start
    __execLine( (" ".join(sys.argv[1:])).strip() )
  File "pysf\sfPPrcssr.py", line 2357, in __execLine
    valStt = eval(ustConvertedAt, globals(), locals() )
  File "<string>", line 1, in <module>
  File "sfCrrntIni.py", line 256, in _
    + str(valAt)
  File "sfCrrntIni.py", line 85, in Assert
    raise sf.ClAppError(strAg)
pysf.sfFnctns.ClAppError: Error at CT:__call__(..) output type check:3
</span>
</code>
</pre>
<p>
CT クラスを使って関数の入出力型を指定できることは、圏論の dom/cod を明示する意味で便利です。でも C/C++/Java でのように、プログラム全体に渡る整合性の確認を行わせる型指定の便利さまでは享受できません。Python では全ての関数で型指定・チェックが行われるわけではないからです。CT に過度に期待すべきではありません。また圏論での PythonSf 式による検討で、型チェックを行わずに済ますことも多くあります。
<p>
圏論の議論では Curry 化関数になっている CT クラスの fst,lst メンバーのほうが、型指定よりも便利に使えるかもしれません。fst は最初の引数の、lst は最後の引数の Curry 化関数です。次のように使います。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
f=f2CT(λ x,y:x+2y, Z3); [f.fst(Z3(1))(Z3(x)) for x in range(5)]
===============================
[1, 0, 2, 1, 0]

f=f2CT(λ x,y:x+2y, Z3); [f.lst(Z3(1))(Z3(x)) for x in range(5)]
===============================
[2, 0, 1, 2, 0]
</span>
</code>
</pre>
<p>
圏論で頻出する関数合成のために sfCrrntIni.py で、ユーザー演算子：~%　に関数合成の機能をアサインしてあります。下のコードで実装されています。
<pre>
<code>
# ~%: user 演算子に関数合成
k__tilda__UsOp_mul____ = lambda x,y:Oc(sf.krry((Oc(x) * Oc(y)).m_tpl, Z5)) # ~*
</code>
</pre>
<!--
CT: class Casting Types

    CT instance.fst
    CT instance.lst

    CT() だと type check 無しで関数を保持するインスタンスになる

    You can use Currying functions without type checks.    
    f=CT()(λ x,y:x+2y).fst(3); f(1),f(2),f(3)
    ===============================
    (5, 7, 9)
    f=CT()(λ x,y:x+2y).lst(3); f(1),f(2),f(3)
    ===============================
    (7, 8, 9)
-->
<h3>cartesian product:直積集合</h3>
<p>
abstract nonsence と揶揄されることもある圏論なんかを、何が嬉しくてやるのかと言えば、集合論が弱すぎるからです。集合論では対象の構造を論じるのに {式(x) for x in ... } しかありません。あとは自然言語で記述していくことになります。
<p>
圏論は集合に結合律を満たす arrow 構造を追加します。これにより対象の構造を視覚化できます。数学の世界では広く出てくる結合律による縛りが、豊富なグラフ構造をもたらします。
<p>
その具体例として McLane の教科書の最初に書いてある直積集合の圏論的な扱いについてみてみましょう。<a href="http://books.google.co.jp/books?id=eBvhyc4z8HQC&printsec=frontcover&hl=ja#v=onepage&q&f=false">ここの</a> 4 ページで読めます。
<h4>集合論での直積集合</h4>
<p>
集合論の範囲で {1,2} と {5,6,7} の直積集合は {(x,y) such that x∈{1,2},y∈{5,6,7} } とでも書くでしょう。PythonSf ならば次のように書けます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 集合 X,Y の直積集合 XxY を PythonSf 式で作る
X,Y={1,2},{5,6,7}; XxY={(x,y) for x,y in mitr(X,Y)}; XxY
===============================
set([(2, 7), (2, 6), (1, 5), (1, 6), (1, 7), (2, 5)])

# XxY を kfs frozenset にしてみる
X,Y={1,2},{5,6,7}; XxY=kfs([(x,y) for x,y in mitr(X,Y)]); XxY
===============================
kfs([(1, 5), (1, 6), (1, 7), (2, 5), (2, 6), (2, 7)])
</span>
</code>
</pre>
<p>
（kfs:frozenset を使うと、その集合の中身が sorting されているので便利です。一方で {... ..} の集合記述も数学での表記に近く、記述も簡素です。以下では両方の集合記述が混在されて使われます。）

<p>
集合論での直積集合は要素ペアが示されるだけです。その働きは自然言語で不明瞭に説明されるだけです。集合論は数学的対象を記述する道具として弱すぎます。下のような、直積集合:XxYから X への自明な写像は明白だからと説明もされないことのほうが多いでしょう。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
X,Y={1,2},{5,6,7}; XxY=kfs([(x,y) for x,y in mitr(X,Y)]); fXxY_X=fCT(λ tpl:tpl[0], XxY, X); fXxY_X((1,5))
===============================
1
</span>
</code>
</pre>
<h4>圏論での直積集合</h4>
<p>
圏論では集合 X と Y の直積集合 XxY は下のグラフで視覚化される、arrow p,q を伴った構造だと定義されます。
<pre>
<code>
    圏論での直積集合 XxY
  {1,2} p         q  {5,6,7}
    X ←─ XxY  ──→ Y
    ↑      ↑        ↑
    │      │∃!h    │
    │      │        │
    └───W ────┘
       f         g
</code>
</pre>
<p>
すなわち「(集合:XxY, arrow:p, arrow:q) が集合 X,Y の直積集合である」とは「任意の集合 W と f:W→X, g:W→Y 関数が与えられたとき、h:W→XxY がユニークに存在し f == h〇p, g== h〇q とできる」ことであるとされます。
<p>
こんな抽象的な言葉だけでは普通の人間では正しく理解できません。PythonSf を使って具体例を作ってみましょう。X,Y={1,2},{5,6,7} 二つの直積集合 XxY を dom とし、X,Y を cod とする p,q arrow 関数を下のように与えることで、圏論的な直積集合の定義の具体例を作れます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
X,Y={1,2},{5,6,7}; XxY=kfs([(x,y) for x,y in mitr(X,Y)]);p,q=fCT(λ x_y:x_y[0],XxY,X), fCT(λ x_y:x_y[1],XxY,Y)
===============================
(<function _ at 0x02597730>, <function _ at 0x02C073B0>)
</span>
</code>
</pre>
<p>
上の XxY,p,q に対し、下のように W={0,1} 集合と arrow f,g を下のように与えてみます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
X,Y={1,2},{5,6,7}; XxY=kfs([(x,y) for x,y in mitr(X,Y)]);p,q=fCT(λ x_y:x_y[0],XxY,X), fCT(λ x_y:x_y[1],XxY,Y); W={10,11}; f,g=fCT(λ x:1,W,X), fCT(λ x:5+x%2,W,Y)
<br>
===============================
<br>
(&lt;function _ at 0x02C6F430&gt;, &lt;function _ at 0x02C6F3B0&gt;)
<br>
<br>
X,Y={1,2},{5,6,7}; XxY=kfs([(x,y) for x,y in mitr(X,Y)]);p,q=fCT(λ x_y:x_y[0],XxY,X), fCT(λ x_y:x_y[1],XxY,Y); W={10,11}; f,g=fCT(λ x:1,W,X), fCT(λ x:5+x%2,W,Y); [f(x) for x in W]
<br>
===============================
<br>
[1, 1]
<br>
<br>
X,Y={1,2},{5,6,7}; XxY=kfs([(x,y) for x,y in mitr(X,Y)]);p,q=fCT(λ x_y:x_y[0],XxY,X), fCT(λ x_y:x_y[1],XxY,Y); W={10,11}; f,g=fCT(λ x:1,W,X), fCT(λ x:5+x%2,W,Y); [g(x) for x in W]
<br>
===============================
<br>
[5, 6]
</span>
</code>
<br>
<p>
この適当に与えられた W,f,g に対し次のような ∃!h:W→XxY を作れます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
X,Y={1,2},{5,6,7}; XxY=kfs([(x,y) for x,y in mitr(X,Y)]);p,q=fCT(λ x_y:x_y[0],XxY,X), fCT(λ x_y:x_y[1],XxY,Y); W={10,11}; f,g=fCT(λ x:1,W,X), fCT(λ x:5+x%2,W,Y); dh={10:(1,5),11:(1,6)}; h=fCT(λ x:dh[x],W,XxY); [h(x) for x in W]
<br>
===============================
<br>
[(1, 5), (1, 6)]
<br>
<br>
<br>
</span>
</code>
<br>
<p>
このように与えられた h に対し先の直積集合のグラフが成り立つこと：arrow が commute することを次のように確認できます
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b><br>
# f と p〇h が commute する<br>
X,Y={1,2},{5,6,7}; XxY=kfs([(x,y) for x,y in mitr(X,Y)]);p,q=fCT(λ x_y:x_y[0],XxY,X), fCT(λ x_y:x_y[1],XxY,Y); W={10,11}; f,g=fCT(λ x:1,W,X), fCT(λ x:5+x%2,W,Y); dh={10:(1,5),11:(1,6)}; h=fCT(λ x:dh[x],W,XxY); [f(x) == (p~%h)(x) for x in W]
<br>
===============================
<br>
[True, True]
<br>
<br>
# g と q〇h が commute する<br>
X,Y={1,2},{5,6,7}; XxY=kfs([(x,y) for x,y in mitr(X,Y)]);p,q=fCT(λ x_y:x_y[0],XxY,X), fCT(λ x_y:x_y[1],XxY,Y); W={10,11}; f,g=fCT(λ x:1,W,X), fCT(λ x:5+x%2,W,Y); dh={10:(1,5),11:(1,6)}; h=fCT(λ x:dh[x],W,XxY); [g(x) == (q~%h)(x) for x in W]
<br>
===============================
<br>
[True, True]
</span>
</code>
<br>
<p>
この h 関数：arrow が与えられた W,f,g に対してユニークに定まることは虱潰しによる確認で証明できます。でも煩雑になりすぎるので省略します。自明に近いとも思います。

<h4>{0,1,2,3,4,5} を直積集合にする</h4>
<p>
圏論の直積集合の定義ならば、集合 WW:{0,1,2,3,4,5} も X,Y の直積集合にできます。次のような pp,qq を考えて見ましょう。
<pre>
<code>
# 圏論での直積集合 
       {0,1,2,3,4,5,6}
  {1,2} pp       qq {5,6,7}
    X ←─  WW  ──→ Y
    ↑      ↑        ↑
    │      │∃!h    │
    │      │        │
    └───W ────┘
       f         g
</code>
</pre>

<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
# pp:WW→X<br>
X,Y={1,2},{5,6,7}; WW=kfs(range(6));pp,qq=fCT(λ x_y:1 if x_y<3 else 2,WW,X), fCT(λ x_y:5+x_y%3,WW,Y); W={10,11}; [pp(x) for x in WW]
<br>
===============================
<br>
[1, 1, 1, 2, 2, 2]
<br>
<br>

# qq:WW→Y<br>
X,Y={1,2},{5,6,7}; WW=kfs(range(6));pp,qq=fCT(λ x_y:1 if x_y<3 else 2,WW,X), fCT(λ x_y:5+x_y%3,WW,Y); W={10,11}; [qq(x) for x in WW]
<br>
===============================
<br>
[5, 6, 7, 5, 6, 7]
</span>
</code>
<br>
<p>
上のような X,Y,WW,pp,qq に対し、先ほどの f,g に対応する ∃!h を次のように定義しましょう
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
X,Y={1,2},{5,6,7}; WW=kfs(range(6));pp,qq=fCT(λ x_y:1 if x_y<3 else 2,WW,X), fCT(λ x_y:5+x_y%3,WW,Y); W={10,11}; f,g=fCT(λ x:1,W,X), fCT(λ x:5+x%2,W,Y); dh={10:0,11:1}; h=fCT(λ x:dh[x],W,WW); [h(x) for x in W]
<br>
===============================
<br>
[0, 1]
</span>
</code>
<br>
<p>
上の ∃!h  と {0,1,2,3,4,5} に対し、下のように直積構造が成立することを確認できます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>

# f と pp〇h が commute する<br>
X,Y={1,2},{5,6,7}; WW=kfs(range(6));pp,qq=fCT(λ x_y:1 if x_y<3 else 2,WW,X), fCT(λ x_y:5+x_y%3,WW,Y); W={10,11}; f,g=fCT(λ x:1,W,X), fCT(λ x:5+x%2,W,Y); dh={10:0,11:1}; h=fCT(λ x:dh[x],W,WW); [f(x)==(pp~%h)(x) for x in W]
<br>
===============================
<br>
[True, True]
<br>
<br>

# g と qq〇h が commute する<br>
X,Y={1,2},{5,6,7}; WW=kfs(range(6));pp,qq=fCT(λ x_y:1 if x_y<3 else 2,WW,X), fCT(λ x_y:5+x_y%3,WW,Y); W={10,11}; f,g=fCT(λ x:1,W,X), fCT(λ x:5+x%2,W,Y); dh={10:0,11:1}; h=fCT(λ x:dh[x],W,WW); [g(x)==(qq~%h)(x) for x in W]
<br>
===============================
<br>
[True, True]
</span>
</code>
<br>
<p>
圏論の直積集合の定義を導入することで {0,1,2,3,4,5} のような直積集合とは思えない集合も {1,2} と {5,6,7} の直積集合とみなせるようになりました。これにより直積集合に関する多くの性質が {0,1,2,3,4,5} 集合についても成り立ちます。このことは {0,1,2,3,4,5} 集合に直積集合の構造を導入したとも言えます。圏論の威力を示す例だとも思います。皆様はどのように思われるでしょうか。
<h3>cartesian co-product:直和集合</h3>
<pre>
<code>
A──→ A + B ←─→B
│        l[f,g]   │
│        V        │
└──→  B  ←──┘
</code>
</pre>
to be discussed
<h3>functor 構造</h3>
to be discussed

<h3>natural transformation 構造</h3>
to be discussed

<h3>adjunction 構造</h3>
to be discussed

<h3>monad 構造</h3>
to be discussed

<h3>圏論の奨め</h3>
<p>
圏論を使うことで、複数の分野に散在していた抽象概念を、さらなる高みから統一して把握しなおすことが可能になります。これは研究者などの「新たな概念を生み出す」者たちに強力なツールをもたらします。抽象的に頭の中だけでボンヤリと考えていたことがらにグラフを使って可視化された具体的な全体構造を見通せるようになります。
<p>
圏論は大学の研究者に限らす「新たな概念を生み出す」者たち全てが利用できる強力ツールです。例えば PythonSf の基本関数たち（sin, cos や `X 恒等関数など）は「リカーシブに加減乗除算と整数べき乗算が可能」です。この「リカーシブに加減乗除と整数べき乗算が可能」な構造は monad とみなせます。「リカーシブに加減乗除算と整数べき乗算が可能」にしているのは ClAF クラスの実装です。この実装仕様を定めるのに monad 構造を意識しているか否かは全体を見通すと力に決定的な違いをもたらします。
<p>
圏論なんて abstract nonsence だと思われている方もいると思います。でも「新たな概念を生み出す者」であることを望むならば、学んでおくべき新しい道具です。それを学ぶ手間隙以上の強力な道具を手に入れられます。
<!--
Cayley Dickson 構成の Monad は ClAF を変形すれば簡単に実装できそう
関数に dom,cod を設けられます。

adjunction など functor と natural transformation を組み合わせた構造の具体例を容易に作れます。

圏論とは
-->
<a name="■■ オペアンプ・フィルタ回路"></a>
<h2>■■ オペアンプ・フィルタ回路</h2>
PythonSf の Laplace 演算子 `s は Matlab, Mathematica などを大きく超えた計算機能です。それをオペアンプ回路に適用した例を見ていきましょう。オペアンプの伝達関数も含んだ回路系の記述・計算が簡単にできるのを見てください。オペアンプ自体の伝達関数も含めてワンライナーで簡単に特性や応答を計算できます。

<h3>反転増幅回路</h3>
<p>
下の回路の伝達関数を考えます。
<pre>
<code>
                     ┌──┐ 
                 ┌─┤ Zf ├─┐
                 │  └──┘　│
         ┌─┐→│Vm    　    │
    Vi ─┤Zi├─┴─◆-       │
         └─┘Ii    │G ＞──┴─── Vo
                 ┌─◇+
                 │
                 │
                 ≡

</code>
</pre>
<p>
下の関係式がなりたちます。
<pre>
<code>
Vo = -G Vm  ----------- (1)
Vi-Vm = Zi Ii --------- (2)
Vm - Vo = Zf Ii ------- (3)
</code>
</pre>
<p>
Vo/Vi の伝達関数が欲しいので、下の PythonSf 式で symbolic な代数解を計算させます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
ts(); Vi,Vo,Vm, Ii, Zi,Zf, G = ts.symbols('Vi,Vo,Vm, Ii, Zi,Zf, G'); ts.solve([ts.Eq(Vo+G Vm), ts.Eq(Vi-Vm-Zi Ii), ts.Eq(Vm-Vo-Zf Ii)], [Vo,Vm,Ii])
<br>
===============================
<br>
{Vo: G*Vi*Zf/(-G*Zi - Zf - Zi), Ii: Vi*(G + 1)/(G*Zi + Zf + Zi), Vm: Vi*Zf/(G*Zi + Zf + Zi)}
<br>
</span>
</code>
<p>
上の代数解より、Vo と Vi には下の関係式が成り立つことが解ります。
<pre>
<code>
Vo==-G Vi Zf/(G Zi + Zf + Zi)
  ==-  Vi Zf/(  Zi + (Zf + Zi)/G )  --------- (4)

∴
Vo/Vi == -Zf/(Zi + (Zf + Zi)/G )  ----------- (5)

G が無限大のとき
Vo/Vi == -Zf/Zi ----------------------------- (6)
</code>
</pre>
<p>
さて代表的なオペアンプ uA741 の DC ゲインは 25000 倍であり、その GBW は 1MHz です。そのファイル変数 uA741.pvl を下のように作っておきましょう。後で上の G に代入する形で使います。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
f=1 M` Hz`; uA741:=2pi f/(`s + 2pi f/25000)
===============================
 
6.283e+06
---------
s + 251.3

<b>PythonSf ワンライナー</b>
G=:uA741; G.plotBode(0.1Hz`, 10M` Hz`)
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_ua741_bode.jpg">
<p>
下のような回路の特性を検討してみましょう
<pre>
<code>
                                C1:0.001uF
                           ┌──┤├──┐
                           │   R2:10kΩ │
                           ├──MWMW──┤
    Ii     R1:1kΩ C1:0.1uF│            │ 
     ───MWMW──┤├──┴─◆-       │
    Vi                 Vm      │ G＞──┴───
                           ┌─◇+  uA741
                           │ 
                           │ 
                           ≡
</code>
</pre>
<p>
理想オペアンプのとき、(6) 式より、上の回路の周波数特性は次のようになります。(下の式で ~+ 演算子は並列接続での足し算を計算させています)
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
R1,R2,C1,C2=1kΩ`,10kΩ`,0.1uF`,0.001uF`; Zi,Zf = R1+1/(C1 `s), R2~+(1/(C2 `s)); (-Zf/Zi ).plotBode(10 Hz`, 10 M` Hz`)
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_ideal_bandpass_bode.jpg">
<br>
<p>
uA741 オペアンプのとき、(5)式より上の回路の周波数特性は次のようになります。ゲイン特性が 1MHz 近辺で異なります。位相特性は、100kHz ぐらいから違ってきています。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
G=:uA741; R1,R2,C1,C2=1kΩ`,10kΩ`,0.1uF`,0.001uF`; Zi,Zf = R1+1/(C1 `s), R2~+(1/(C2 `s)); ( -Zf/(Zi + (Zf + Zi)/G ) ).plotBode(10 Hz`, 10 M` Hz`)
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_ua741_bandpass_bode.jpg">
<br>
<br>
理想オペアンプと uA741 でのステップ応答の違いを見てみましょう
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
G=:uA741; R1,R2,C1,C2=1kΩ`,10kΩ`,0.1uF`,0.001uF`; Zi,Zf = R1+1/(C1 `s), R2~+(1/(C2 `s)); ( -Zf/Zi ).plotAnRspns(0.3ms`); ( -Zf/(Zi + (Zf + Zi)/G ) ).plotAnRspns(0.3ms`, color=red)
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_ideal_ua741_step.jpg">
<br>
<p>
赤い線のほうが uA741 側です。当然ながら uA741 のステップ応答のほうが少し鈍ります。でも多くの場合で許されそうな範囲です。
<p>
厳密には uA741 の slew rate は 0.5V/us 程度ですから、そっちの方の影響の方が少しだけ強そうです。もし slew rate まで含めてシミュレートしようとすると、PythonSf ではなく Spice を持ち出してくるべきでしょう。PythonSf でも kOde(..) を使って微分方程式を解かせればシミュレートできます。でも その微分方程式モデルを作り上げる手間が面倒すぎです。
<p>
逆に線形系：Laplace 変換で扱える範疇ならば、上の程度の回路の特性検討は Spice よりも PythonSf の方が便利だと思います。Spice ソフトを立ち上げたり、回路図を描いて部品定数を入力するのではなく、エディタ上で PythonSf 式を書くだけなのですから。

<h3>多重帰還型バンドパスフィルタ</h3>
<p>
もう少し複雑な下の回路トポロジで記述される多重帰還型バンドパスフィルタを検討してみましょう。
<pre>
<code>
                                           Io
                   ┌──────┬──────┐ 
                   │            │        Vo  │ 
               ┌─┴─┐    ┌─┴─┐        │ 
               │  Z3  │    │  Z5  │        │ 
               └─┬─┘    └─┬─┘        │ 
                   │↑I2      →│            │ 
    Ii ┌──┐    │V2┌──┐Im│            │ 
     ─┤ Z1 ├──┼─┤ Z4 ├─┴──◆-   Vo│
    Vi └──┘  ↓│Ig└──┘Vm      │ G＞─┴───
               ┌─┴─┐          ┌─◇+
               │  Z2  │          │ 
               └─┬─┘          │ 
                   ≡              ≡
</code>
</pre>
<p>
上の Vi,Vo と Z1, Z2,Z3,Z4,Z5 と V2,Vm,I2,Ig,Im の間に次の六つの関係式が成り立ちます。
<pre>
<code>
Vm = - 1/G Vo ---------------------------------------(1)
Im = (1+1/G) Vo/Z5 --------------------------------- (2)
I2 = 1/Z3 (V2-Vo) ---------------------------------- (3)
Im = 1/Z5 (V2-Vm) ---------------------------------- (4)
Vi-V2 = Z1 I2 + Z1 Im + Z1 Ig ---------------------- (5)
V2 = Vm + Im Z4
   = -1/G Vo + (1+1/G) Vo Z4/Z5 -------------------- (6)
</code>
</pre>
<p>
上の関係式から V2, Im,Ig,Vm を消去して Vo/Vi を表す式を求めるため、下の PythonSf 式を使って Vo,V2, Im,Ig,Vm を Vi と Z1,Z2,Z3,Z4,Z5 の組み合わせの式に変形します。その結果の Vo = .... の式から Vo/Vi = f(Z1,Z2,Z3,Z4,Z5, G) の式を導きます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
ts(); I2,Im,Ig,Vi,Vm,Vo,V2,Z1,Z2,Z5,Z4,Z3,G = ts.symbols('I2,Im,Ig,Vi,Vm,Vo,V2,Z1,Z2,Z5,Z4,Z3,G'); ts.solve([ts.Eq(Im + (1+1/G) Vo/Z5), ts.Eq(1/Z3 (V2-Vo) - I2), ts.Eq(1/Z4 (V2-Vm) - Im),ts.Eq(V2 - Z2 Ig),ts.Eq(-Vi +V2 + Z1 I2 + Z1 Im + Z1 Ig),ts.Eq(V2+1/G Vo - Im Z4)], [I2,Im,Ig,Vo,Vm,V2])
<br>
===============================
<br>
{I2: Vi*Z2*(G*Z4 + G*Z5 + Z4 + Z5)/(G*Z1*Z2*Z3 + G*Z1*Z2*Z4 + G*Z1*Z2*Z5 + G*Z1*Z3*Z4 + G*Z2*Z3*Z4 + Z1*Z2*Z3 + Z1*Z2*Z4 + Z1*Z2*Z5 + Z1*Z3*Z4 + Z1*Z3*Z5 + Z2*Z3*Z4 + Z2*Z3*Z5), Im: Vi*Z2*Z3*(G + 1)/(G*Z1*Z2*Z3 + G*Z1*Z2*Z4 + G*Z1*Z2*Z5 + G*Z1*Z3*Z4 + G*Z2*Z3*Z4 + Z1*Z2*Z3 + Z1*Z2*Z4 + Z1*Z2*Z5 + Z1*Z3*Z4 + Z1*Z3*Z5 + Z2*Z3*Z4 + Z2*Z3*Z5), Vo: G*Vi*Z2*Z3*Z5/(-G*Z1*Z2*Z3 - G*Z1*Z2*Z4 - G*Z1*Z2*Z5 - G*Z1*Z3*Z4 - G*Z2*Z3*Z4 - Z1*Z2*Z3 - Z1*Z2*Z4 - Z1*Z2*Z5 - Z1*Z3*Z4 - Z1*Z3*Z5 - Z2*Z3*Z4 - Z2*Z3*Z5), Ig: Vi*Z3*(G*Z4 + Z4 + Z5)/(G*Z1*Z2*Z3 + G*Z1*Z2*Z4 + G*Z1*Z2*Z5 + G*Z1*Z3*Z4 + G*Z2*Z3*Z4 + Z1*Z2*Z3 + Z1*Z2*Z4 + Z1*Z2*Z5 + Z1*Z3*Z4 + Z1*Z3*Z5 + Z2*Z3*Z4 + Z2*Z3*Z5), V2: Vi*Z2*Z3*(G*Z4 + Z4 + Z5)/(G*Z1*Z2*Z3 + G*Z1*Z2*Z4 + G*Z1*Z2*Z5 + G*Z1*Z3*Z4 + G*Z2*Z3*Z4 + Z1*Z2*Z3 + Z1*Z2*Z4 + Z1*Z2*Z5 + Z1*Z3*Z4 + Z1*Z3*Z5 + Z2*Z3*Z4 + Z2*Z3*Z5), Vm: Vi*Z2*Z3*Z5/(G*Z1*Z2*Z3 + G*Z1*Z2*Z4 + G*Z1*Z2*Z5 + G*Z1*Z3*Z4 + G*Z2*Z3*Z4 + Z1*Z2*Z3 + Z1*Z2*Z4 + Z1*Z2*Z5 + Z1*Z3*Z4 + Z1*Z3*Z5 + Z2*Z3*Z4 + Z2*Z3*Z5)}
<br>
<br>
# Vo = .... の式
<br>
Vo= G*Vi*Z2*Z3*Z5/(-G*Z1*Z2*Z3 - G*Z1*Z2*Z4 - G*Z1*Z2*Z5 - G*Z1*Z3*Z4 - G*Z2*Z3*Z4 - Z1*Z2*Z3 - Z1*Z2*Z4 - Z1*Z2*Z5 - Z1*Z3*Z4 - Z1*Z3*Z5 - Z2*Z3*Z4 - Z2*Z3*Z5)
<br>
<br>
# Vo/Vi = f(Z1,Z2,Z3,Z4,Z5, G) の式
<br>
Vo/Vi= Z2 Z3 Z5/(-Z1 Z2 Z3 - Z1 Z2 Z4 - Z1 Z2 Z5 - Z1 Z3 Z4 - Z2 Z3 Z4 -(Z1 Z2 Z3 + Z1 Z2 Z4 + Z1 Z2 Z5 + Z1 Z3 Z4 + Z1 Z3 Z5 + Z2 Z3 Z4 +
Z2 Z3 Z5)/G)
<br>
 --------------------------------------------------- (7)
</span>
</code>
<br>
<p>
上の 7 式なんて、手計算では絶対に計算しきれないと思います。途中で誤りが入り込んで計算が収束しないでしょう。SymPy は凄いと思います。そして SymPy で Python プログラム・コードを書くとしても、普通のエンジニアはデバッグ途中でギブ・アップすると思います。でもワン・ライナーであれこれ試せる PythonSf ならば、この程度のトポロジーの回路でも扱えます。ここらが限度の気もしますが、通常の回路設計ならば これで十分でしょう。各 Z ブロックは単一素子に限らなくて、任意の L C R の組み合わせでもかまわないのですから。
<p>
上で求めた Vo/Vi の式を下の多重帰還型バンドパスフィルタ回路に適用してみましょう。
<pre>
<code>
                   ┌──────┬──────┐ 
                   │Z3          │Z5      Vo  │ 
                 ─┴─1000p     ≧220k        │ 
                 ─┬─          ≦            │ 
                 ↑│I2      →  │            │ 
    Ii     Z1      │V2  Z4  Im  │            │ 
     ───MWMW──┼──┤├──┴─◆-       │
    Vi     22k     │   1000p Vm     │ G＞──┴───
                   ≧Z2          ┌─◇+
                   ≦1k          │ 
                   │            │ 
                   ≡            ≡
</code>
</pre>
<p>
理想オペアンプでは次のような伝達関数・Bode 線図になります。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
# 伝達関数
Z1,Z2,Z3,Z4,Z5 = 22kΩ`, 1kΩ`, 1/(1000pF` `s), 1/(1000pF` `s),220kΩ`; trf=Z2 Z3 Z5/(-Z1 Z2 Z3 - Z1 Z2 Z4 - Z1 Z2 Z5 - Z1 Z3 Z4 - Z2 Z3 Z4); trf
<pre>
===============================
     -4.545e+04 s
----------------------
 2
s + 9091 s + 4.752e+09
</pre>
</span>
</code>

<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
# Bode 線図
Z1,Z2,Z3,Z4,Z5 = 22kΩ`, 1kΩ`, 1/(1000pF` `s), 1/(1000pF` `s),220kΩ`; trf=Z2 Z3 Z5/(-Z1 Z2 Z3 - Z1 Z2 Z4 - Z1 Z2 Z5 - Z1 Z3 Z4 - Z2 Z3 Z4); trf.plotBode(1k` Hz`,100k` Hz`)
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_ideal_multiple_feedback_bandpass.jpg">
<br>
<p>
この伝達関数の極は次の PythonSf 式で求められます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
Z1,Z2,Z3,Z4,Z5 = 22kΩ`, 1kΩ`, 1/(1000pF` `s), 1/(1000pF` `s),220kΩ`; trf=Z2 Z3 Z5/(-Z1 Z2 Z3 - Z1 Z2 Z4 - Z1 Z2 Z5 - Z1 Z3 Z4 - Z2 Z3 Z4); trf.m_plDenom.roots
<br>
===============================
<br>
[-4545.45454545+68785.20886555j -4545.45454545-68785.20886555j]
</span>
</code>
<br>
<p>
uA741 オペアンプでは次のような伝達関数・Bode 線図になります。中心周波数が理想オペアンプのときより数 kHz 低くなります。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
G=:uA741; Z1,Z2,Z3,Z4,Z5 = 22kΩ`, 1kΩ`, 1/(1000pF` `s), 1/(1000pF` `s),220kΩ`; trf=Z2 Z3 Z5/(-Z1 Z2 Z3 - Z1 Z2 Z4 - Z1 Z2 Z5 - Z1 Z3 Z4 - Z2 Z3 Z4 -(Z1 Z2 Z3 + Z1 Z2 Z4 + Z1 Z2 Z5 + Z1 Z3 Z4 + Z1 Z3 Z5 + Z2 Z3 Z4 + Z2 Z3 Z5)/G); trf
<br>
<pre>
===============================
              -2.856e+11 s
----------------------------------------
 3             2
s + 7.338e+06 s + 6.214e+10 s + 2.986e+16
</pre>
</span>
</code>
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
G=:uA741; Z1,Z2,Z3,Z4,Z5 = 22kΩ`, 1kΩ`, 1/(1000pF` `s), 1/(1000pF` `s),220kΩ`; trf=Z2 Z3 Z5/(-Z1 Z2 Z3 - Z1 Z2 Z4 - Z1 Z2 Z5 - Z1 Z3 Z4 - Z2 Z3 Z4 -(Z1 Z2 Z3 + Z1 Z2 Z4 + Z1 Z2 Z5 + Z1 Z3 Z4 + Z1 Z3 Z5 + Z2 Z3 Z4 + Z2 Z3 Z5)/G); trf.plotBode(1k` Hz`,100k` Hz`)
</span>
</code>
<br>
<img src="./jpg/1111/oneliners__ua741_multiple_feedback_bandpass.jpg">
<p>
流石に複雑なトポロジーの回路で部品数も多い分、先の微分・積分回路によるバンド・パスのときより急峻な選択特性になっています。
<p>
この伝達関数の極は次の PythonSf 式で求められます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
G=:uA741; Z1,Z2,Z3,Z4,Z5 = 22kΩ`, 1kΩ`, 1/(1000pF` `s), 1/(1000pF` `s),220kΩ`; trf=Z2 Z3 Z5/(-Z1 Z2 Z3 - Z1 Z2 Z4 - Z1 Z2 Z5 - Z1 Z3 Z4 - Z2 Z3 Z4 -(Z1 Z2 Z3 + Z1 Z2 Z4 + Z1 Z2 Z5 + Z1 Z3 Z4 + Z1 Z3 Z5 + Z2 Z3 Z4 + Z2 Z3 Z5)/G); trf.m_plDenom.roots
<br>
===============================
<br>
[ -7.33006081e+06    +0.j          -3.96063749e+03+63701.29330301j
  -3.96063749e+03-63701.29330301j]
</span>
</code>
<p>
部品定数を変化させ根軌跡を描くことで、共振特性も検討できそうです。周波数選択特性も設計できそうです。
<br>
<br>
<a name="■■ Fractal 図形"></a>
<h2>■■ Fractal 図形</h2>
<p>
PythonSf 記述は数学記述に近いので、数学的な対象の説明では、自然言語による説明より PythonSf コードの方が解り易いことが多くあります。Fractal 図形について、その様子を見てみましょう。
<p>
なお、ここでは one-liner ではなく、ブロック・コードのほうが多用されます。One-liner にして再利用する意味は殆ど無いからです。ならば可読性を優先すべきだからです。

<h3>Koch Curve</h3>
<p>
コッホ曲線を PythonSf で描きます。<a href="http://ja.wikipedia.org/wiki/コッホ曲線">Wiki</a> などにも Koch 曲線の説明があるのですが、下の 
複素数を使ったコードのほうが解りやすいと思います。
<!--
http://en.wikipedia.org/wiki/Koch_snowflake
-->
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ブロック</b>
# Koch 曲線
//@@
θ=exp(`i pi/3)
def f(lst,count=10):
    if count<0:
        return lst

    rtn=[]
    for k in range(len(lst)-1):
        sg = (lst[k+1]-lst[k])/3
        rtn += [lst[k], lst[k]+sg, lst[k]+sg+θ sg, lst[k]+sg 2]
    
    rtn += [lst[-1] ]
    return f(rtn, count-1)

plotTrajectory([ (x.real, x.imag) for x in f([0,1], 5)])
//@@@
</code>
</pre>
<br>
<img src="./jpg/1111/block_python_kocho2.jpg">
<p>
上のコードの肝は、下の二行です。
<pre>
<code>
        sg = (lst[k+1]-lst[k])/3
        rtn += [lst[k], lst[k]+sg, lst[k]+sg+θ sg, lst[k]+sg 2]
</code>
</pre>
<p>
Koch 曲線を lst に平面位置：複素数値を順番に並べることで表現します。その部分セグメント：直線：lst[k+1]-lst[k] の 1/3 の線分 sg を作ります。sg ができたら、θ sg によって左方向に 60度回転させた線分を作れます。そして [lst[k], lst[k]+sg, lst[k]+sg+θ sg, lst[k]+sg 2] によって元の線分をもう一段階細かく折り曲げた四つの繋がった線分を作ります。
<p>
下は [0,1,0.5-`i, 0] の三角形の線分から Koch 曲線を作ることで、雪の結晶のような Koch 曲線にしています。
</span>
</code>
</pre>
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ブロック</b>
# 星型の Koch 曲線
//@@
θ=exp(`i pi/3)
def f(lst,count=10):
    if count<0:
        return lst

    rtn=[]
    for k in range(len(lst)-1):
        sg = (lst[k+1]-lst[k])/3
        rtn += [lst[k], lst[k]+sg, lst[k]+sg+θ sg, lst[k]+sg 2]
    
    rtn += [lst[-1] ]
    return f(rtn, count-1)

plotTrajectory([ (x.real, x.imag) for x in f([0,1,0.5-`i, 0], 5)])
//@@@

</span>
</code>
</pre>
<br>
<img src="./jpg/1111/block_python_kocho2_snow.jpg">
<h3>Hilbert Curve</h3>
<p>
平面を埋め尽くす一次元の線として Hirbert Curve が有名です。でも<a href="http://en.wikipedia.org/wiki/Hilbert_curve#Applications_and_mapping_algorithms ">Wiki</a>や <a href="http://mathworld.wolfram.com/HilbertCurve.html">WolframMathWorld</a> などの説明を読んでも、どうやって描いていくのか簡単には理解できません。下の PythonSf ブロック・コードなら Hilbert Curve を作るアルゴリズムが良くわかると思います。いかがでしょうか？
<!--
http://en.wikipedia.org/wiki/Hilbert_curve#Applications_and_mapping_algorithms

http://mathworld.wolfram.com/HilbertCurve.html
A Lindenmayer system invented by Hilbert (1891) whose limit is a plane-filling function which fills a square. Traversing the polyhedron vertices of an n-dimensional hypercube in Gray code order produces a generator for the n-dimensional Hilbert curve. The Hilbert curve can be simply encoded with initial string "L", string rewriting rules "L" -> "+RF-LFL-FR+", "R" -> "-LF+RFR+FL-", and angle 90 degrees (Peitgen and Saupe 1988, p. 278). 

https://www.fractalus.com/kerry/tutorials/hilbert/hilbert-tutorial.html
-->
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ブロック</b>
//@@
N=3

# seed trajectory: matrix of position data
mt=~[(1/4,3/4),(1/4,1/4),(3/4,1/4),(3/4,3/4)]
mtL = ~[[ 0,1],     # rotate pi/2 left
        [-1,0]]
mtS = ~[[ 0,1],     # symmetric conversion for x==y axis
        [ 1,0]]

for _ in range(N):
    mt=~[list((mt mtL)[::-1] +~[1,1])
       + list(mt)
       + list(mt+~[1,0])
       + list(mt mtS + ~[1,1])
        ]/2

plotTrajectory(mt)
//@@@
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_hilbert_curve.jpg">
<br>
<p>
上のコードの肝は mt mtL と mt mtS の行列積です。mt は N x 2 行列であり N この平面位置ベクトルを保持しています。これに右から mtL:( pi/2 だけ回転させる) 変換と mtS:(x==y の直線に対称な位置に鏡影変換する行列を掛けることで位置ベクトルの羅列データ mt を変換しています。
<!--
<h2>Gauss の代数学基本定理</h2>
問題定義
Gauss の代数学の基本定理 「N 次多項式は N 個の根を持つ」を成り立たせている必要十分な理由を示せ
<== 四元数では無限個になる
常に Z3 n 次多項式が n 個の根を持つように Z3 体を拡張できるか
<== 直感的には無限次元になってしまいそう
<== 三次、四次、五次多項式まで調べてみよ
独立させる
<p>
数学も自然科学です。ですから数学の問題を実験により解明していけます。そして PythonSf は、この実験のための手間を著しく簡便にしてくれます。
<p>
例として「Gauss の代数学の基本定理:N 次多項式は N 個の根を持つ」性質は何によってもたらされているのか？」を考えて見ます。でも、このような単なる疑問文では漠然としすぎで、考察を進められないので、
<ul>
    <li> 多項式の根を求める → 自乗根: x^2 == 1 となる x を求める
</ul>
と問題を単純化します。そして 1 の自乗根を探す範囲を四元数に広げてみます。また逆に z5_x + z5_y i where z5_x, z5_y ∈ Zp(5) に根を探す範囲を狭めてみます。

<h2>sqrt(..) の多項式展開</h2>
sqrt は Maclaurin 展開できない
http://chaosweb.complex.eng.hokudai.ac.jp/~josch/workshop/math/Maclaurin/Maclaurin3.htm

<h3>実数値四元数</h3>
oc.Oc(2,30,500, 7000)^2
===============================
(-49250896, 120, 2000, 28000)

(x+yi+zj+wk) (x+yi+zj+wk) = x^2-y^2-z^2-w^2+(2 x y) i+(z x + w y + x z - y w) j+(w x - z y + y z : x w) k

上の式の確認
x,y,z,w = (2,30,500, 7000); x^2-y^2-z^2-w^2
===============================
-49250896
x,y,z,w = (2,30,500, 7000); (2 x y)
===============================
120
x,y,z,w = (2,30,500, 7000); (z x + w y + x z - y w) 
===============================
2000
x,y,z,w = (2,30,500, 7000); (w x - z y + y z + x w) 
===============================
28000


独立させる
Larent 展開;;http://www.f-denshi.com/000TokiwaJPN/12cmplx/090cmp.html
sqrt(..) 関数は z==0 の点で 0 次の極を持つ解析関数です。でも z==0 の点では Taylor 展開も Laurent 展開もできません。z=0+0j の点は孤立特異点であり、Rieman 面が発生しています

plot3dGr( sqrt, [-1,1],[`i,-`i])
plot3dGr(-sqrt, [-1,1],[`i,-`i])

z=1+0j など 0+0j 以外の場所では taylor 展開可能です
ts(); ts.sqrt(1+`x).series(`x,n=5)
===============================
1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128 + O(x**5)

ts(); (1/ ts.sqrt(1+`x) ).series(`x,n=5)
===============================
1 - x/2 + 3*x**2/8 - 5*x**3/16 + 35*x**4/128 + O(x**5)

sqrtm(`σx+`σy)
===============================
[[  5.94603558e-01 -5.94603558e-01j   8.40896415e-01 +1.11022302e-16j]
 [ -5.55111512e-17 +8.40896415e-01j   5.94603558e-01 -5.94603558e-01j]]
---- ClTensor ----

mt=sqrtm(`σx+`σy); mt^2
===============================
[[ 0. -3.33066907e-16j  1. -1.00000000e+00j]
 [ 1. +1.00000000e+00j  0. +2.22044605e-16j]]
---- ClTensor ----

sy(); sc.source(sy.linalg.sqrtm)
sc.source(np.linalg.sqrtm)
np.source(sqrtm)


x=`X; plotGr(1+x, 0.5,1.5); plotGr( 1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128,0.5,1.5, color=red)

ts(); ts.sqrt(1+`x).series(`x,n=10)
===============================
1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128 + 7*x**5/256 - 21*x**6/1024 + 33*x**7/2048 - 429*x**8/32768 + 715*x**9/65536 + O(x**10)

x=`X; plotGr(1+x, 0.5,1.5); plotGr(1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128 + 7*x**5/256 - 21*x**6/1024 + 33*x**7/2048 - 429*x**8/32768 + 715*x**9/65536 ,0.5,1.5, color=red)

x=`X; plotGr(sqrt( 1+x ),-0.5,0.5); plotGr( 1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128,-0.5,0.5, color=red)
x=`X; plotGr(sqrt( 1+x ),-1.0,3.5); plotGr( 1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128,-1.0,3.5, color=red)
x=`X; plotGr(sqrt( 1+x ),-1.0,3.5); plotGr(1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128 + 7*x**5/256 - 21*x**6/1024 + 33*x**7/2048 - 429*x**8/32768 + 715*x**9/65536 ,-1.0,3.5, color=red)
x=`X; plotGr(sqrt( 1+x ),-1.0,2.5); plotGr(1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128 + 7*x**5/256 - 21*x**6/1024 + 33*x**7/2048 - 429*x**8/32768 + 715*x**9/65536 ,-1.0,2.5, color=red)
x=`X; plotGr(sqrt( 1+x ),-1.0,1.5); plotGr(1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128 + 7*x**5/256 - 21*x**6/1024 + 33*x**7/2048 - 429*x**8/32768 + 715*x**9/65536 ,-1.0,1.5, color=red)
<== Taylor 展開は万能ではない
    <== sqrt(z) は 0 が Laurent 展開できない特異点であり、Taylor 展開では その影響が反対側にも及ぶ


行列でも Taylor 展開近似が成り立つか？
x=`σx+`σy; print(sqrt( 1+x )); `print( 1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128)
[[ 1.00000000+0.j          1.45534669-0.34356075j]
 [ 1.45534669+0.34356075j  1.00000000+0.j        ]]
---- ClTensor ----
ClTensor([[ 0.59375+0.j   ,  1.62500-0.625j],
       [ 1.62500+0.625j,  0.59375+0.j   ]], dtype=complex)
===============================
None

x=0.1 ( `σx+`σy ); print(sqrt( 1+x )); `print( 1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128)
[[ 1.00000000+0.j          1.04988954-0.04762406j]
 [ 1.04988954+0.04762406j  1.00000000+0.j        ]]
---- ClTensor ----
ClTensor([[ 0.99748438+0.j      ,  1.05012500-0.050125j],
       [ 1.05012500+0.050125j,  0.99748438+0.j      ]], dtype=complex)
===============================
None
x=0.2 ( `σx+`σy );`print(sqrt( 1+x )); `print( 1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128)
ClTensor([[ 1.0000000+0.j        ,  1.0992162-0.09097391j],
       [ 1.0992162+0.09097391j,  1.0000000+0.j        ]], dtype=complex)
ClTensor([[ 0.98975+0.j   ,  1.10100-0.101j],
       [ 1.10100+0.101j,  0.98975+0.j   ]], dtype=complex)
===============================
None

`σx^2
===============================
[[ 1.  0.]
 [ 0.  1.]]
---- ClTensor ----

sqrt(kzrs(2,2)^0)
===============================
[[ 1.  0.]
 [ 0.  1.]]
---- ClTensor ----

その固有値は [1,1], [1,-1],[-1,-1],[-1,-1]
eigvalsh(`σx)
===============================
[-1.  1.]
---- ClTensor ----
eigvalsh(`σy)
===============================
[-1.+0.j  1.+0.j]
---- ClTensor ----

`σx^2
===============================
[[ 1.  0.]
 [ 0.  1.]]
---- ClTensor ----
`σy^2
===============================
[[ 1.+0.j  0.+0.j]
 [ 0.+0.j  1.+0.j]]
---- ClTensor ----

`σx^0, `σx, `σy, `σz はベクトルとして直行している
[ x.r y.r for x,y in combinate([`σx^0, `σx, `σy, `σz],2)]

-->





<a name="■■ wav データ処理"></a>
<h2>■■ wav データ処理</h2>
<p>
標準配布の PythonSf　の sfCrrntIni.py ファイルには wav ファイルを読み書きする readWv(..)/writeWv(..) 関数を書いてあります。readWv(..) 関数は wav ファイルのデータをベクトル・データに変換します。writeWv(..) 関数はベクトル・データのデータを wav ファイルに変換します。ベクトル・データであれば、PythonSf で自由に操作できます。
<p>
これを使って PythonSf one-liner による楽器音の合成や英語音声の解析を行います。
<p>
この小さな readWv(..)/wirteWv(..) カスタマイズ関数の導入だけで、PythonSf's one-liner による音声処理が可能になることを見てやってください。
<h3>ギター音の合成</h3>
<a href="http://en.wikipedia.org/wiki/Karplus-Strong_string_synthesis">Karplus というギター音の合成アルゴリズム</a>があります。弦を引っかくときのノイズ・データと、減衰フィルタから構成されます。
<!--
http://lab.andre-michelle.com/karplus-strong-guitar
http://www.mathworks.co.jp/products/signal/demos.html?file=/products/demos/shipping_ja/signal/filterguitardemo.html
http://electro-nut.blogspot.com/2009/08/karplus-strong-algorithm.html
音声合成ソフトでの Karplus 操作ビデオ;;http://wn.com/Karplus-Strong_algorithm
-->
<pre>
<code>
<span style="color: #9f009f;">
<b>pythonsf ブロック</b>
//@@
f0=220Hz`       # key 音
SR=44100Hz`     # sampling rate
z_=1/`s         # z^-1: z 変換記号
seed(0)         # random の種
pluckedNoise=rand(SR//f0)-0.5   # 弦を引っ掛けるノイズ
F=0.996/2 (1+z_)                # 減衰フィルタ 1
G=1/(1-F z_^(SR//f0))           # 減衰フィルタ 2: f0 での振動も生成する

# 伝達関数 G に pluked noise を与えたときの応答ベクトル data を作る
data=G.getDgRspns(np.r_[pluckedNoise, [0]*(SR-SR//f0)])

# 最大値を 2^15 に規格化する
data=2^15/max(abs(data))

# 規格化されたベクトル data をカレント・ディレクトリの temp.wav ファイルとして書き込む
writeWv(data, 'temp',(1, 2, SR, 32400, 'NONE', 'not compressed'))
//@@@

<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
f0,SR,z_=220Hz`, 44100Hz`, 1/`s; seed(0);F=0.996/2 (1+z_); G=1/(1-F z_^(SR//f0)); data=G.getDgRspns(np.r_[rand(SR//f0)-0.5, [0]*(SR-SR//f0)]); data*=2^15/max(abs(data)); writeWv(data, 'temp',(1, 2, SR, 32400, 'NONE', 'not compressed'))
</span>
</code>
<br>
</span>
</code>
</pre>
<p>
下のようにフィルタを追加して高周波を落としてやるとナイロン弦でのような音になります。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
f0,SR,z_=220Hz`, 44100Hz`, 1/`s; seed(0); sy();y=sg.lfilter([0.1]*10,[1,1.0], rand(SR//f0)-0.5);F=0.996/4 (1+z_+z_^2+z_^3); G=1/(1-F z_^(SR//f0)); data=G.getDgRspns(np.r_[y, [0]*(SR-SR//f0)]); data=2^15/max(abs(data)) data; writeWv(data, 'temp',(1, 2, SR, 32400, 'NONE', 'not compressed'))
</span>
</code>
<br>
<p>
SciPy の signal sub package には、signal processing のための様々な関数群が用意されています。原理的には如何様なギター音でも合成できます。結構遊べます。
<h3>L/R 識別</h3>
英語の love と rub 音声ファイル love_rub.wav も標準配布のカレント・ディレクトリに入れてあります。16kHz サンプリングの整数値データです。これと PythonSf のワンライナーを使って、日本人の苦手な L/R 識別について調べ・考えてみましょう。
<p>
下のように love_rub.wav は 27545 点のデータからなり、1.728125 秒の長さの音声です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
readWv('love_rub').shape
==============================
(27545,)

ts(); 27645.0/(16 k` Hz`)
===============================
1.7278125*s`
</span>
</code>
</pre>
<p>
<a href="http://sourceforge.jp/projects/sfnet_wavesurfer/releases/">WaveSurfer</a> というソフトを使って、その波形とスペクトログラムの時間変化を下のように可視化できます。
<br>
<img src="./jpg/1111/oneliners_wave_surfer_love_rub.jpg">
<br>
日本人が L/R の区別をできないのは、日本語でのラ行の音に置き換えて聞いてしまうからです。love も rub も「ラブ」聞いてしまうからです。PythonSf を使って子音 L や R だけを取り出して実際に聞いてみましょう。
<h4>L 子音の取り出しと識別</h4>
<p>
L の音は、love_ruv.wav ファイルで 0.358s -- 0.490s の範囲にあります。この時間幅をインデックスで表現すると、5707 -- 7011 の範囲です。下の計算で分かります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# L の音の範囲のインデックスを計算する
27545 0.358s`/(1.7278125*s`)
===============================
5707.28015916

27545 0.490s`/(1.7278125*s`)
===============================
7811.64044131

7800-5700
===============================
2100
</span>
</code>
</pre>

<p>
この L 子音の部分だけを抜き出して、デフォルトの _tmp.wav ファイに書き出します。ただし音声データを急激に 0 にするとプチ・ノイズになるので、最後の 200 点の音は直線状に絞って消します。したの arsq(1,200,-1/200) の部分が、それを行います。readWv(..) が「Numpy の ndarray データを返すこと」と「ndarray と list の積は要素ごとを掛け合わした ndarray でーたになること」を利用しています。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# love_rub.wav から子音 L の部分を抜き出して _tmp.wav ファイルに保存する。
vct=readWv('love_rub')[5700:7800]; writeWv(vct ( (1,)*1900+arsq(1,200,-1/200)) )
===============================
None
</span>
</code>
</pre>
<p>
このようにして抜き出した子音 L の音:_tmp.wav を御自分の耳で是非とも聞いてください。日本語でのラ行の音とは異なることが分かると思います。この子音 L の部分だけ(母音とは独立させて)聞き取れるようになると L/R の誤認識を改善できます。
<p>
でもまだ この子音：L には余分なノイズに近い音が混じっています。私が L の音だと思っているのとは少し違いがあります。その L の音を抜き出すため、フーリエ変換を使います。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 子音 L のフーリエ変換
vc=readWv('_tmp'); plotGr( abs( fftshift( fft(vc) ) ) )
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_wave_surfer_l_fft.jpg">
<br>
<p>
上のグラフでフーリエ変換の絶対値のグラフは左右対称です。画面で左右対称になっていないのは、2100 点のデータをコンピュータ画面上で表示するときに歯抜けが発生するからです。歯抜けが左右対称には起きないためです。1000 点のデータ：±4kHz 弱の領域に限ると、下のように左右対称になります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 子音 L のフーリエ変換結果を中心部分 1000 点に限定してグラフ化する
vc=readWv('_tmp'); plotGr( abs( fftshift( fft(vc) ) )[2100/2-550: 2100/2+550] )
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_wave_surfer_l_fft_1000.jpg">
<br>
子音 L の音から±220 点、±1.67kHz の領域のみの音を取り出して、それ以外とはノイズだとみなしてみましょう。
だとみなしてみましょう
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# 16kHz サンプリングの fft データから 220 点のデータを取り出したときの周波数
16k` Hz` 220/2100
===============================
1676.19047619

# 子音 L の音を±1.6kHz に限定した _tmp.wav ファイルを作る
vc=readWv('_tmp'); v=fft(vc); v[220:-220]=0; writeWv( ifft(v).real )
</span>
</code>
</pre>
<p>
上のようにして作った _tmp.wav ファイルの音を自分の耳で聞いて見てください。love の音から、この部分の音に集中して聞き取るようにすることで love の英語の l が、日本語のラブとは違った音として聞き取れるようになってきます。


<h4>R 子音の取り出しと識別</h4>
to be discussed
<!--
*** R の音
27545 1.040s`/(1.7278125*s`)
===============================
16579.8082836

27545 1.165s`/(1.7278125*s`)
===============================
18572.5737023

vct=readWv('love_rub')[16570:18570]; writeWv(vct ( (1,)*1800+arsq(1,200,-1/200)) )
===============================
None
<== R の音は、なだらかに切り出すだけで、私の聞いている音になった。


vct=readWv('love_rub')[16570:18570]; plotGr(abs(sc.fft.fft(vct))^2)

<h3>和音</h3>
音楽の小理屈;;http://homepage2.nifty.com/sampodo/korikutu/korikutu.html
<h2>対称群</h2>
<p>
kfs:ソート機能付の frozeset
    <== 集合の集合 など frozenset でなければ使えない
        { {1,2,3}, {4,5} }
unhashable type: 'set' at excecuting:set([ set([1,2,3]), set([4,5]) ])
        { kfs({1,2,3}), kfs({4,5}) }
===============================
set([kfs([1, 2, 3]), kfs([4, 5])])
    ×<== == など frozenset でなければ使えない
{1,2,3} == {1,2,3}
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:SS4, SA4; SA4 + Cy(0,1) SA4 == SS4
===============================
True
Sb
=:SS4, SA4; SS4/SA4
===============================
kfs([Sb(0,1,2,3), Sb(0,1,3,2)])

=:SS4, SA4; kfs([ x y x^-1 y^-1 for x,y in mitr(SA4,SA4)])
===============================
kfs([Sb(0,1,2,3), Sb(1,0,3,2), Sb(2,3,0,1), Sb(3,2,1,0)])

=:SS4, SA4; SS=kfs([ x y x^-1 y^-1 for x,y in mitr(SA4,SA4)]); [ x y in SS for x,y in mitr(SS,SS)]
===============================
[True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]
=:SS4, SA4; SS=kfs([ x y x^-1 y^-1 for x,y in mitr(SA4,SA4)]); [ x y in SS for x,y in mitr(SS,SS)]
=:SS4, SA4; SS=kfs([ x y x^-1 y^-1 for x,y in mitr(SA4,SA4)]); SA4/SS
===============================
kfs([Sb(0,1,2,3), Sb(0,2,3,1), Sb(0,3,1,2)])
=:SS4, SA4; SS=kfs([ x y x^-1 y^-1 for x,y in mitr(SA4,SA4)]); Sb(0,2,3,1) SS == SS Sb(0,2,3,1)
===============================
True

</span>
</code>
</pre>

<h2>wikipedia</h2>
<h3>gamma function</h3>
http://en.wikipedia.org/wiki/Gamma_function
χ 自乗分布;;http://en.wikipedia.org/wiki/Chi-squared_distribution など、様々の公式で gamma 関数が出てくる。何故だろうか。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
sy(); ss.gamma(0.5+`i)
===============================
(0.300694617261-0.424967879433j)

sy(); seed(0);N=10; [ ss.gamma(x+1) ~= (x ss.gamma(x)) for x in randn(N)]
===============================
[True, True, True, True, True, True, True, True, True, True]

sy(); seed(0);N=10; [ ss.gamma(x+1) ~= (x ss.gamma(x)) for x in randn(N)+`i randn(N)]
===============================
[True, True, True, True, True, True, True, True, True, True]

sy(); plot3dGr( ss.gamma, [-5     ,5],[+5`i, -5`i])

sy(); vc=klsp(-3,3,300); f=ss.gamma; dct={};for idx,(x,y) in enmitr(vc,vc):dct[idx]=f(x+`i y); render2dRGB(dct)
</span>
</code>
</pre>
<h3>χ自乗検定：Pearson's chi-squared test</h3>
Pearson's chi-squared test;;http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test
( カイ二乗検定;;http://ja.wikipedia.org/wiki/カイ二乗検定 )
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
(44-50)^2/50 + (56-50)^2/50
===============================
1.44

1-quadR(λ x:exp(-x/2)/sqrt(2 pi x), 0, 1.44)
===============================
0.230139340443
</span>
</code>
</pre>
<h2>Building Abstractions with Functions</h2>
http://www-inst.eecs.berkeley.edu/~cs61a/sp12/book/objects.html
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
import urllib as md; shakespeare = md.urlopen('http://inst.eecs.berkeley.edu/~cs61a/fa11/shakespeare.txt'); shakespeare.read()

import urllib as md; shakespeare = md.urlopen('http://inst.eecs.berkeley.edu/~cs61a/fa11/shakespeare.txt'); words:=set(shakespeare.read().decode().split())

=:words; [ w for w in words if len(w)>=5 and w[::-1] in words]
===============================
[u'lived', u'level', u'steel', u'speed', u'repel', u'drawer', u'redder', u'refer', u'sessa', u'madam', u'leper', u'diaper', u'deeps', u'reward', u'devil', u'repaid', u'stops', u'keels', u'spots', u'stink', u'rever', u'leets', u'sleek', u'asses', u'knits', u'minim']
</span>
</code>
</pre>
-->
<div>
<div id="div_1">
<p><input type="button" value="説明を表示する" style="WIDTH:150px"
   onClick="document.getElementById('div_2').style.display='block';
            document.getElementById('div_1').style.display='none'"></p>
</div>
<div id="div_2" style="display:none">
<p><input type="button" value="説明を隠す" style="WIDTH:150px"
   onClick="document.getElementById('div_2').style.display='none';
            document.getElementById('div_1').style.display='block'"></p>
<p>
なんだかんだ。（説明文）
</p>
<p><input type="button" value="説明を隠す△" style="WIDTH:150px"
   onClick="document.getElementById('div_2').style.display='none';
            document.getElementById('div_1').style.display='block';
            document.location='#div_1'"></p>
</div>
</div>
<!--
    mailto: your@email.ne.jp<br>
    Last update: 
高校数学
等比数列・等比級数と循環小数
>私は中学3年生です。数日前卒業式でした。
>数学の分野で学んだところを言うと、おととい数学Iの実数の絶対値のところを理解した感じです。
>ただhop step jumpなところがあり数学Aや数学Bに少し手を出したりもします。

期待できそうな若い人たちを見ていると嬉しくなります、

Python の膨大なライブラリは、理工系の様々な数値実験を手軽に実行可能にしてくれます。循環小数や等比数列・等比級数などの理論を数値実験しながら理解していけます。ここらの話を少し詳しくみてみましょう。

等比数列・等比級数の説明が Wikipedia にあります。これを Python に数値実験で なぞっていきましょう。

●等比数列
等比数列は初項 a と公比 r から定まる [a, ar, ar^2, ar^3, ... ] の数列です。Python で長さ N=10 の数列をリスト内包表記で作れます。

N=10; a,r=3,2; [a r^n for n in range(N)]
===============================
[3, 6, 12, 24, 48, 96, 192, 384, 768, 1536]

N=10; a,r=3,4; [a r^n for n in range(N)]
===============================
[3, 12, 48, 192, 768, 3072, 12288, 49152, 196608, 786432]

//@@
N=10
import sympy as ts
a=3
r=ts.Rational(1)/4
print [a* r**n for n in range(N)]
//@@@
[3, 3/4, 3/16, 3/64, 3/256, 3/1024, 3/4096, 3/16384, 3/65536, 3/262144]

数列の隣の項との比が常に公比 r になっていることが分かります。

最後の例で SymPy の Rational を使いました。有理数クラスを持ってこないと、下のような小数点数値列となってしまいます。微小値ですが、数値計算誤差が入り込んできます。
N=10; a,r=3,1/4; [a r^n for n in range(N)]
===============================
[3.0, 0.75, 0.1875, 0.046875, 0.01171875, 0.0029296875, 0.000732421875, 0.00018310546875, 4.57763671875e-05, 1.1444091796875e-05]

tn.`Σ(tn.chain([2],tn.cycle([2,3,4])))
tn.ClMakeSumUpGn(tn.chain([2],tn.cycle([2,3,4])))[:10]
●等比級数
等比級数は、無限に伸びる等比数列の和です。公比 r が 1 より大きいと、等比数列の和は無限大の値に発散してしまいます。でも公比 r が 1 より小さいときは、数列が無限長であっても、その無限和は有限な値となります。

ここで無限数列という暴れ馬が出てきます。本来ならば有限な人間が操作できるのは有限なものに限られます。でも r が 1 より小さいときは、等比級数は無限長であっても有限和の値を持ちます。なんとか無限数列を扱いたくなります。等比級数の無限数列だけならば、そんなに拘る必要はないのですが、微分・積分が必須となる近代数学の世界では、いたる所で無限数列が顔を出してきます。なんとか無限数列を数学的な厳密性を損なうことなく扱う必要にせまられます。

そこで近代数学は「有限な手続きを組み合わせて極限値に収束させる」ことで無限数列という暴れ馬を乗りこなしていきます。以下の話は、この乗りこなし方を意識しながら見ていくと面白いでしょう。

この方法は無限という暴れ馬は不完全にしか乗りこなせていません。例えば現代数学の偏微分の定義では病的な例が山ほど出てくるのに目を瞑ったままです

等比級数は「等比数列の弟 n 項までの和が、n を無限大にしたとき収束する値」と定義することで、有限な人間が有限な手続きだけで無限数列を扱えるようにします。

「等比数列の弟 n 項までの和」は先の wikipedia で証明されているように、下の公式で表されます。
       n
Sn ≡ Σ a r^k ≡ a+ar+ar^2+ar^3+ ... + a r^n ≡ sum([a, a r, a r^2, a r^3, ... , a r^n])
      k=0

   ≡ a (1-r^(n+1))/(1-r)

数学で新しい公式が出てきたら、数値実験で試してみましょう。具体例で試すことで、その公式の意味が解ってきます。Python を使えば数値実験は簡単です。

n=10; a,r=3,4; sum([a*r**k for k in range(n+1)]), a*(1-r**(n+1))/(1-r)
===============================
(4194303, 4194303.0)

等比級数の公比 r が 1 より大きいとき、Sn=(a (1-r^(n+1))/(1-r) の公式が成り立ちながら、Sn が発散していく様子が、下の Python 式で解ります。

N=11; a,r=3,4; [(sum([a*r**k for k in range(n+1)]), a*(1-r**(n+1))/(1-r)) for n in range(N)]
===============================
[(3, 3.0), (15, 15.0), (63, 63.0), (255, 255.0), (1023, 1023.0), (4095, 4095.0), (16383, 16383.0), (65535, 65535.0), (262143, 262143.0), (1048575, 1048575.0), (4194303, 4194303.0)]
n=10; a,r=3,4; 

逆に等比級数の公比 r が 1 より小さいとき、Sn=(a (1-r^(n+1))/(1-r) の公式が成り立ちながら、Sn が収束していく様子が、下の Python 式で解ります。
N=11; a,r=3,0.4; [(sum([a*r**k for k in range(n+1)]), a*(1-r**(n+1))/(1-r)) for n in range(N)]
===============================
[(3.0, 3.0), (4.2, 4.2), (4.680000000000001, 4.68), (4.872000000000001, 4.872), (4.948800000000001, 4.9488), (4.979520000000001, 4.979520000000001), (4.991808000000001, 4.991808), (4.996723200000001, 4.996723200000001), (4.998689280000001, 4.998689280000001), (4.999475712000001, 4.999475712000001), (4.9997902848, 4.9997902848)]

上で書いた Python 式による数値実験は、ぜひとも自分で行ってください。Python で動かしてください。a や r を様々な値に変てみてください。[(sum([a*r**k for k in range(n+1)]), a*(1-r**(n+1))/(1-r)) for n in range(N)] の部分も自分で考えたコードにしてみてください。余裕があるのならば等比数列以外の数列にもチャレンジしてみてください。


ts(); a,r,k,n=ts.symbols('a r k n');         (ts.summation(a*r**k, (k,0,n))          )
===============================
a*(-r**(n + 1) + 1)/(-r + 1)

N=10; [ sum([a r^k for k in range(n+1)]) - a (1-r^(n+1))/(1-r) for (a,r),n in zip(randn(N,2), range(N))]
===============================
[0.0, 0.0, 2.2204460492503131e-16, 0.0, 2.2204460492503131e-16, 3.5527136788005009e-15, -5.5511151231257827e-17, -2.2204460492503131e-16, 0.0, 5.6843418860808015e-14]

さてSn=(a (1-r^(n+1))/(1-r) の公式は、 |r|＜1 のとき n→∞ にすると S∞ = a/(1-r) となります。r^(n+1)→ 0 となるからです。初項 a=3, 公比 r=0.4 のとき、その等比級数は下のようになります。上でも 5 に近づいていく様子が見えます。

a,r=3,0.4;                                      a/(1-r)
===============================
5.0

import sympy as ts; x=ts.symbols('x'); ts.summation(1/ x**2, ( x,1,10))
等比級数

● 循環小数
<ADDRESS>
</ADDRESS>
-->

</BODY>
</HTML>
