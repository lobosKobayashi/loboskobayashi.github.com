<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HEAD>
<TITLE>one-liners</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Shift_JIS"> 
<LINK href="./style.css" type="text/css" rel="stylesheet">
<STYLE>
</STYLE>
</HEAD>
<BODY>

<H1 class=title>■■ PythonSf one-liners and short codes ■■</H1>
<h2>■■ 目次  </h2>
<a href="#■■ はじめに">■■ はじめに</a><br>
<a href="#■■ Portable PythonSf">■■ Portable PythonSf</a><br>
<a href="#■■ PythonSf vim operation">■■ PythonSf vim operation</a><br>
<a href="#■■ PythonSf Fast Tour">■■ PythonSf Fast Tour</a><br>
<a href="#■■ グラフ表示">■■ グラフ表示</a><br>
<a href="#■■ 積分:quadR(..), quadC(..), quadAn(..)">■■ 積分:quadR(..), quadC(..), quadAn(..)</a><br>
<a href="#■■ 行列演算 2">■■ 行列演算 2</a><br>
<a href="#■■ 代数系">■■ 代数系</a><br>
<a href="#■■ 多項式">■■ 多項式</a><br>
<a href="#■■ 無限長数列と itertools">■■ 無限長数列と itertools</a><br>
<a href="#■■ その他">■■ その他</a><br>
<a href="#■■ Laplace 演算子:`s および遅延演算子 z^-1">■■ Laplace 演算子:`s および遅延演算子 z^-1</a><br>
<a href="#■■ 置換群：Sn(N)">■■ 置換群：Sn(N)</a><br>
<a href="#■■ PythonSf を使った遊び">■■ PythonSf を使った遊び</a><br>
<a href="#■■ 正規表現">■■ 正規表現</a><br>
<a href="#■■ PythonSf Octernion と Cayley/Dickson construction">■■ PythonSf Octernion と Cayley/Dickson construction</a><br>
<a href="#■■ Category Theory">■■ Category Theory</a><br>
<a href="#■■ オペアンプ・フィルタ回路">■■ オペアンプ・フィルタ回路</a><br>
<a href="#■■ Fractal 図形">■■ Fractal 図形</a><br>
<a href="#■■ wav データ処理">■■ wav データ処理</a><br>

<a name="■■ はじめに"></a>
<h2>■■ はじめに</h2>
<!--
PythonSf とは？
    エディタ上でのメモ書き数式
    プリプロセッサ
    Python Upper compatible
    カスタマイズ

短い数式記述
-->
<p>
PythonSf は Python Scientific Calculator の略です。電卓の手軽さで matlab/mathematica クラスの計算処理を可能にします。

あえてコンソール・プログラムとすることで、<b>日常メモ書き数式を使ったエディタ上での計算</b>を可能にし、数式入力のためのユーザー･インターフェースをユーザーごとに最適なものにします。プリプロセッサを介在させることで、積演算子の省略を可能にするなど数学での数式記述に近いメモ書き数式記述と Python との upper compatiblity を両立させます。また名前空間の拡張とカスタマイズ機能により、ユーザーの専門分野に合わせた数式記述を可能にします。これにより可読性を保ちながら、短い計算式：ワン・ライナー記述を可能にします。たぶん大多数のユーザーが、日常計算の九割以上をワンライナーで済ませられるでしょう。また任意の Python コードの実行も可能です。次のような具合です。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 数値の加減乗除べき乗算
(1-2*3/4)^5
===============================
-0.03125

# sin(1/x) value at x=pi
sin(1/`X)(pi)
===============================
0.312961796208

# 数値微分値: sin(1/x) value at x=pi
∂x( sin(2/`X) )(`π)
===============================
-0.162946719226

# シンボリック微分: sin(1/x)
ts(); ∂x( ts.sin(1/`x) )
===============================
-cos(1/x)/x**2

# Groebner 基底をシンボリックに計算する
ts();x,y,z=ts.symbols('x y z');f1,f2,f3=[x+y^2+3z^2-4, 4y^2-5,y^4-5z-10]; ts.groebner([f1,f2,f3], [x,y,z])
===============================
[-5/4 + y**2, 1483/256 + x, 27/16 + z]

# 行列とベクトルの積演算
#  |1,2| * |5|
#  |3,4|   |6]
mt,vc=~[[1,2],[3,4]], ~[5,6]; mt vc
===============================
[ 17.  39.]
---- ClTensor ----

# W:ワット、A:アンペア単位付きの数値計算
ts(); wattage,current=100W`,2.3A`; wattage/current^2
===============================
18.9035916824197*V`/A`

# Bool 体係数多項式の商と剰余
(`P^7+1)/(`P^2+1)
===============================
(Pl(`P^5+`P^3+`P), Pl(`P+1))

x=`P; (x^7+1)%(x^2+1)
===============================
`P+1

# 楕円関数:第一種の不完全/Jacobi 楕円関数の計算
φ,m=pi/3,0.6; sy(); u=ss.ellipkinc(φ,m); ss.ellipj(u,m)
===============================
(0.8660254037844386, 0.50000000000000011, 0.74161984870956643, 1.0471975511965976)

# Sn(4) 置換群における 置換集合:{Sb(2,3,0,1), Sb(1,0,3,2),Sb(1,3,2,0)} の左剰余類
=:SS4; SS4/{Sb(2,3,0,1), Sb(1,0,3,2),Sb(1,3,2,0)}
===============================
kfs([Sb(0,1,2,3), Sb(0,1,3,2), Sb(0,2,1,3), Sb(0,2,3,1), Sb(0,3,1,2), Sb(0,3,2,1)])

# 数値 1234 と文字列 '1' の hash コードを確認する Python テスト・コード
hash(1234), hash('1')
===============================
(1234, 1977051568)

# グラフ描画: sin(1/x) を [0.2, pi] 領域で
plotGr( sin(1/`X), 0.2, pi )
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/plotGrSin1_x.jpg">
<p>
上の数式で、`X は back quote ` 記号により拡張された名前空間に属する変数名です。カスタマイズ機能を使って、`X に加減乗除べき乗算が可能な恒等関数を割り振っています。これにより日常でのメモ書きに近い、計算可能な任意の有理関数を記述できます。同様に `P には、ブール体係数の単項一次多項式(x 相当) を割り振ってあります。これも加減乗除べき乗算可能であり、殆どメモ書き数式と同じままにブール体系数多項式を計算できます。
<p>
特殊記号の漢字∂∇□△ およびギリシャ文字漢字を使えるようにすることでメモ書き数式を数学教科書での記述に近いものにできています。∂x(...) による微分表記の可読性の高さを、漢字文化圏の方には理解してもらえるはずです。
<p>
~[...] 表記により行列やベクトルを表記します。グラフ描画は plotGr(..) に関数と表示領域パラメータを与えるだけです。どちらも最小の手間で行列計算処理すること、グラフを描くことを狙っています。

<h3>PythonSf ワンライナー</h3>
<p>
PythonSf では、多くの計算をワンライナーで行います。複数の Python 式／文を使うときはセミコロンを間に挿入します。上の全ての例がワンライナーです。
<p>
上の計算例で print 命令がないにもかかわらず、最後の式の値が出力されていることにも注目ください。
ワンライナーで複数の式／文を実行するとき、ユーザーが知りたい計算値は、大部分の場合最後の式の値なので、それを自動的にコンソールに出力させています。
<p>
数学での数式記述は、短さと可読性の両立させています。PythonSf 数式でも短く可読性の高い記述を追求しています。ワンライナーの最終式の値の自動出力は その一例です。
<h3>PythonSf は mathematica/matlab クラスの機能を持つ</h3>
<!--
np: numpy package は import numpy as np と import ずみ
sy() 関数を呼び出すことで scipy package/sub_package を sy, ss, .... などの名前で import
一般体への拡張
    oc.Pl([1,2,3,4,5,6])
    # 多項式割り算の商と剰余
    oc.Pl([1,2,3,4,5,6])//oc.Pl([1,1,1])
customize
-->
<p>
上で「 matlab/mathematica クラスの計算処理を可能にする」と書きましたが、これは誇大妄想でも、大言壮語でもありません。PythonSf は Python upper compatible であり、Python package/module として配布されている全ての機能を利用できるからです。
<p>
PythonSf は、sy() 関数呼び出しにより scipy および、その sub package を import します。scipy package は、実用的には十分なほどに matlab の多くの数値計算機能を Python で実装しています。sy() により special function sub package を ss のラベルに import してあるので、上の計算例のように、ss の下で楕円関数 ellipkinc, ellipj を呼び出しています。
<p>
また ts() により  sympy を import し、同時に `x,`y,`z,`t ラベルに sympy のシンボリック変数を割り当てます。これによりシンボリックな演算操作が可能です。上の計算例ではシンボリック微分を行っています。
<p>
さらに numpy の 行列・ベクトルを拡張し一般体も扱えるようにしてあり、Zp(N) や、それを係数とする多項式も扱えるようにしてあります。置換群 Sn(N) も扱えます。Laplace 変換/z 変換のための有理式クラスも用意してあります。
標準の PythonSf だけで学部数学程度の計算能力を備えています。

<h3>習得・記述が容易な PythonSf</h3>
<p>
これらの膨大な数学領域を扱えるにも関わらず、Python を知っているならば、PythonSf の学習コストは一日程度です。文法は Python であり、プリプロセッサで行っているのは、数学での数式記述に近づけることだけであり、Python Upper Compatible を保っているからです。ss が special function subpackage であること、`x,`y,`z が sympy のシンボリック変数であることなどの、ラベルと対応する Python object を覚えるだけで、Python 文法と数学知識から多くの PythonSf 式が 予測・類推できます。上の PythonSf 式例を見ただけで、多くの方は関数電卓以上の計算ができるようになっていると思います。

<p>
あなたが Python ユーザーであるならば、matlab/mathematica など既存数学ソフトのヘビー・ユーザーであっても、PythonSf を強く勧めます。PythonSf は数学ソフトの L.L:Light weight/Script Language です。ブール体係数多項式の商と剰余を計算させたときのように、メモ書き数式と殆ど同じような短い式で記述・計算させられます。
他数学ソフトのユーザーであっても、PythonSf の方が数式記述が容易で簡単に計算させられるので、こちらでの計算のほうが多くなるはずです。
<p>
PythonSf の方が数式記述力の多くが次に述べるカスタマイズ機能によってもたらされます。
<h3>短い数式記述とカスタマイズ機能</h3>
<!--
Sb, `P
customize.py(python path にある), sfCrrntIni.py(current directory にある) の両方を import * してからユーザーが記述した PythonSf 式を実行しています。 
from pysf.ptGrp import kfs,Cy,group,Sb, TyZp, ClZp
グラフ関数
-->
<p>
ユーザーの専門分野によって望ましい数学ソフト機能は異なります。多くのユーザーが、自分に合わせて数学ソフトをカスタマイズする必要に迫られるはずです。逆に自由にカスタマイズできる数学ソフトを望むユーザーも多いはすです。
<p>
PythonSf はカスタマイズ・モジュール customize.py/sfCrrntIni.py の中で拡張された名前空間の短いラベルに、Python program を使って、望ましい機能の Python object を割り当てることによりカスタマイズを実装します。ここで customize.py は python path に置かれます。sfCrrntIni.py は current directory に置かれます。PythonSf は、数式を実行する前に from customize import *, from sfCrrntIni import * を行います。すなわち customize.py/sfCrrntIni.py で宣言された変数、関数、クラスとクラス・インスタンスの名前は全てグローバル変数名前空間に入り込んできます。
<p>
例えば上の例で `P がブール体係数の単項一次多項式でした。これは customize.py の中で下のような Python program を書くことで実現されています。そしてプリプロセッサが `P を k__bq_P___ に置き換えることで、先のブール体系数多項式の割り算 (`P^7+1)/(`P^2+1) は Python は、Python program code として実行できる文字列になります。
<pre>
<code>
<span style="color: #9f009f;">
class PB(oc.Pl):
    """' BF:Bool Field `P polynomial '"""
    def __init__(self, *sqAg):
        oc.Pl.__init__(self, dtype = oc.BF, variable='`P', *sqAg)

k__bq_P___ = PB(1,0)
</span>
</code>
</pre>
<p>
customize.py/sfCrrntIni.py の中で何をどのように import するのか、どんな変数名に何を割り当てるのかはユーザーの自由です。k__bq_P___  に別の機能を持ったインスタンスを割り当てれば、`P は別の意味を持つことになりますす。
<p>
ここで、back quote:` による名前空間の拡張に注目下さい。もし一文字 P にブール体係数の単項一次多項式を割り振り振るのは無謀すぎます。一文字 P は短すぎます。どこかで名前の衝突が発生し予定外の動作になる危険性が潜んできます。でも `P ならば、名前の衝突は PythonSf 式の範囲だけに限られます。名前の衝突に神経質になる必要はありません。すなわち短い PythonSf 式で複雑な計算をさせられるようになります。 (`P^7+1)/(`P^2+1) だけでブール体系数多項式の割り算を計算できてしまいます。
<p>
Current directory に置かれる sfCrrntIni は、そのディレクトリに限ったカスタマイズを記述します。特定の分野に限って、そこで必要となる前提を sfCrrntIni.py のグローバル変数に書き上げておけば、短い PythonSf 式で数多くの処理ができてしまいます。(`P^7+1)/(`P^2+1) でブール体系数多項式の割り算を計算させるような真似をユーザー側で自由にできるようになります。
<p>
適切にカスタマイズしてやることで日常計算の九割以上が PythonSf 式の a one-liner で計算できてしまうようになります。
<p>
カスタマイズ・ファイルに、考えている数式群の前提を、明示的に凝縮させることにも注目ください。
<p>
Mathematica などの notebook でも、計算過程を保存でき後で参照できます。でも、notebook に残っている大部分の式がゴミです。そしてゴミと後で再利用する大事な式や値との区別が不明確です。書いた直後ならば重要な式・考えている文脈が頭の中に残っているので、そのような notebook でも役にたちます。でも一年後などでは notebook を最初から読み下して昔考えていた文脈を再構築せねばなりません。ゴミ溜めの中から重要な式を拾い出して、昔考えていた文脈を頭の中に再構築するには大変な労力が必要となります。
<p>
sfCrrntIn.py などのカスタマイズ・ファイルには何度も参照される重要な式のみが凝縮して残されていきます。一年後でも、そのカスタマイズ・ファイルを読み直せば、当時考えていた文脈が直ぐに戻ってきます。
<h3>PythonSf はヒューマン・インターフェースに優れたコンソール･ソフト</h3>
<!--
前後の文脈の影響を受けないことの方が多い
計算で GUI は面倒なだけ
    マウスを使うことなくキーボードだけで済ませられる
    漢字を使えば微分記号は ∂x で済ませられる
式を与えて計算させるだけ。
    途中で人間とやり取りする必要がありません。
エディタに組み込んで使う
-->
<p>
PythonSf は CUI:コンソール・ソフトです。GUI ではありません。マウスを使うのは 3D グラフを様々の角度から見るときぐらいです。
計算ソフトはグラフ表示を除いたら GUI に向きません。人間が数式を与えて、コンピュータがそれを計算するだけだからです。計算途中で人間とコンピュータが対話する必要性がないからです。∂ などの漢字記号を許せば、CUI の範囲のメモ書き数式でも、数学教科書での数式表記に近づけられます。
<p>
コンピュータに与える数式文字列の入力は使い慣れたエディタで行うのが適切です。文字列の取り扱いで使い慣れたエディタに勝るものはないからです。エディタで計算させたい数式文字列を入力し終わったら、エディタのコンソール処理マクロを使って PythonSf プリプロセッサの CUI インターフェース経由で計算処理をさせ、計算結果を待つだけです。
<p>
PythonSf での計算処理はエディタを使わずに、コンソールで直接行わせることも可能です。先のブール体係数多項式の計算は次のようにコンソールでも行わせられます。
<br>
<img src="./jpg/1111/sfPP_dosBoolPoly.jpg">

<p>
要は sfPP.py プリプロセッサ・モジュールに PythonSf 式文字列を与えることで計算処理を行うわけです。ただ「一日に何十回、何百回も python -u -m sfPP &quot...&quot と決まりきった文字列を入力すること」と「計算結果をコピー・ペーストすること」をエディタ側で行うことで手間を省くことを推奨しているわけです。この&quotpython -u -m sfPP&quot文字列とカーソル下の PythonSf 式文字列とを繋ぎ合わせてコンソール側に実行させるエディタ・マクロを作って使うことを強く推奨します。Vim エディタでの PythonSf 式を実行するマクロの配布と使い方は<a href="#■■ PythonSf vim operation">こちら</a>で詳述します。PythonSf を評価するだけならば、人間がコンソールから手入力することもありだと思います。
<p>
PythonSf をエディタ上で計算させることと、分野に合わせたカスタマイズによる短い数式文字列で計算できることから、PythonSf では one-liners による計算が多用されます。

<h3>多くの計算処理が、PythonSf の自然なワンライナーで可能です。</h3>
<p>
ユーザーに合わせたカスタマイズを施すことで、日常計算の九割以上を PythonSf の自然なワンライナーで計算できてしまいます。これにより数学を使った思考が変わります。群論、圏論、特殊・一般相対論など教科書を写経して勉強しなければならなかった分野を PythonSf で計算確認しながら読み進めていけるようになります。これにより短時間に各分野を習得できるようになります。
<p>
ここで「自然な」とは「if then else 分を含まない」ことを意味しています。計算処理では、普通のプログラムより自然なワンライナーで記述できる場合が多くなります。数学の世界では、理論が十二分以上に整理し尽くされていることが多いので、if then else の場合分けを必要としないことが多いからです。if then else がなければ、そのプログラムは 1 行目から始まるコードをインデントなしで並べていくだけです。インデントなしで単純に縦に並んだコードならば、それを横に並べてワンライナーにしても可読性の悪化は限られます。
<p>
自然なワンライナーに if 文を含まないとしましたが、for ループは含めます。リスト内包表記も含めます。リスト内包表記の後ろに付けられる if 式も含めます。これらは可読性の妨げになりません。ワンライナーの for ループで実行できる文は一つだけであり、インデントを必要としないからです。また multiple iterator:mitr(..) ジェネレータを使うことで、多重ループもワンライナーで自然に扱えます。
<p>
ワンライナーにすることで、一つの纏まった機能を容易に再利用可能になります。エディタの一行コピー・ペーストと必要に応じた一部の修正による計算操作の容易性の意味だけではなく、思考での容易さにも注目してください。ワンライナーは、その一行で一つの纏まった機能として完結しています。前後の文脈に影響されません。その一行は、一年後でも、そのワンライナーだけで完結して、一つのシステムとして纏まって動くのです。このようなワンライナーは思考を積み重ねていく上での一つのユニットとしても再利用できるのです。
<p>
もちろん、無理なワンライナーは避けるべきです。作者自身が 処理内容を読み取れないないようなワンライナーは本末転倒です。PythonSf でも、もちろんブロック記述も可能です。ワンライナーが無理筋なときは積極的にブロック記述にしてください。それでも通常の Python コードの数分の 1 のコード記述量で済むのですから。
<p>
百聞は一見にしかずです。三つの粒子がニュートン力学に従って 8 の字軌跡を描く様子を計算する下の PythonSf スクリプトを見てください
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ブロック</b>
//@@
# initial positions/vectors
inV=[-0.97,0.243,       # 0th particle initial position
      0.97,-0.243,      # 1st parcitle initial position
      0,0,              # 2nd parcitle initial position

     -0.466,-0.432,     # 0th particle initial velocity
     -0.466,-0.432,     # 1st particle initial velocity
      0.932,0.864]      # 2nd particle initial velocity

# N particle problem
N=len(inV)//4

# get force to j-th particle from k-th particle
getFV=λ v,i,k:(λ r=krry(v[2k:2k+2])-krry(v[2i:2i+2]):r/norm(r)^3 if norm(r)!=0 else ~[0,0])()

# sum up forces to j-th paticle
sumFc=λ v,j:sum([getFV(v,j,k) for k in range(N) if j!=k])

# define function:fnc which drives a differential equation dv/dt == fnc(*v).
# kOde(...) needs a fnc(x0,x1,...) whick parameter is expanded.
fnc= λ *v: np.r_[v[2N:],(~[sumFc(v,j) for j in range(N)]).r]

# solve the differential equation numerically untill 2 second on 400 points
# kOde(...) returns 400 x 2N data
mt=kOde(fnc,inV, 2 s`,400)

# draw the trajectories of 3 particles using mt data
pt=plotTrajectory
pt(mt[:,:2])
pt(mt[:,2:4],color=red)
pt(mt[:,4:6],color=green)
//@@@
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/8charTrajectory6.jpg">
<p>
&quot fnc= λ *v: np.r_[v[2N:],(~[sumFc(v,j) for j in range(N)]).r]&quot の部分が少しばかり技巧に走っていますが、その他は Python と numpy に少し詳しければ何の処理をしているのか推測できると思います。この技巧は kOde(...) 上微分方程式のソルバーがベクトル値しか受け付けないため、三個の粒子の位置と速度のベクトル微分方程式を、一個のベクトルだけによる微分方程式で扱うための対策が入っているためです。それを短いワンライナーで記述するために技巧に走っています。その技巧にしても、次の節の説明を読んでもらえば、また numpy 行列のメソッドに詳しければ容易に読み下せる内容です。
<p>
このスクリプトを実行させると、上図のような ８の字軌跡を描きます。
<p>
上のスクリプトでは他人様に読んでもらうためにコメントを追加し、改行や空行を挿入していますが、それらは実際の処理には必要ありません。このスクリプトから それらを取り去れば、Python 文が if then else 無しで、すなわちインデント無しで縦に並んでいるだけになります。ならば、これを横に並べてワン･ライナーにできます。実際に下のワン･ライナーでも全く同様に動きます。また この程度のコード量は 27 インチ LCD の全画面ならばワン･ライナーで表示できます。
<p>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
inV=[-0.97,0.243, 0.97,-0.243, 0,0, -0.466,-0.432, -0.466,-0.432, 0.932,0.864]; N=len(inV)//4; getFV=λ v,i,k:(λ r=krry(v[2k:2k+2])-krry(v[2i:2i+2]):r/norm(r)^3 if norm(r)!=0 else ~[0,0])(); sumFc=λ v,j:sum([getFV(v,j,k) for k in range(N) if j!=k]); fnc= λ *v: np.r_[v[2N:],(~[sumFc(v,j) for j in range(N)]).r]; mt=kOde(fnc,inV, 2 s`,400); pt=plotTrajectory; pt(mt[:,:2]); pt(mt[:,2:4],color=red); pt(mt[:,4:6],color=green)
</span>
</code>
<p>
上の意味の分かりにくい初期数値パラメータの羅列に物理単位系を追加してやれば、この PythonSf 式のワンライナーの塊りが、三体問題の求解の意味を持っていることを表現できます。このスクリプトの作者は、ニュートン力学や微分方程式を熟知しています。このワン･ライナーの読者が一年後の作者など この分野に精通した方なら、下の PythonSf 式を見るだけで、この物理的な意味を、特別な解読作業をすることなく自然に読み取れるでしょう。
<p>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
inV=[-0.97m`,0.243m`, 0.97m`,-0.243m`, 0m`,0m`, -0.466m`/s`,-0.432m`/s`, -0.466m`/s`,-0.432m`/s`, 0.932m`/s`,0.864m`/s`]; N=len(inV)//4; getFV=λ v,i,k:(λ r=krry(v[2k:2k+2])-krry(v[2i:2i+2]):r/norm(r)^3 if norm(r)!=0 else ~[0,0])(); sumFc=λ v,j:sum([getFV(v,j,k) for k in range(N) if j!=k]); fnc= λ *v: np.r_[v[2N:],(~[sumFc(v,j) for j in range(N)]).r]; mt=kOde(fnc,inV, 2 s`,400); pt=plotTrajectory; pt(mt[:,:2]); pt(mt[:,2:4],color=red); pt(mt[:,4:6],color=green)
</span>
</code>
<p>
このワン･ライナーは８の字軌跡だけでなく、任意の二次元三体問題に使えます。<a href="#kOde:常微分方程式">後で説明</a>するように これを少し変形するだけで任意の三次元 N 体問題に拡張できます。
<p>
このワン･ライナーは、これだけで独立しています。Mathematica や Matlab での NoteBook とは異なり、それ以前に書かれた式に依存しません。この一行だけで完結して動作します。ですから、この一行をエディタ上で copy and paste してやり、初期条件パラメータを変更するだけで、様々の軌跡を検討できます。N 体問題についての考察を積み重ねていくとき、 このワン･ライナー・ユニットを何度も再利用できます。
<p>
逆に、このような様々に利用できるワンライナーを各分野ごとに蓄積していくことで、その分野を深く理解したことにもなります。この意味で PythonSf は数学思考をコンピュータを活用したものに変えます。今まで抽象的・思弁的な思考のだけで、写経を何度も繰り返すことで理解しなければならなかった分野であっても、コンピュータを活用して実際の問題に適用しながら理解していくことを PythonSf は可能にします。
<p>
以下では、PythonSf のワンライナーで可能な計算処理を数多く羅列していきます。以下の説明は PythonSf の計算処理機能のギャラリーともいえます。これらは PythonSf の威力を示ものになると思います。
<br>
<br>
<br>
<h3>なぜ SAGE ではなく PythonSf か？</h3>
<p>
Python での数学処理について詳しい方の中には「なぜ SAGE を使わないのか」と思う方もいると思います。理由は SAGE は数学を作る側：職業数学者のためのソフトであり、数学を使う側にとっては PythonSf の方が便利だからです。PARI/GP、GAP、Maxima、SINGULAR などの数式処理パッケージが統合されていることから SAGE が数学を作る側のソフトだと分かります。これらを必須とするような方は職業数学者だと思います。
<p>
SAGE と PythonSf は どちらも Python の数学ソフトであり Python で扱う数学については重複する部分も多くあります。大きな違いは、SAGE は 数学の定理や公式を作る側のソフトであり、PythonSf は その定理や公式を実際に応用するためのソフトだという点です。電卓の手軽さで・９割り以上をワン・ライナーで使うというてんです。
<p>
Python で数学を使うことに関しては、多くの場面で SAGE より PythonSf の方が優れています。現在 SAGE を使っているとしても、scipy, sympy, matplotlib など python だけでも記述できるような対象しか扱っていない方ならば、PythonSf の方が便利です。

SAGE を使っている職業数学者の方でも、SAGE の notebook で計算させるより、vim/emacs など日常使っているエディタから計算させるほうが便利だと思う方が多数派でしょう。そのような方は是非とも PythonSf も試してください。御自分の定理や公式を Python で実装してあるならば、それを PythonSf でも動かして見てください。それの大部分を PythonSf のワン・ライナー式で動かすようにカスタマイズしてみてください。その学習コストもカスタマイズも一日程度のはずです。

<a name="■■ Portable PythonSf"></a>
<h2>■■ Portable PythonSf</h2>
<p>
評価版のインストーラーは設けずに、portable な PythonSf を配布します。このほうがユーザ環境の変更を招かないので喜ばれると考えます。コンピュータにインストールするにしても、portable PythonSf のなかから、いくつかのディレクトリと py ファイルを python lib path にコピーするだけです。

また この配布には、vim editor 上で PythonSf 式の計算を可能にするエディタ・マクロを組み込んだ vim も一緒に配布します。
<h3>Small PythonSf</h3>
<p>
<a href="https://box.yahoo.co.jp/guest/viewer?sid=box-l-ixochkktrwgsokcnarhwwuwqe4-1001&uniqid=ff820895-9ac1-4304-87fa-8f92220ae07a&viewtype=detail">smallWithoutPython_v096a_win7_64.zip</a> は scipy や vpython,sympy,matplotlibといった PythonSf に必要なライブラリが既にインストールずみ、または別にインストールする方のために設けました。80MB と小さいサイズに収まっています。
<p>
現在のところ windows7 64ビット向けのみを用意しています。でも 64ビットなのは vim エディタ部分だけであり、PythonSf 自体は Xp でも Windows7 32bit でも動作します。
<h3>big PythonSf</h3>
<p>
<a href="https://box.yahoo.co.jp/guest/viewer?sid=box-l-ixochkktrwgsokcnarhwwuwqe4-1001&uniqid=8dea2ba7-f642-4424-941b-f2cfccfd121c&viewtype=detail">bigIncludingPython_v096a_win7_64.zip</a> は Python や scipy,sympy,vpython や  matplotlibといった PythonSf に必要なライブラリ全てを含んだ portable な環境です。Python でさえもインストールする必要がありません。その代償として 1.2GB  と大きなサイズになってしまいました。でも現在の USB メモリならば問題なく持ち運べるでしょう。
<p>
現在のところ windows7 64ビット向けのみを用意しています。でも 64ビットなのは vim エディタ部分だけであり、PythonSf 自体は Xp でも Windows7 32bit でも動作します。
<h3>Install PythonSf</h3>
<p>
PythonSf を気に入ってもらい、自分の Python 環境にインストールしたいとき、bigIncludingPython_v096_win7_64 を使っているときは簡単です。このディレクトリを PythonSf など自分の好きな名前に変更して、望みの HDD の場所にコピーし、そこに path を通すだけです。
<p>
smallWithoutPython_v096_win7_64 を使っているときは、既に Python がインストールされているので、そこにディレクトリ pysf とファイル sfPP.py をコピーします。python\\Lib\site-packages\ ディレクトリの下に pysf ディレクトリは コピーします。python\\Lib\ の下に sfPP.py をコピーします。
<p>
どちらの場合も実際に計算作業をするディレクトリに sfCrrntIni.py と Vc7VrfyMDdRt10D.zip ファイルをコピーしておく必要があります。Vc7VrfyMDdRt10D.zip ファイルがキーファイルになっており、これがないと評価版の PytonSf が動作しません。
<p>
Portable PythonSf に含まれる vim も使い続けるときは、そのディレクトリ以下を全部 HDD にコピーし、そこに path を通さねばなりません。 

<h3>評価版とコマーシャル版の違い</h3>
<p>
評価版とコマーシャル版の違いは下の二点だけです。
<ol>
<li>動作開始時に 5 秒のディレー時間が入る
<li>カレント・ディレクトリにキーファイル:Vc7VrfyMDdRt10D.zip が必要となる
</ol>
<p>
PythonSf を気に入っていただきコマーシャル版を希望される方はカレント・ディレクトリにできている yourMichine.code ファイルを添付したメールを kverifierlab@yahoo.co.jp に送付ください。
<p>
なおコマーシャル版の価格 PythonSf は 5000 円です。

<a name="■■ PythonSf vim operation"></a>
<h2>■■ PythonSf vim operation</h2>
<p>
PythonSf は、計算での human interface に優れた CUI ソフトであり、その機能はユーザーが日常使っているエディタに組み込んで使うことを想定して作られています。その一例として、vim エディタで PythonSf を使うためのマクロ:pysf.vim を vim 環境込みで portable PythonSf の中に同梱して配布します。普段の思考も vim エディタ上で行う理系の方にとって PythonSf と pysf.vim の組み合わせは life changing なソフトになるでしょう。
<p>
もし portable 版の vim ではなく自分の vim を使いたいのならば portable PythonSf のなかの vim\vim73\plugin\pysf.vim ファイルを御自分の vim73\plugin ディレクトリにコピーしてください。キー・バインドをカスタマイズしたいときは pysf.vim の nnorremap 行を変更してください。pysf.vim は全部で 300 行程度の小さなマクロです。vim マクロが分かっている方ならば容易にカスタマイズできます。以下この pysf.vim が vim の plugin ディレクトリ入っていることを前提に、このマクロの使い方を説明していきます。
<p>
pysf.vim マクロは単純で小さなマクロですが PythonSf 式の計算以外にも、通常の python code, OS コマンドの実行も行えます。C 言語などコンピュータにインストールされている任意の言語系のコンパイルや実行も可能です。これらのマクロは大きく分けて「ワン・ライナー系のマクロ」、「ギリシャ文字記号入力マクロ」と「ブロック実行系のマクロ」の三つに分けられます。まずは単純なワン･ライナー系のマクロから見ていきましょう。
<p>
同梱する vim は <a href="http://www.kaoriya.net/software/vim">kaoriya さんの vim </a>です。日本人向けの配布であり、PythonSf 式でのギリシャ文字や記号を漢字コードで表記するのにトラブルが少ないと思います。
<h3>ワン･ライナー系 vim マクロ</h3>
<h4>PythonSf ワン・ライナー式の計算</h4>
<p>
vim エディタでの PythonSf のワン･ライナー式文字列をこのマクロで計算させるには、その文字列行の上にカーソルを置いてノーマル・モードで ;j 操作を行います。インサート・モード中ならば Alt+;j 操作を行います。行います。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
3+4
===============================
7
</span>
</code>
</pre>
<img src="./jpg/1111/one_liner_python_sf_eq.jpg">
<p>
;j 操作により 3+4 文字列の前に python -u -m sfPP 文字列を追加して OS に実行させ、CUI が返した文字列を vim エディタの最下行のコマンド・ラインに表示します。
<img src="./jpg/1111/one_liner_python_sf_eq_execute.jpg">
<p>
その計算結果を vim エディタ編集結果として残したいときは、ノーマル・モードでの p 操作を行います。
<img src="./jpg/1111/one_liner_python_sf_eq_execute_paste.jpg">
<p>
PythonSf は Python Upper Compatible ですから、普通の Python ワンライナーも ;j 操作で実行できます。vim ノーマル・モードで、下の Python ワン・ライナー文字列行の上にカーソルを持っていき ;j 操作を行えば、Python での extractall(..) 関数動作を実際に行います。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
import tarfile as tr;tr.open('pycrypto-2.0.1.tar.gz', 'r').extractall()
IOError:You may use nonexistent variable name:[Errno 2] No such file or directory: 'pycrypto-2.0.1.tar.gz'
</span>
</code>
</pre>
<p>
ちなみに ;j 操作で行っている vim マクロは、下の 9 行です。
<pre>
<code>
function! ExecPySf_1liner()
    let l:strAt = __getLineOmittingComment()
    let l:strAt = 'python -u -m sfPP "' . l:strAt . '"'
    echo l:strAt
    let @0= system(l:strAt)
    let @" = @0
    " clipboard に unnamed が設定されてないとき、a* にも戻り値を設定する
    " vim 以外のアプリケーションからも計算結果を参照できるようにするため
    " 下は clipboard += unnamed になっているときにも必要です。そのときは
    " p で past されるのは @* の中身だからです。
    let @* = @0
    echo @0
endfunction         
</code>
</pre>
<p>
このように小さな vim マクロですから、このような操作が気に入らない方は御自分に合うように簡単にカスタマイズできるはずです。
<p>
<b>注意</b>
PythonSf ワン･ライナーを実行するとき文字列はシングル・クォート:'....' で表記しなければなりません。通常の Python で使われるダブル・クオート:&quot;...&quot; を使えません。PythonSf ワン･ライナー式文字列を sfPP.py プリプロセッサへの文字列引数として渡しているからです。その時に python -u -m sfPP &quot;...&quot; とダブル・クォートで PythonSf 式文字列を囲んでいるからです。
<h4>OS コマンド実行</h4>
<p>
pysf.vim マクロはノーマル状態で、コマンド文字列の上にカーソルを置いて ;a 操作することにより OS コマンドも実行できます。下のような具合です

<pre>
<b>dir コマンド文字列</b>
dir cl*.pvl
</pre>
<img src="./jpg/1111/one_liner_command_execute.jpg">
<p>
dir コマンドぐらいでは あまり嬉しくもないでしょうが、任意のプログラムを起動できることで多くのことが可能になります。例えば vim 画面で下の文字列の上にカーソルを置いて ;a 操作を行えば 10 ページ目で pdf ファイルを開いてくれます。下の行を copy and paste して page パラメータ 10 と ファイル名を変えてやれば、そのページで指定された pdf ファイルを開きます。
<pre>
<b>ページ指定を伴う acrobat 起動コマンド文字列</b>
C:"\Program Files (x86)\Adobe\Reader 9.0\Reader\AcroRd32.exe" /A page=10 D:\utl\vim73\byte_of_vim_v051.pdf
</pre>
<p>
ちなみに、OS コマンドを実行させている vim マクロ関数は Exec_command() です。興味のある方・カスタマイズしたい方は pysf.vim ファイルを参照ください。
<h4>start コマンド実行／PythonSf 計算</h4>
<p>
上の pdf ファイルを開くコマンドは戻り値を必要としません。でも vim の子プロセスとしてコマンドを実行し pdf ファイルを開いているので、その pdf ファイルを開いている間は下の vim ファイルの編集ができなくなってしまいます。これを避けるために windows では start を付けて別プロセスでコマンドを実行させます。このためにはノーマル・モードで ;f 操作を行います。
<p>
Windows では「start fileName」を実行させると fileName の拡張子に関連付けられたアプリケーションが そのファイルを引数として起動されます。これを利用するとコンピュータ操作が便利になります。たとえば vim ノーマル・モードで URL 文字列行の上にカーソルを持っていき ;f 操作をすると、デフォルトの web ブラウザが その URL で立ち上がります。
<pre>
<b>URL の ;f すなわち start 実行</b>
http://www.nhk.or.jp/daily/english/
</pre>
<br>
<b>上の ;f の結果、NHK 英語ニュースの web ページがデフォルトのブラウザで開きます</b>
<br>
<img src="./jpg/1111/one_liner_start_nhk.jpg">
<p>
PythonSf 式でグラフ表示をさせたまま別の PythonSf 式を実行させたいことが よく発生します。このときは ;s 操作を行い PythonSf を vim とは別プロセスで実行させます。これによりグラフをさせたままで、 vim の操作を並行して実行できます。複数個のグラフを表示さながら、別の PythonSf 式を計算させられます。 
<pre>
<b>コメント + ;; + PythonSf 式文字列</b>
PythonSf グラフ表示式;;plotGr(sin, 0,2pi)
</pre>

<h4>ワン・ライナーの前コメント</h4>
<p>
ワン・ライナー文字列の前側にコメントを書いておきたいことが良く発生します。URL などの長い文字列だと後ろ側にコメントを書いても、どこからがコメント文字列か一目では読み取れません。そのため pysf.vim マクロでは連続する二つのセミコロン ;; をデリミタとし、その前の文字列をコメントとみなします。例えば下の URL文字列行にカーソルを持っていき ;f 操作をすると NHK の英語ニュース音声をダウンロードできるページに飛んでいきます。PythonSf 式文字列行にカーソルを持っていき ;j 操作をすれば 3+4 を計算します。 
<pre>
<b>コメント + ;; + URL 文字列</b>
NHK 英語ニュース;;http://www.nhk.or.jp/nhkworld/english/radio/program/index.html

<b>コメント + ;; + PythonSf 式文字列</b>
PythonSf 式テスト;;3+4
</pre>
<h3>ブロック系 vim マクロ</h3>
<p>
PythonSf ブロック式や複数行にわたる Python コード、C プログラムなどの一般プログラム・ブロックのコンパイルや実行も pysf.vim マクロから行えます。
<p>
pysf.vim でのブロック行とは、下のように //@@ と //@@@ の文字列行で挟まれた間のテキスト行のことを意味します。pysf.vim は このブロック行に対して PythonSf ブロック式の計算をさせたり Python プログラムを実行させたり、コンパイルさせたりします。
<pre>
<code>
<b>pysf.vim でのブロック</b>
//@@
    ・
  ブロック行
    ・
//@@@
</code>
</pre>

<h4>PythonSf ブロック式の計算</h4>
<p>
PythonSf 計算で、ワン･ライナーでの計算よりも複数行での計算のほうが望ましいときは //@@ から //@@@ の間のブロック行で計算式を記述します。vim ノーマル・モードで、//@@ と //@@@ の間のどれかの行にカーソルを置いておき、;k 操作をすると pysf.vim マクロは //@@ と //@@@ の間の block 行をカレント・ディレクトリの temp.py ファイルに書き出します。そして python -u -m sfPP -fs temp.py を実行して、 PythonSf プリプロセッサに temp.py を python が扱える __tempConverted.py ファイルを生成させます。その後に pysf.vim は python -u __tempConverted.py を実行させます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ブロック式</b>
//@@
# 07.11.26 beer barrel form pulley
# width = 5 meter, hieght = 1meer,  depth 1 meter, 

#import sf
import pysf.sfFnctns as sf

N, M =20,5
dctUpper={}
dctLower={}
for pos, index in zip(sf.masq([-2.5,N+1, 5.0/N],[-0.5,M+1, 1.0/M]), sf.mrng(N+1,M+1) ):
    dctUpper[index] = (pos[0], 1, pos[1])
    dctLower[index] = (pos[0],-1, pos[1])

N, M = 10,5
dctLeft ={}
dctRight ={}
for (theta, z), index in zip(sf.masq([sf.pi/2, N+1, -sf.pi/N], [-0.5, M+1, 1.0/M])
                            ,sf.mrng(N+1,M+1) ):
    dctRight[index] = [2.5+sf.cos(theta), sf.sin(theta),z]
    dctLeft[index] = [-2.5-sf.cos(theta), sf.sin(theta),z]


sf.renderFaces(dctUpper)
sf.renderFaces(dctLower)
sf.renderFaces(dctLeft)
sf.renderFaces(dctRight)

dctLeft ={}
dctRight ={}
N=40
for (theta, z), index in zip(sf.masq([sf.pi, N+1, -2*sf.pi/N], [-0.5, M+1, 1.0/M])
                            ,sf.mrng(N+1,M+1) ):
    dctRight[index] = [2.5+(2-sf.cosh(z))*sf.cos(theta), (2-sf.cosh(z))*sf.sin(theta),z]
    dctLeft[index] = [-2.5-(2-sf.cosh(z))*sf.cos(theta), (2-sf.cosh(z))*sf.sin(theta),z]

sf.renderFaces(dctLeft, blMeshOnly=True, meshColor=sf.red)
sf.renderFaces(dctRight, blMeshOnly=True, meshColor=sf.red)
//@@@
</span>
</code>
</pre>
<p>
ちなみに、OS コマンドを実行させている vim マクロ関数は ExecPySf_Bloc() です。興味のある方・カスタマイズしたい方は pysf.vim ファイルを参照ください。
<p>
なお、この PythonSf ブロック式は下のようなベルト・コンベアの 3D 図を描画しています。
<br>
<img src="./jpg/1111/block_python_sf_comveyer.jpg">
<p>
コンベヤのプーリーは上の 3D 図のように中央が膨らんでいます。直感に反すでしょうが、これによりコンベヤ・ベルトをプーリーの中央に保っています。
<p>
逆に下のように赤いコンベヤ・プーリーの中央を凹ませると、コンベヤ・ベルトはプーリーの端に引き寄せられ、コンベヤが壊れてしまいます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ブロック式</b>
//@@
# 07.11.26
# width = 5 meter, hieght = 1meer,  depth 1 meter, 

#import sf
import pysf.sfFnctns as sf

N, M =20,5
dctUpper={}
dctLower={}
for pos, index in zip(sf.masq([-2.5,N+1, 5.0/N],[-0.5,M+1, 1.0/M]), sf.mrng(N+1,M+1) ):
    dctUpper[index] = (pos[0], 1, pos[1])
    dctLower[index] = (pos[0],-1, pos[1])

N, M = 10,5
dctLeft ={}
dctRight ={}
for (theta, z), index in zip(sf.masq([sf.pi/2, N+1, -sf.pi/N], [-0.5, M+1, 1.0/M])
                            ,sf.mrng(N+1,M+1) ):
    dctRight[index] = [2.5+sf.cos(theta), sf.sin(theta),z]
    dctLeft[index] = [-2.5-sf.cos(theta), sf.sin(theta),z]


sf.renderFaces(dctUpper)
sf.renderFaces(dctLower)
sf.renderFaces(dctLeft)
sf.renderFaces(dctRight)

dctLeft ={}
dctRight ={}
N=40
for (theta, z), index in zip(sf.masq([sf.pi, N+1, -2*sf.pi/N], [-0.5, M+1, 1.0/M])
                            ,sf.mrng(N+1,M+1) ):
    dctRight[index] = [2.5+sf.cosh(z)*sf.cos(theta), sf.cosh(z)*sf.sin(theta),z]
    dctLeft[index] = [-2.5-sf.cosh(z)*sf.cos(theta), sf.cosh(z)*sf.sin(theta),z]

sf.renderFaces(dctLeft, blMeshOnly=True, meshColor=sf.red)
sf.renderFaces(dctRight, blMeshOnly=True, meshColor=sf.red)

thetaS = 2.05117740593
#Z0 = 0.48121182506 # real value
Z0 = 0.35   # exagerated value
lstRear =[(2.5+sf.cosh(0.5)*sf.cos(thetaS),1,-0.5), (2.5, sf.cosh(-Z0), -Z0)]
lstFront =[(2.5+sf.cosh(0.5)*sf.cos(thetaS),1,0.5), (2.5, sf.cosh(Z0), Z0)]
N=30
for theta in sf.arSqnc(sf.pi/2, N+1, -sf.pi/N):
    lstRear.append( (2.5+sf.cosh(Z0)*sf.cos(theta), sf.cosh(-Z0)*sf.sin(theta),-Z0) )
    lstFront.append( (2.5+sf.cosh(Z0)*sf.cos(theta), sf.cosh(Z0)*sf.sin(theta),Z0) )

sf.plotTrajectory(lstRear, blAxis=False)
sf.plotTrajectory(lstFront, blAxis=False)
//@@@
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/block_python_sf_concave_comveyer.jpg">
<p>
このような曲面の組み合わさった 3D 図を word などの drawing soft を使って書くのは大変です。理系の方ならば上のような PythonSf 数式で描かせたほうが楽だと思います。如何でしょうか。

<h4>Python ブロック実行</h4>
<p>
Python のプログラム・コードについても、PythonSf のブロック計算と同様に pysf.vim マクロは //@@ と //@@@ で囲まれたブロック行を ;p で実行します。
<pre>
<code>
<span style="color: #9f009f;">
<b>Python ブロック実行</b>
//@@
#from;;http://www.daniweb.com/forums/thread113274.html
#from TurtleWorld import *
#TurtleWorld()
import turtle as t

def Koch(length):
    if length&lt=2 :
        t.forward(10*length)
        return

    Koch(length//3)
    t.left(60)
    Koch(length//3)
    t.right(120)
    Koch(length//3)
    t.left(60)
    Koch(length//3)

t.setpos(-300,10)
Koch(60)
t.exitonclick()
</span>
</code>
</pre>
<p>
<img src="./jpg/1111/block_python_kocho.jpg">
<p>
なお、PythonSf は python に upper compatible であり、上の python ブロック・コードを PythonSf 式としても実行できてしまいます。vim エディタ上の ;k 操作でも同じプログラム動作を行ってしまいます。同じ Koch 曲線を描きます。ただし PythonSf プリプロセッサが動いてしまいます。少しだけ余分に CPU 時間を消費します。実際には体感できませんが。PythonSf 評価版では 5 秒の遅れが入るので体感できます。
<p>
ちなみに、Python ブロック実行をさせている vim マクロ関数は ExecPy_Bloc() です。興味のある方・カスタマイズしたい方は pysf.vim ファイルを参照ください。

<h4>ブロック・コマンド連続実行</h4>
<p>
ブロック行に連続して書いたコマンド文字列行を実行していくことで、任意言語のコンパイル・リンク・実行をpysf.vim マクロで行わせられます。pysf.vim マクロでは ;e 操作に この動作を割り当ててあります。
<p>
vim ノーマル・モードで //@@ ... //@@@ ブロック行の何処かにカーソルを置いて ;e 操作を行うと pysf.vim マクロはカレント・ディレクトリの __temp ファイルにブロック行の中身を書き出します。そして //@@@ に連続して // 文字列で始まる行が存在すると、その行を OS への操作とみなして連続して実行していきます。 //copy ...、 //gcc .... などと // で始まるコピー・コマンドやコンパイル・コマンド文字列を書いておけば、pysf.vim はブロック行に書かれた内容をコンパイルしていきます。下に C++ プログラムでの例を示します。@@@ の次にカレント・ディレクトリの __temp ファイルを a.cpp にコピーし、a.cpp を gcc でコンパイルしています。
<pre>
<code>
<span style="color: #9f009f;">
<b>ブロック・コマンド連続実行： C プログラムのコンパイルと実行</b>
//@@
//06.01.28  test valarray sum <== OK
#include &;t;valarray&gt;
#include &;t;iostream&gt;   // iostream cannot co-exist with systemc.h
using namespace std;

int main()
{
    valarray&lt;int&gt; vlrInAt(5);  // 要素が 0 で初期化された size 5 の vararray
    vlrInAt[0]=1;
    vlrInAt[1]=2;
    vlrInAt[2]=3;
    vlrInAt[3]=4;
    vlrInAt[4]=5;
    
    cout &lt;&lt; vlrInAt.sum() &lt;&lt; endl;
    return 0;
}
//@@@
//copy __temp a.cpp /y
//g++ a.cpp  -O0 -g
//a

</span>
</code>
</pre>
<br>
<img src="./jpg/1111/block_gpp_block_continue.jpg">

<p>
ブロック・コマンド連続実行 ;e 操作では、//@@@ に連続する行に任意のコマンド文字列を記述できます。ブロック行を Haskell で実行したければ下のように書くだけです
<pre>
<code>
<span style="color: #9f009f;">
<b>ブロック・コマンド連続実行</b>
//@@
data Variables = C Char | S String | I Int | Iex Integer | D Double | F Float
data VarList a = VarX a [Variables]

instance Show Variables where
    show (C ch)  = "C "   ++ show ch
    show (S str) = "S "   ++ show str
    show (I m)   = "I "   ++ show m
    show (Iex n) = "Iex " ++ show n
    show (D o)   = "D "   ++ show o
    show (F p)   = "F "   ++ show p

instance Show a => Show (VarList a) where
    show (VarX x y) = "Var " ++ show x ++ " " ++ show y

x = VarX 11 [(Iex 21), (S "fd"), (C 'a')]

main = do
    print x
//@@@
//copy __temp temp.hs /y
//D:\lng\Haskell\ghc6121\bin\runghc.exe temp.hs

Var 11 [Iex 21,S "fd",C 'a']
</span>
</code>
</pre>
<p>
上の Haskell 実行コマンドではフル･パスで指定しているので、path 環境変数への設定さえなしで実行しています。
<p>
このようなブロックの連続実行は小さな大量に発生する小さなテスト・プログラムの実行に便利です。小さなテスト・ファイルが何十、何百も溜まってくると、それらを管理できなくなってしまいます。でもブロック・コマンドの連続実行ならば一つのファイルのなかにテスト・コードを全部纏めて置いておけます。コンパイル・オプション、リンク・オプションやテスト実行での引数も そのファイルの同じ場所に残っています。そのブロック行の場所にカーソルを持っていくだけで、以前のテスト結果を何時でも再現できます。
<p>
ちなみにブロック・コマンドの連続実行マクロは関数は Exec_BlockCntn() です。興味のある方・カスタマイズしたい方は pysf.vim ファイルを参照ください。まだ Exec_BlockCntn() 関数はエラー処理が殆ど書かれていないので、そこらを改善すべきです。しかし この状態でも便利に使えるのでテスト的に公開します。

<h3>ギリシャ文字 ∂ 記号入力 ctrl+a+g</h3>
<p>
日本語 Windows ならば IME を使ってギリシャ文字や ∂ 記号を入力できます。でも数式入力の最中にIME のオン･オフ操作を入れることは面倒です。それを対策するために vim の入力モードでアルファベット文字の直後で ctrl+a+g 操作をしたとき、そのアルファベットをギリシャ文字漢字に変更するマクロを作りました。
<p>
∂ 記号は r` 文字の直後に ctrl+a+g 操作で入力します。
<p>
数式入力中に IME のオン・オフにイラつくかたは御利用ください。

<a name="■■ PythonSf emacs operation"></a>
<h2>■■ PythonSf emacs operation</h2>
<p>
まだ在りません。

<a name="■■ PythonSf Fast Tour"></a>
<h2>■■ PythonSf Fast Tour</h2>
<p>
PythonSf は数式記述を簡便なメモ書き数式に近づけるためプリプロセッサを介在させ、 少しだけ Python 文法を拡張しています。この拡張部分を知っておかないと、PythonSf 数式を見ても意味が分らない部分が出てくると思います。PythonSf が始めての方は、この節だけは目を通しておかれたほうが理解が早いと思います。

<h3>積演算子の省略</h3>
<p>
数学では積の演算子が省略されることが普通です。PythonSf でも それを踏襲します。
<p>
PythonSf は普段メモ書きしている数式に近い記述で計算処理することを目指して作りました。このためにプリプロセッサを介在させています。このプリプロセッサにより積演算子の省略を可能にしています。下のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
a,b=3,4; 2 a b
===============================
24

<b>PythonSf ワンライナー</b>
a,b=3,4; 2a + 3b
===============================
18

<b>PythonSf ワンライナー</b>
a,b=3,4; 2(a+b)
===============================
14

<b>PythonSf ワンライナー</b>
a,b=3,4; a (a+b)
===============================
21

<b>PythonSf ワンライナー</b>
a,b=3,4; ab
name 'ab' is not defined at excecuting:ab

<b>PythonSf ワンライナー</b>
a,b=3,4; a(a+b)
'int' object is not callable at excecuting:a(a+b)
</span>
</code>
</pre>
<p>
ただし Python 文法との共存を許すため、 ab とか a(a+b) のようには書けません。Python 文法では ab 文字列は a*b ではなく、変数 ab とみなすからです。また a(a+b) は、 a と (a+b) の積ではなく、引数 a+b を関数 a により関数呼び出しする意味になるからてす。

<h3>べき乗演算子:^</h3>
<p>
数学ではべき乗演算子に ^ を使うことが普通です。** 演算子を使うのはログラミングの世界での話です。一方で Python では ^ は bit exor 演算子の意味になります。
<p>
PythonSf プリプロセッサでは Python との互換性よりも、数学記述に近いメモ書き数式のほうを選択し ^ をべき乗演算子の意味にしました。bit exor 演算を行せるときは \^ を使うことにしました。もちろん ** 演算子をべき乗の意味に使うことも可能です。下のような具合です

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
2^4, 2\^4, 2**4
===============================
(16, 6, 16)
</span>
</code>
</pre>
<p>
PythonSf 式は Python Upper Compatible だといっていますが、ここの ^ 演算子のように、厳密には Python Upper Compatible ではない箇所が幾つかあります。Python では sin (pi/3) とスペースを挿入しても sin 関数を計算をしてくれますが、PythonSf 式では sin*(pi/3) の意味になってしまいます。でも bit exor 演算など殆どの方は一年に何回も使わないはすです。関数呼び出しの括弧の前にスペースを必要とする方もいないと思います。このような些細なことがらだけならば「PythonSf は Python Upper Compatible だ」といっても許されると主張します。 

<h3>バック・クォートと名前空間</h3>
<p>
数式の記述は、できるだけ短く書けることが望まれます。数学では x,y が何であるかを説明しなくても x+y と書いたら、二変数の足し算すなわち二変数関数のことを意味します。でもプログラミングの世界でそんなことをしたら「未定義の x,y を使っている」エラーとなって動きません。
<p>
グローバルな x,y ラベルに何らかのインスタンスを予めアサインしておけば未定義エラーを避けられます。でも x,y のような短い変数名をグローバルな定義済みにすることは Python コードに悪影響を与えてしまいます。
<p>
PythonSf では、この数学とPython の衝突を回避するために、変数名の前後に複数のバック・クォートを追加できるようにしました。このように名前空間を拡張することで、既存の Python コードにはない、数学向けの短い変数名を使用できるようにしました。
<p>
たとえば `X に加減乗除べき乗算が可能な恒等関数クラスの callable instance を割り当てておくことで `X^2+3`X+1 を二次関数として扱えるようにしています。下のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
(`X^2+3`X+1)(1)
===============================
5
<b>PythonSf ワンライナー</b>
(`X^2+3`X+1)(2)
===============================
11
</span>
</code>
</pre>
<p>
`Y に、引数の二番目を取り出す機能を追加した加減乗除べき乗算が可能な恒等関数クラスの callable instance を割り当てておくことで `X^2+3`Y を二変数の二次関数として扱えるようにしています。下のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
(`X^2+3`Y+1)(1,2)
===============================
8

sqrt(`X^2+3`Y+1)(1,2)
===============================
2.82842712475
</span>
</code>
</pre>
<h3>ベクトル・行列記号</h3>
<p>
PythonSf では、ベクトルや行列をあらわすのに ~[...]の記法を使います。下のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
~[1,2,3]    # float value vector
===============================
[ 1.  2.  3.]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
~[1,2,3+4j]    # complex value vector
===============================
[ 1.+0.j  2.+0.j  3.+4.j]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
vc=~[1,2,3]; vc+[4,5,6]    # vector add
===============================
[ 5.  7.  9.]
---- ClTensor ----

vc=~[1,2,3]; vc [4,5,6]    # vector inner product
<b>PythonSf ワンライナー</b>
===============================
32.0

<b>PythonSf ワンライナー</b>
~[ [1,2],[3,4] ]           # matrix
===============================
[[ 1.  2.]
 [ 3.  4.]]<F12>
---- ClTensor ----

<b>PythonSf ワンライナー</b>
mt,vc=~[[1,2],[3,4]],~[5,6]; mt vc   # product of matrix and vector
===============================
[ 17.  39.]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
mt=~[[1,2],[3,4]]; 1/mt, mt^-1   # inverse of matrix
===============================
(ClTensor([[-2. ,  1. ],
           [ 1.5, -0.5]]),
 ClTensor([[-2. ,  1. ],
           [ 1.5, -0.5]]))

<b>PythonSf ワンライナー</b>
# 辞書行列から ClTensor 行列の生成
dct={(0,0):1,(0,1):2,(1,0):3,(1,1):1}; ~[dct]
===============================
[[ 1.  2.]
 [ 3.  1.]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
PythonSf のベクトルや行列ではデフォルトで浮動小数点型のそれにします。浮動小数点のベクトルや行列であっても整数のベクトル・行列であっても、整数のときと同様な計算結果になることが多いからです。逆に整数は割り算が入ると小数点以下が 0 になってしまうからです。
<p>
ベクトルや行列に整数など浮動小数点以外の型:typeを指定したいときは ~[..., type] と最後に型:type引数を追加します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
~[1,2,3, int]   # int type vector
==============================
[1 2 3]
---- ClTensor ----
</span>
</code>
</pre>
<p>
ブール体型など、Python の基本数値型以外の型、ユーザーが定義する型を指定することで、その型でのベクトル・行列演算も可能です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
~[1,0,1, oc.BF]     # oc.BF:Bool Filed type vector
===============================
[1 0 1]
---- ClFldTns:&lt;class 'pysf.octn.BF'&gt; ----

<b>PythonSf ワンライナー</b>
mt,vc=~[[1,1,0],[1,1,1],oc.BF],~[1,0,1, oc.BF]; mt vc     # product of Bool Type matrix and vector
===============================
[1 0]
---- ClFldTns:&lt;class 'pysf.octn.BF'&gt; ----

<b>PythonSf ワンライナー</b>
~[1,2,3, oc.BF]     # oc.BF:Bool Filed type vector
===============================
[1 0 1]
---- ClFldTns:&lt; class 'pysf.octn.BF'&gt; ----

<b>PythonSf ワンライナー</b>
class Cl(int):pass; ~[1,2,3, Cl]    # user defined type
===============================
[1 2 3]
---- ClFldTns:&;t;class 'pysf.sfPPrcssr.Cl'&gt; ----
</span>
</code>
</pre>
<p>
ClTensor/ClFldTns と numpy の ndarray のベクトル・行列演算では、デフォルトが浮動小数点／整数の違いになること以外に、乗除算の扱いが異なります。ClTensor や ClFldTns の乗除算は、「ベクトルと行列」「行列と行列」の乗除算になります。「ベクトルとベクトル」の乗算は内積となり除算はエラーになります。ndarray の乗除算は要素ごとの乗除算になります。最初のうちは戸惑うと思います。御注意ください。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# PythonSf でのベクトル要素どうしの積：内積
~[1,2,3] ~[4,5,6]
===============================
32.0

<b>PythonSf ワンライナー</b>
~[1,2,3]/ ~[4,5,6]
Traceback (most recent call last):
  File "D:\lng\Python26\lib\runpy.py", line 122, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "D:\lng\Python26\lib\runpy.py", line 34, in _run_code
    exec code in run_globals
  File "D:\my\vc7\mtCm\sfPP.py", line 2, in <module>
    pysf.sfPPrcssr.start()
  File "pysf\sfPPrcssr.py", line 2722, in start
    __execLine( (" ".join(sys.argv[1:])).strip() )
  File "pysf\sfPPrcssr.py", line 2345, in __execLine
    valStt = eval(ustConvertedAt, globals(), locals() )
  File "<string>", line 1, in <module>
  File "pysf\sfFnctns.py", line 547, in __truediv__
    return self.__mul__(ag.inv())
  File "pysf\sfFnctns.py", line 492, in inv
    return copy.deepcopy(self.m_inv)
  File "pysf\sfFnctns.py", line 909, in __getattr__
    self.__dict__['m_inv'] = ClTensor(sl.inv(self))
  File "D:\lng\Python26\lib\site-packages\numpy\linalg\linalg.py", line 423, in inv
    return wrap(solve(a, identity(a.shape[0], dtype=a.dtype)))
  File "D:\lng\Python26\lib\site-packages\numpy\linalg\linalg.py", line 290, in solve
    _assertRank2(a, b)
  File "D:\lng\Python26\lib\site-packages\numpy\linalg\linalg.py", line 134, in _assertRank2
    two-dimensional' % len(a.shape)
numpy.linalg.linalg.LinAlgError: 1-dimensional array given. Array must be             two-dimensional

<b>PythonSf ワンライナー</b>
# numpy でのベクトル要素どうしの割り算
vA,vB = np.array([1,2,3]),np.array([4,5,6]); vA/vB
===============================
[ 0.25  0.4   0.5 ]

<b>PythonSf ワンライナー</b>
# numpy でのベクトル要素どうしの積
np.array([1,2,3]) np.array([4,5,6])
===============================
[ 4 10 18]

np.array([1,2,3])/np.array([4,5,6])
===============================
[ 0.25  0.4   0.5 ]
</span>
</code>
</pre>
<p>
なお、整数／実数／複素数を要素とする ClTensor インスタンスが最終計算値のとき、計算結果の文字列の最後に ---- ClTensor ---- 文字列が追加されます。ClFldTns インスタンスが最終計算値のときは ---- ClFldTns:< class 'pysf.octn.BF'> ---- など要素のタイプも含めた文字列が返されます。下のような具合です。np.ndarray インスタンスのときはタイプ情報は返されません。
<p>
np.ndarray と ClTensor の加減乗除算は ClTensor インスタンスになります。np.ndarray と ClTensor では乗除算が要素ごとの乗除算になことと、行列・ベクトルの乗除算になる違いがあります。どちらの演算を行っているのか理解して計算を続ける必要があります。
<p>
とくに scipy の 非 ufunc:universal function の行列やベクトルを扱う関数のときに注意が必要です。ClTensor インスタンスを引数として与えても、np.ndarray インスタンスが返ってきてしまうからです。それが嫌で fft バッファ関数を設けたりしています。ufunc ならば ClTensor インスタンスを引数にすれば、ClTensor 値が帰ってくるのですが、scipy の全ての関数が ufunc に統一されてはいません。
<pre>
<code>
<span style="color: #9f009f;">
整数／実数／複素数 PythonSf 行列／ベクトル式
===============================
値文字列
---- ClTensor ----


非整数・非実数・非複素数 PythonSf 行列／ベクトル式
===============================
値文字列
---- ClFldTns:< class 'pysf.octn.BF'> ----
</span>
</code>
</pre>
<h3>ギリシャ文字と特殊記号</h3>
数学では変数や関数を表すのにギリシャ文字が しばしば使われます。PythonSf では Python 2.x てあっても変数名にギリシャ文字の漢字を使えるようにしています。(2011 年 10 月現在では使える漢字コードは shift-jis のみです。要望が多ければ utf8 なども考えます。)下のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
σx,σz=~[[0,1],[1,0]], ~[[1,0],[0,-1]]; σx σz
===============================
[[ 0. -1.]
 [ 1.  0.]]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
σx,σz=~[[0,1],[1,0]], ~[[1,0],[0,-1]]; σx+σz
===============================
[[ 1.  1.]
 [ 1. -1.]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
ギリシャ文字の他に日常の計算で使うことの多い「∇□∂△」漢字記号も扱えるようにしています。特に微分記号 ∂ は便利に多用されます。
<pre>
<code>
<span style="color: #9f009f;">
# 数値微分
∂x(`X^2+2`X+3)(2)
===============================
6.0

# シンボリック微分
<b>PythonSf ワンライナー</b>
ts(); ∂x(`x^2+2`x `y+3)
===============================
2*x + 2*y

# Jacobian 数値微分
∂J(`X^2+`Y^2, 2)(1,2)
===============================
[ 2.  4.]
---- ClTensor ----
</span>
</code>
</pre>
<h4>lambda 式とギリシャ文字 λ</h4>
<p>
ワンライナーで lambda 式が多用されることと、lambda より漢字 λ の方が視認性で勝ることより、lambda 式の記述に漢字 λ を使えるようにしています。これによりコンピュータ・サイエンスの教科書にあるような λ 式記述が可能になります。下のような具合です。その代償として λ 一文字だけの変数を使えなくなります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
f=λ x:sin(x)+2cos(x); f(pi/2)
===============================
1.0

<b>PythonSf ワンライナー</b>
# python lambda 式でデフォルト引数を利用した let 文 を使う
# デフォルト引数 y=sin(x)+2cos(x) が let 分になっている。
# y の書き換えができない。
f=λ x:(λ y=sin(x)+2cos(x): y+y^2)(); f(pi/2)
===============================
2.0

<b>PythonSf ワンライナー</b>
λ=3; 2λ
invalid syntax (<string>, line 1) at excecuting:lambda=3
</span>
</code>
</pre>
<p>
Python での λ:labmda 式は、コンピュータ・サイエンスでの λ式 に近い仕様になっています。下の様に Charch 数による自然数のモデル化ができてしまいます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# Charch 数 2
Z='1';S =λ s:s+'1';(λ s:λ z:s(s(z)))(S)(Z)
===============================
111

# Charch 数での 2 + 3
Z='1';S =λ s:s+'1';(λ s:λ z:s(s(  s(s(s(z))) )))(S)(Z)
===============================
111111
</span>
</code>
</pre>

<h3>演算子記号の拡張</h3>
<p>
~~, ~^, ~+, ~-, ~*, ~/, ~%, ~&, ~|, ~== の中置ユーザー演算子を定義できます。ただ現在のところ演算子の優先順位が最大固定なので、括弧が必要になることか多くなります。
<p>
<p>
PythonSf のプリプロセッサは、できるだけ Python と upper compatible になるようにしてありますが、以上の点に限っては upper cmpatible であることより、日常でのメモ書き数式に近づけることを優先しました。

<h3>グローバル変数名前空間</h3>
<p>
PythonSf プリプロセッサが PythonSf 式を実行する前に from pysf.sfFnctns import * を行っています。これにより基本数値関数 exp, sin, cos, tan, sinh, cosh, tanh, arcsin, arccos, arctan, log10, sqrt など多くの基本的な数学要素をグローバル名前空間に導入済みにしています。これにより import math などを行わずに計算処理が可能です。通常の関数電卓で行う算の殆どを PythonSf では import なしで可能です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
tan(pi/3)
===============================
1.73205080757
</span>
</code>
</pre>

<h3>名前空間の拡張とカスタマイズ</h3>
<p>
すでに `X などの変数名を使っていますが、PythonSf では変数名の前後に back quote:` を複数追加したものを、プリプロセッサによる変換を介在させることで許しています。この名前空間の拡張と PythonSf のカスタマイズ機能により、数学慣習に従った短い数式記述と Python 文法を共存させています。
<p>
より具体的に見てみましょう。PythonSf プリプロセッサが ` で始まる変数名を見つけると k__bq_ を文字列の最初に、__ を文字列の最後に付加した物に変換します。`X は k__bq_X__ 文字列に変換されます。そしてカスタマイズ・ファイル:customize.py の中で  k__bq_X__ 変数名に加減乗除べき乗算が可能な恒等関数のクラス・インスタンスを assign することで `X^2+1 などの記述を可能にしています。
<p>
数式の記述は、できるだけコンパクトであることが望まれます。そのため多くの暗黙の前提の上に数式が書かれます。数学の世界では X と書けば、未知変数 X を意味します。物理の世界では h c と書いたときには、プランク定数と光速度の積を意味したりします。でも X,h,c のように短い変数ラベルに、恒等関数、プランク定数や光速度の意味を与えてしまうのは、Python コードの記述としては やりすぎです。どこかで既存の Python コードと矛盾する可能性が出てきます。
<p>
この問題を対策するため、PythonSf では変数文字列の前後に一つ以上のバック・クォート文字を追加できるようにして名前空間を拡張しました。この拡張された変数名 の拡張された変数名 `X や h` や c` にプランク定数や光定数を割り当てることで、数学や物理での暗黙の前提を使いながらも Pythoｎ コードと矛盾しないメモ書き数式記述を可能にしました。
<p>
なお PythonSf では名前の最後にバック・クォートを追加した変数名には物理単位、または物理定数を割り当てるという naming convention を適用しています。
<p>
また back quote は Γ``_[i,j,k] などのようにテンソル・インデックスの上下を示すことにも naming convention として使います。この例では i,j が上側の, k が下側のインデックスになります。Γ``_ では back quate が名前の前後ではないと指摘されるかもしれません。厳密には名前の前後というとき under_score 文字列は含まないと思ってください。
<h4>カスタマイズ customize.py, sfCrrntIni.py</h4>
<p>
数式を書くとき、暗黙の前提とする事柄はユーザーの専門分野によって異なります。場合によっては計算するディレクトリごとに暗黙の前提が必異なったりさえします。
<p>
このため、PythonSf では共通前提向けに pysf.customize.py ファイルを設けています。それとは別に、カレント・ディレクトリに sfCrrntIni.py ファイルを置けるようにしています。PythonSf プリプロセッサは計算処理の前に from pysf.customize import * を実行します。カレント･ディレクトリに sfCrrntIni.py ファイルが存在するときは、from sfCrrntIni import * も実行します。
<p>
標準配布の中に customize.py, sfCrrntIni.py も含まれています。customize.py の中で上の PythonSf 式例で使った物理単位や `X,`x 変数を定義しています。その他に、単位純虚数:`i, ブール値:`1,`0、パウリ行列:`σx,`σy,`σz を、ts() 関数の中では有理数の 1:`1r などを customize.py で定義しています。次のような計算が可能です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
exp(2pi `i/3)
===============================
(-0.5+0.866025403784j)
<b>PythonSf ワンライナー</b>
# Bool 値ベクトルの和
~[`1,`0,`1]+[`1,`1,`1]
===============================
[0 1 0]
---- ClFldTns:< class 'pysf.octn.BF'> ----
<b>PythonSf ワンライナー</b>
`σx + 2`σy
===============================
[[ 0.+0.j  1.-2.j]
 [ 1.+2.j  0.+0.j]]
---- ClTensor ----

# exp 行列の計算
t,mt=0.1, `σx + 2`σy; expm(`i t mt)
===============================
[[ 0.97510399+0.j          0.19833750+0.09916875j]
 [-0.19833750+0.09916875j  0.97510399+0.j        ]]
---- ClTensor ----
<b>PythonSf ワンライナー</b>
# 有理数の数列
ts(); [`1r/(k+1) for k in range(10)]
===============================
[1, 1/2, 1/3, 1/4, 1/5, 1/6, 1/7, 1/8, 1/9, 1/10]

ts(); sum( [`1r/(k+1) for k in range(10)] )
===============================
7381/2520
</span>
</code>
</pre>
<p>
その他 customize.py には三階の Livi-Civita テンソル:`εL, 微分関数:∂x, Jacovian 微分:∂J、Laplace 演算子多項式:`s などが定義してあり、これらを使った計算処理が可能です。下のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
`εL        # Levi-Civita tensor
===============================
[[[ 0.  0.  0.]
  [ 0.  0.  1.]
  [ 0. -1.  0.]]

 [[ 0.  0. -1.]
  [ 0.  0.  0.]
  [ 1.  0.  0.]]

 [[ 0.  1.  0.]
  [-1.  0.  0.]
  [ 0.  0.  0.]]]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
a,b=~[1,2,3],~[4,5,6]; -a `εL b      # outer product by Levi-Civita tensor
===============================
[-3.  6. -3.]
---- ClTensor ----

a,b=~[1,2,3],~[4,5,6]; np.cross(a,b)     # outer product by numpy
===============================
[-3.  6. -3.]

<b>PythonSf ワンライナー</b>
∂x(`X^2+1)(1)                      # differential x^2+1 at 1
===============================
2.0

<b>PythonSf ワンライナー</b>
∂J(~[`X+`Y, `X `Y], 2)(1,2)        # Jacobian of ~[x+y,x y] field at [1,2]
===============================
[[ 1.  1.]
 [ 2.  1.]]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
1/(`s+1) ( (`s+2) +1/(`s+3))
===============================
   2
1 s + 5 s + 7
-------------
  2
 s + 4 s + 3

<b>PythonSf ワンライナー</b>
# Bode 線図
(1/(`s+1) ( (`s+2) +1/(`s+3))).plotBode(0.01Hz`,100Hz`)
</span>
</code>
</pre>
<img src="./jpg/1111/bode_sp1_sp2_sp2.jpg">
<br>
<p>
標準配布の PythonSf では sfCrrntIni.py の中で、整数剰余体：Zp(N) の N が 2,3,4,5,7 のときの Z2,Z3,Z4,Z5,Z7 を定義しています。これらは PythonSf 式を実行するときのグローバル変数中に存在することとなり、import 文無しで PythonSf 式中で Z2,Z3,Z4,Z5,Z7 を好きに使えます。次のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# Z3 行列
~[range(2*2), Z3].reshape(2,2)
===============================
[[Z3(0) Z3(1)]
 [Z3(2) Z3(0)]]
---- ClFldTns:< class 'sfCrrntIni.Z3'> ----

# Z3 行列の逆行列
mt=~[range(2*2), Z3].reshape(2,2); mt^-1
===============================
[[Z3(0) Z3(2)]
 [Z3(1) Z3(0)]]
---- ClFldTns:< class 'sfCrrntIni.Z3'> ----

# Z3 行列どうしの積
mt=~[range(2*2), Z3].reshape(2,2); mt mt^-1
===============================
[[Z3(1) Z3(0)]
 [Z3(0) Z3(1)]]
---- ClFldTns:< class 'sfCrrntIni.Z3'> ----

</span>
</code>
</pre>
<p>
customize.py/sfCrrntIni.py はユーザーが自分の都合に合わせてカスタマイズして使うものです。中身は Python プログラムに過ぎませんので、ユーザの必要に応じて自由に改変できます。

<h3>ファイル変数</h3>
<p>
PythonSf では、pickable なインスタンスをファイル変数にできます。このファイル変数はカレント・ディレクトリに拡張子 pvl で実際のファイルとして作られます。OOP 用語を使って言い換えると、pickable な計算結果をファイル変数としてシリアライズして、何時でも再利用可能にします。one-liner では「:=」でファイル変数への書き込みを行い「=:」でファイル変数からの読み込みを行います。ファイル変数はカスタマイズと似た機能を果たします。
<p>
下に示すように「tmp:=3+4」で tmp.pvl ファイルがカレント・ディレクトリに作られます。「=:tmp; tmp/2」でカレント・ディレクトリから tmp.pvl を読み出し、tmp 変数に その値を設定します。そのあと tmp を含んだ式を計算できるようになります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
tmp:= 3+4
===============================
7
<b>dos command</b>
dir tmp.pvl
 ドライブ D のボリューム ラベルは ボリューム です
 ボリューム シリアル番号は 4CBC-BC86 です

 D:\my\vc7\mtCm のディレクトリ

2012/01/05  06:13                42 tmp.pvl
               1 個のファイル                  42 バイト
               0 個のディレクトリ  41,679,384,576 バイトの空き領域
<b>dos command</b>
type tmp.pvl
# python object printed out by pprint
7

<b>PythonSf ワンライナー</b>
=:tmp; tmp/2
===============================
3.5
</span>
</code>
</pre>
<h4>ファイル変数 X32,X64,X28,  Px32,Px64,Px128 と行列力学</h4>
<p>
ファイル変数の もっと実用的な使用例を示します。標準配布している PythonSf のカレント・ディレクトリには X32.pvl,X64.pvl,X28.pvl,  Px32.pvl,Px64.pvl,Px128.pvl といった量子力学の行列力学で使うための[-1,1] 範囲の位置演算子行列、[0,2pi] 範囲の運動量演算子行列のファイル変数を入れてあります。X32 は下のようなデータの行列です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
P,X=:Px32,X32; X
===============================
[[-0.96875  0.       0.      ...,  0.       0.       0.     ]
 [ 0.      -0.90625  0.      ...,  0.       0.       0.     ]
 [ 0.       0.      -0.84375 ...,  0.       0.       0.     ]
 ..., 
 [ 0.       0.       0.      ...,  0.84375  0.       0.     ]
 [ 0.       0.       0.      ...,  0.       0.90625  0.     ]
 [ 0.       0.       0.      ...,  0.       0.       0.96875]]
---- ClTensor ----
</span>
</code>
</pre>
位置／運動量演算子行列 X,Px が与えられれば、Hamiltonian 行列が定まります。位置・運動量演算子行列が PythonSf 変数として与えられているのですから、量子力学の教科書の行列力学の章に書いてある式が実際に計算可能になります。例えば調和振動子の Hamiltonian は下のように書けます。 
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
P,X=:Px64, X64; H=P^2+X^2;          H 
===============================
[[ 4.25805908 +8.32667268e-17j  1.99678801 +9.80959047e-02j
   0.49679034 +4.89295777e-02j ...,  0.21901645 -3.24880216e-02j
   0.49679034 -4.89295777e-02j  1.99678801 -9.80959047e-02j]
 [ 1.99678801 -9.80959047e-02j  4.19751221 +5.55111512e-17j
   1.99678801 +9.80959047e-02j ...,  0.12179970 -2.42274668e-02j
   0.21901645 -3.24880216e-02j  0.49679034 -4.89295777e-02j]
 [ 0.49679034 -4.89295777e-02j  1.99678801 -9.80959047e-02j
   4.13891846 -5.55111512e-17j ...,  0.07680678 -1.92390964e-02j
   0.12179970 -2.42274668e-02j  0.21901645 -3.24880216e-02j]
 ..., 
 [ 0.21901645 +3.24880216e-02j  0.12179970 +2.42274668e-02j
   0.07680678 +1.92390964e-02j ...,  4.13891846 +2.04697370e-16j
   1.99678801 +9.80959047e-02j  0.49679034 +4.89295777e-02j]
 [ 0.49679034 +4.89295777e-02j  0.21901645 +3.24880216e-02j
   0.12179970 +2.42274668e-02j ...,  1.99678801 -9.80959047e-02j
   4.19751221 +6.80011603e-16j  1.99678801 +9.80959047e-02j]
 [ 1.99678801 +9.80959047e-02j  0.49679034 +4.89295777e-02j
   0.21901645 +3.24880216e-02j ...,  0.49679034 -4.89295777e-02j
   1.99678801 -9.80959047e-02j  4.25805908 -8.32667268e-17j]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
Hamiltonian 行列の数値要素だけを見せられても「だから何？」でしょうが、その固有値を求めて見ると、また その差分を見てみると、調和振動子の片鱗が出てきます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# Hamiltonian の固有値
P,X=:Px64, X64; H=P^2+X^2; eigvalsh(H)
===============================
[  0.03125000+0.j   0.09375000+0.j   0.15625000+0.j   0.21875000+0.j
   0.28125000+0.j   0.34374997+0.j   0.40625022+0.j   0.46874830+0.j
   0.53125901+0.j   0.59370001+0.j   0.65642917+0.j   0.71797533+0.j
   0.78307742+0.j   0.83758165+0.j   0.91619057+0.j   0.94962095+0.j
   1.06362868+0.j   1.07763419+0.j   1.23050560+0.j   1.23652959+0.j
   1.41810063+0.j   1.42121437+0.j   1.62625614+0.j   1.62810710+0.j
   1.85462810+0.j   1.85582224+0.j   2.10294704+0.j   2.10374776+0.j
   2.37102704+0.j   2.37156478+0.j   2.65874147+0.j   2.65908661+0.j
   2.96600288+0.j   2.96619493+0.j   3.29274974+0.j   3.29281031+0.j
   3.63887701+0.j   3.63893806+0.j   4.00435423+0.j   4.00453612+0.j
   4.38921091+0.j   4.38952113+0.j   4.79342210+0.j   4.79387721+0.j
   5.21696632+0.j   5.21759441+0.j   5.65982304+0.j   5.66066864+0.j
   6.12196967+0.j   6.12310288+0.j   6.60337666+0.j   6.60491066+0.j
   7.10399790+0.j   7.10612440+0.j   7.62374802+0.j   7.62681621+0.j
   8.16243915+0.j   8.16715679+0.j   8.71954535+0.j   8.72762234+0.j
   9.28731293+0.j   9.31657988+0.j   9.75250929+0.j  10.19014824+0.j]
---- ClTensor ----

# Hamiltonian 固有値の差分
P,X=:Px64, X64; H=P^2+X^2; vc=eigvalsh(H); vc=vc-shftSq(vc)
Waring: don't use assignment at last sentence.We ignore the assignment.
===============================
[  3.12500000e-02+0.j   6.25000000e-02+0.j   6.25000000e-02+0.j
   6.24999998e-02+0.j   6.25000026e-02+0.j   6.24999695e-02+0.j
   6.25002517e-02+0.j   6.24980750e-02+0.j   6.25107081e-02+0.j
   6.24410072e-02+0.j   6.27291558e-02+0.j   6.15461604e-02+0.j
   6.51020863e-02+0.j   5.45042324e-02+0.j   7.86089186e-02+0.j
   3.34303833e-02+0.j   1.14007733e-01+0.j   1.40055090e-02+0.j
   1.52871408e-01+0.j   6.02399218e-03+0.j   1.81571035e-01+0.j
   3.11374152e-03+0.j   2.05041772e-01+0.j   1.85096230e-03+0.j
   2.26521002e-01+0.j   1.19413904e-03+0.j   2.47124794e-01+0.j
   8.00725528e-04+0.j   2.67279275e-01+0.j   5.37743185e-04+0.j
   2.87176693e-01+0.j   3.45136237e-04+0.j   3.06916275e-01+0.j
   1.92040921e-04+0.j   3.26554815e-01+0.j   6.05733205e-05+0.j
   3.46066693e-01+0.j   6.10529677e-05+0.j   3.65416172e-01+0.j
   1.81887321e-04+0.j   3.84674788e-01+0.j   3.10218641e-04+0.j
   4.03900971e-01+0.j   4.55112728e-04+0.j   4.23089107e-01+0.j
   6.28094792e-04+0.j   4.42228631e-01+0.j   8.45595766e-04+0.j
   4.61301033e-01+0.j   1.13320700e-03+0.j   4.80273786e-01+0.j
   1.53399721e-03+0.j   4.99087243e-01+0.j   2.12649374e-03+0.j
   5.17623621e-01+0.j   3.06819454e-03+0.j   5.35622935e-01+0.j
   4.71764271e-03+0.j   5.52388560e-01+0.j   8.07698830e-03+0.j
   5.59690586e-01+0.j   2.92669528e-02+0.j   4.35929408e-01+0.j
   4.37638952e-01+0.j]
---- ClTensor ----
</span>
</code>
</pre>
<p>
最初の固有値は h/2:3.125e-2 ですが、その次からは h:6.25e-2 刻みになっています。さらに 0 振動から離れると 64 点有限近似の影響が表れてきます。下のように、直線から二次の曲線に移っていきます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
P,X=:Px64, X64; H=P^2+X^2; plotGr( eigvalsh(H) )
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_harmonic_oscilator_eig.jpg">
<br>
<p>
初期状態でインデックス 16 の位置に集中している波動関数ベクトル vc の位相も含めた時間変化：調和振動子波動関数の運動を、下のように自然なワン・ライナーで計算・可視化できます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
P,X=:Px64, X64; H=P^2+10 X^2; vc=kzrs(64); vc[16]=1; renderMtCplx( ~[ expm(`i H t) vc for t in klsp(0, 5s`)]) 

</span>
</code>
<br>
<img src="./jpg/1111/oneliner_harmonic_oscilator_wave_function.jpg">
<p>
ファイル変数はワンライナーでは収まらない、何段階もの計算・思考の中間データとして使います。先の Hamiltonian 行列が大規模・複雑で その計算に時間がかかるときは、Hamiltonian 行列のデータを ファイル変数として残しておき再利用する方法を使います。
<!--
<p>
全ての PythonSf ワン･ライナー式の計算結果は pickable なときは _dt.pvl ファイルとしてカレント・ディレクトリに残されます。これを別の変数名に OS のコマンドで rename してやれば、その rename された変数名で PythonSf 式の中で利用できます。これらのデータはファイル・データとして HDD 上のカレント・ディレクトリに残っているので永続的に残ります。様々の PythonSf 式で何度でも再利用できます。
-->
<p>
何度でも再利用できるということは、カスタマイズ・データとしても利用できることを意味します。ファイル変数は行列などの pickable にインスタンスにしか使えないのですが、必要なときにだけ =: で読み出して使うので、他の PythonSf 式の時間負荷になりません。sfCrrntIni.py/customize.py に書かれた Python Code は何時でも PythonSf 式の実行前に import され実行されるので時間負荷となり、応答時間を増大させます。
この意味で、ファイル変数は別の時間負荷とならないカスタマイズ方法としても使えます。
<br>
<br>
<br>
<h3>基本数値関数の加減乗除べき乗算と関数合成</h3>
<p>
PythonSf では、 基本数値関数 exp, sin, cos, tan, sinh, cosh, tanh, arcsin, arccos, arctan, log10, sqrt, absF は、グローバル変数に入れてあり、import 無しで直ぐに使えます。同時に、これらは加減乗除と整数べき乗算および関数合成を可能にしてあります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
x=pi/6; ( 2 sin cos )(x), sin(2`X)(x)
===============================
(0.8660254037844386, 0.8660254037844386)
</span>
</code>
</pre>
<p>
関数を加減乗除べき乗算と関数合成を可能なものにするために ClAF クラスを設けています。pysf\basicFnctns.py で実装しています。この ClAF で numpy の exp, sin, cos, tan, sinh, cosh, tanh, arcsin, arccos, arctan, log10, sqrt を包んでやることで、本関数 sin(2pi `X^2) + 1 などの PythonSf 式を可能にしています。
<p>
usFn=ClAF(userFunction) と一変数関数:userFunction を包んで usFn などのラベルに割り当ててやれば、usFn が関数合成と加減乗除べき乗算が可能な userFnction の関数機能を持った関数になります。customize.py または sfCrrntIn.py の中に usFn=ClAF(userFunction) コードを書いてやれば usFn が PythonSf 式を実行するときのグローバル変数に入り込みます。このようにカスタマイズしてやることでユーザーが望む関数を import なしで使える、関数合成と加減乗除べき乗算が可能な関数にできます。
<p>
exp, sin, cos, tan, sinh, cosh, tanh, arcsin, arccos, arctan, log10, sqrt を ClAF で包むことは 
pysf\kNumeric.py で行っています。そして customize.py のなかで kNumeri.py を import * してあります。興味のある方は Python ソース・コードを見てみてください。
<h3>`X,`Y,`Z、`T 変数</h3>
<p>
数学の世界では x,y,z は変数の意味になります。x,y,z が何であるかに言及することなく sin(x^2), cos(2x+1), tan(x+y), exp(x^2+y^2+z^2) などの関数の意味は明確であるとされてしまいます。 「x^2+2x + 3 は二次関数である」というとき、x が何であるかまでは言及しません。

<p>
同様なことを可能にするため、 `X,`Y,`Z,`T 変数に加減乗除べき乗算と関数合成が可能な恒等関数を assign するコードを customize.py に書いてあります。`X,`Y,`Z,`T は、一番目の、二番目の、三番目の、最後の引数を取り出す意味も与えてあります。恒等関数といっても加減乗除べき乗算を組み合わせることで任意の多項式関数を表現できます。下のような具合です。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
(`X^2+2`X+3)(2)     # quadratic function
===============================
11

<b>PythonSf ワンライナー</b>
(`X^2+`Y^2)(2,3)     # 2 parameter quadratic function
===============================
13

<b>PythonSf ワンライナー</b>
(`X^2 + `T)(2,3)    # `T picks up the last parameter 3
===============================
7

<b>PythonSf ワンライナー</b>
N=6; [(sin(2`X))(n/N) for n in range(N)]
===============================
[0.0, 0.32719469679615221, 0.61836980306973699, 0.8414709848078965, 0.97193790136331271, 0.99540795775176494]
</span>
</code>
</pre>
<h3>numpy scipy と パッケージの利用</h3>
<p>
Python には、numpy, scipy パッケージという、膨大な数学ライブラリの蓄積があります。scipy は numpy を包含します。scipy のサブパッケージには scipy.optimize,integrate,linalg,special,signal といった Matlab では別の単独パッケージとして売られているような物も入っています。でも numpy には、これらがありません。
<p>
「ならば、nympy ではなく、scipy だけを使っておけばよい。」とはできません。 scipy は膨大すぎて、netbook のような非力なパソコンでは import scipy とするだけで、二秒近くかかったりします。一方で numpy は一桁短い時間で import を終了します。ですから PythonSf では常に import numpy as np を実行しますが、import scipy as sy を実行するのは、sy() を明示的に呼び出したときに限っています。
<p>
sy() を呼び出すと import scipy as sy のほかに so,si,sl,ss,sg の名前で下のサブ・パッケージも同時に import しています。これらの サブ・パッケージの import 時間は無視できる程度だからです。これらのサブ・パッケージは下の機能を持っています。
<ol>
<li>so optimize:    特定の条件を満たす変数値を求める関数群
<li>si integrate:   積分を行う関数群
<li>sl linalg:      行列の線形処理を行う関数群
<li>ss specia:      特殊関数群
<li>sg signal:      線形システムを処理する関数群
</ol>
<p>
numpy は pysf.sfFnctns.py の中で import numpy as np と import 済みであり、numpy package にある膨大な機能が np名前空間 の下で全て利用可能です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# numpy.source(..) 関数は引数に与えられた関数やモジュールのソース･コードを返します
np.source(fft)
In file: pysf\kNumeric.py

def fft(sqAg, n=None, axis = -1):
    """' reverse Fasst Fourier Transform
         return ClTensor array
    '"""
    import numpy.fft as fp
    return sf.krry(fp.fft(sqAg, n, axis))

===============================
None

<b>PythonSf ワンライナー</b>
# numpy.info(..) 関数は引数に与えられた関数やモジュールについてのコンパクトな説明を返します。
# help(..) でのように詳細すぎる説明ではありません。
np.info(np.linalg)
Core Linear Algebra Tools
-------------------------
Linear algebra basics:

- norm            Vector or matrix norm
- inv             Inverse of a square matrix
- solve           Solve a linear system of equations
- det             Determinant of a square matrix
- lstsq           Solve linear least-squares problem
- pinv            Pseudo-inverse (Moore-Penrose) calculated using a singular
                  value decomposition
- matrix_power    Integer power of a square matrix

Eigenvalues and decompositions:

- eig             Eigenvalues and vectors of a square matrix
- eigh            Eigenvalues and eigenvectors of a Hermitian matrix
- eigvals         Eigenvalues of a square matrix
- eigvalsh        Eigenvalues of a Hermitian matrix
- qr              QR decomposition of a matrix
- svd             Singular value decomposition of a matrix
- cholesky        Cholesky decomposition of a matrix

Tensor operations:

- tensorsolve     Solve a linear tensor equation
- tensorinv       Calculate an inverse of a tensor

Exceptions:

- LinAlgError     Indicates a failed linear algebra operation
===============================
None

<b>PythonSf ワンライナー</b>
# 擬似逆行列の計算
np.linalg.pinv([[1,2,3],[4,5,6]])
===============================
[[-0.94444444  0.44444444]
 [-0.11111111  0.11111111]
 [ 0.72222222 -0.22222222]]

<b>PythonSf ワンライナー</b>
# 擬似逆行列との積が単位行列になること：上の計算結果の確認
np.dot([[1,2,3],[4,5,6]], np.linalg.pinv([[1,2,3],[4,5,6]]))
===============================
[[  1.00000000e+00  -4.44089210e-16]
 [  0.00000000e+00   1.00000000e+00]]
</span>
</code>
</pre>
<p>
なお、numpy の中でも使用頻度の高いフーリエ変換:fft,ifft,fftshift, 行列の固有値、固有ベクトル：eig,eigvals, 行列の exponential/logarithm/square_root:expm,logm,sqrtm は、グローバル名前空間に再実装してあり、下のように直接呼び出せます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
fft([1,2,3,4])
===============================
[ 10.+0.j  -2.+2.j  -2.+0.j  -2.-2.j]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
eig([[1,2],[3,4]])
===============================
(ClTensor([-0.37228132,  5.37228132]),
ClTensor([[-0.82456484, -0.41597356],
       [ 0.56576746, -0.90937671]]))

<b>PythonSf ワンライナー</b>
eigvals([[1,2],[3,4]])
===============================
[-0.37228132  5.37228132]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
expm([[1,2],[3,4]])
===============================
[[  51.9689562    74.73656457]
 [ 112.10484685  164.07380305]]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
sqrtm([[1,2],[3,4]])
===============================
[[ 0.55368857+0.46439416j  0.80696073-0.21242648j]
 [ 1.21044109-0.31863972j  1.76412966+0.14575444j]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
scipy パッケージは sy() を呼び出して下のように使います。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
sy(); sy.factorial(10), sy.factorial(10, True)
===============================
(array(3628800.0), 3628800L)

</span>
</code>
</pre>
<!--
<b>PythonSf ワンライナー</b>
1/`s + 1/(`s+1)     # add transfer function
===============================
 
2 s + 1
-------
 2
s + 1 s
-->



<p>
scipy は sy() と関数呼び出しを行ったときに sy の名前で import されます。このとき同時に import scipy.optimize as so, import scipy.integrate as si, import scipy.linalg as sl, import scipy.special as ss, import scipy.signal as sg も行われます。sy() を一度呼び出すだけで、so,si,sl,ss,sg の下で optimize,integrate,linalg,special,signal のサブ･パッケージ内にある膨大な機能を利用可能になります。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
sy(); so.bisect(`X^3+2`X^2-3`X-1, -10,10)   # find 0 point by bi-section method
===============================
1.19869124352

<b>PythonSf ワンライナー</b>
# 二重積分:関数 f(x,y)=x^2 + y^2 を、原点から半径 1 の円内の領域で積分する
sy(); si.dblquad(`X^2+`Y^2, -1,1, sqrt(1-`X^2),-sqrt(1-`X^2) )
===============================
(-1.5707963267947727, 1.2484818956437493e-08)
# 右側の 1.2484818956437493e-08 は推定誤差

<b>PythonSf ワンライナー</b>
sy(); sl.sinm(`σx)         # sinm(x) == x - x^3/3! + x^5/5! - ...
===============================
[[ 0.          0.84147098]
 [ 0.84147098  0.        ]]
# 注意 scpy のユニーバーサル関数は ClTensor 引数値を与えれは ClTensor インスタンスを返す
# でも scipy 関数の中には、sinm(..) のように ClTenso 引数値を与えても np.ndarray 値を返すものがある。
# np.ndarray と ClTensor では、乗除算が、要素ごとの乗除算／行列としての乗除算の違いがある

<b>PythonSf ワンライナー</b>

sy(); ss.zeta(3,0)          # special function ζ(..) 
===============================
1.79769313486e+308
</span>
</code>
</pre>

<h4>numpy の info, source 関数</h4>
<p>
numpy の info(..) 関数は非常に便利です。help(..) 関数より、凝縮して情報を表示してくれ、また np.info(..) 関数の情報だけで十分なことが多いからです。パッケージ・モジュール・クラス・関数などドキュメント文字列を備えた全ての Python オブジェクトに対して使えます。 PythonSf 式だ下でなく、np.info(..) 関数は Python 一般で、もっと使われるべきです。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.info(set)
 set()

set() -> new empty set object
set(iterable) -> new set object

Build an unordered collection of unique elements.


Methods:

  difference_update  --  Remove all elements of another set from this set.
  symmetric_difference  --  Return the symmetric difference of two sets as a new set.
  pop  --  
  issuperset  --  Report whether this set contains another set.
  remove  --  Remove an element from a set; it must be a member.
  issubset  --  Report whether another set contains this set.
  union  --  Return the union of sets as a new set.
  add  --  Add an element to a set.
  discard  --  Remove an element from a set if it is a member.
  intersection  --  Return the intersection of two or more sets as a new set.
  symmetric_difference_update  --  Update a set with the symmetric difference of itself and another.
  update  --  Update a set with the union of itself and others.
  difference  --  Return the difference of two or more sets as a new set.
  copy  --  Return a shallow copy of a set.
  isdisjoint  --  Return True if two sets have a null intersection.
  clear  --  Remove all elements from this set.
  intersection_update  --  Update a set with the intersection of itself and another.
===============================
None
</span>
</code>
</pre>
<p>
np.source(..) 関数は、モジュール、クラス、関数の Python source code を表示する関数です。Python は短く書けるけれど可読性に優れた言語です。下手なドキュメントよりソース･コードを読んだ方が良く解ることが珍しくありません。Python document 文字列だけでは解りにくいときは、そのソース･コードを見てみましょう。下のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.source(mitr)
In file: pysf\basicFnctns.py

def mitr(*args):
    """ 多次元の繰り返しを生成するジェネレータ
        generator generating for multiple dimention iterators
    e.g.
    list(mitr(2,3))
    ===============================
    [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)]

    s=set(['a','b']);list(mitr(s,s))
    ===============================
    [('a', 'a'), ('a', 'b'), ('b', 'a'), ('b', 'b')]

    s=[1,2,3];list(mitr(s,s))
    ===============================
    [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]

    """
    head, tail = args[0], args[1:]

    if type(head) in [int, long, float]:
        head = range(int(head))

    if tail:
        if len(tail) == 1 and hasattr(tail[0],'next'):
            # to avoid multiple use of one iterator
            tailAt = (tuple(tail[0]), )
        else:
            tailAt = tail

        for i in head:
            for j in mitr(*tailAt):
                if len(tail) == 1:
                    yield (i, j)
                else:
                    yield (i,)+j
    else:
        for i in head:
            yield i

===============================
None
</span>
</code>
</pre>
<p>
ついでですが、上の mitr(..) generator は多重ループを一つのイタレータで済ますようにする generator 関数です。PythonSf ワンライナーでは短く多重ループ処理を記述できるので多用します。上のソースを追ってみれば、mitr(..) generator が関数プログラミング的に実装されており、任意の N 重ループも扱えることまで解るでしょう。
<p>
enmitr(..) は mitr(..) の機能に加えて、整数インデックスも返すので、行列・テンソル・データの作成に便利です。次のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# [-1,1]x[-1,1] の領域での x^2 - x y 関数分布を行列データとして作り、表示させる
dct={}; v=klsp(-1,1); for idx,pos in enmitr(v,v):dct[idx]=(`X^2-`X `Y)(*pos); renderMtrx(dct)
</span>
</code>
</pre>
<img src="./jpg/1111/oneliner_xpw2_xy.jpg">
<br>
<p>
分からないコードが出てきたときは、np.info(..), np.source(..) を使った PythonSf ワンライナーで、その機能や使い方を調べられます。上の klsp(..) の意味が分からないときは、これらを使って調べましょう。PythonSf のワンライナーを使えば、その確認・実行は簡単です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# klsp のソース: numpy の linspace に kryy(..) 関数を被せて ClTesnor インスタンスを変えているだけ
np.source(klsp)
In file: pysf\basicFnctns.py

def klsp(*sq, **dct):
    """' return ClTensor of scipy.linspace(...)
    '"""
    return sf.krry(sc.linspace(*sq, **dct) )

===============================
None

# [-1,1] の範囲を 49 等分する 50 点の ClTesor データ
klsp(-1,1)
===============================
[-1.         -0.95918367 -0.91836735 -0.87755102 -0.83673469 -0.79591837
 -0.75510204 -0.71428571 -0.67346939 -0.63265306 -0.59183673 -0.55102041
 -0.51020408 -0.46938776 -0.42857143 -0.3877551  -0.34693878 -0.30612245
 -0.26530612 -0.2244898  -0.18367347 -0.14285714 -0.10204082 -0.06122449
 -0.02040816  0.02040816  0.06122449  0.10204082  0.14285714  0.18367347
  0.2244898   0.26530612  0.30612245  0.34693878  0.3877551   0.42857143
  0.46938776  0.51020408  0.55102041  0.59183673  0.63265306  0.67346939
  0.71428571  0.75510204  0.79591837  0.83673469  0.87755102  0.91836735
  0.95918367  1.        ]
---- ClTensor ----

# [-1,1] の範囲を 5 等分する 6 点の ClTesor データ
klsp(-1,1, 6)
===============================
[-1.  -0.6 -0.2  0.2  0.6  1. ]
---- ClTensor ----
</span>
</code>
</pre>
<p>
np.inf(..), np.source(..) や PythonSf ワンライナーを使ってドキュメント文字列を調べたり、テスト・コードを実行してみることは PythonSf 式の作成だけに限らず、Python プログラミング一般の作成でも有効です。活用ください。
<!--
numpy 行列関数
その他で使う頻度の多い numpy 行列関数として下のようなものが PythonSf global 変数に取り込んでいます。
expm,logm, sqrtm, ['eigvalsh', 'eigvals', 'eig', 'eigh']
用例だけ
-->

<h4>np.ndarray, ClTensor, ClFldTns 行列の違い</h4>
<!--
ベクトルの内積はベクトルどうしの積によって計算させます。

vc=np.array([1,2,3]);vc[0]=2.4; vc
===============================
[2 2 3]
<== 何度も痛い目にあって、数値計算向けのデフォルト整数にしました。
ベクトル
<== デフォルト整数、dot を使わねばならない。
np.dot
    行列　ベクトルの積
    ClTensor/ClFldTns には縦ベクトル、横ベクトルの区別がない
最後のClTensor, ClFldTns 表記による区別

np.matrix は ndarray と統一が取れていない
<== fast tour の段階では避けるべき。
    np.matrix はあるが、使いにくい
        np.matrix(`σx) [1,2]
        matrices are not aligned at excecuting:np.matrix(k__bq__sSigma_x___) * [1,2]
        np.matrix(`σx) [[1],[2]]
        ===============================
        [[ 2.]
         [ 1.]]

numpy/scipy の行列・ベクトルは matlab に近い実装
三次元 vector 分布関数
~[`X^2+1,`X^2+`Y^2, `Z](1,2,3)
===============================
[ 2.  5.  3.]
---- ClTensor ----
-->
<p>
np.array(..) を使って生成する np.ndarray インスタンスは使いにくいので、PythonSf では ClTensor インスタンスを主に使います。整数、実数・複素数以外の一般の環・体を要素とする行列・ベクトルには ClFldTns を使います。~[...] 記法で作られるインスタンスのタイプは ClTensor または ClFldTns のどちらかです。
<p>
 np.ndarray インスタンスが使いにくいのは下の理由によります。
<ol>
<li>整数引数でインスタンスを生成すると、整数タイプの行列になる。その後に浮動小数点値を代入すると、小数点以下が切り取られる。
<li>行列やベクトルの間の演算に dot(...) 関数が必要になる。
</ol>
<p>
実際に ndarray 使ってみると、デフォルトで整数タイプの行列になることが非常に困ります。それらしく動いてしまうので、分からないまま少しだけ値が違う計算が入り込んでミスに気づかずに計算作業を蓄積していってしまうからです。後でミスを見つけ出すのが厄介だからです。数学の世界では浮動小数点と整数を区別しないことが大部分であり、注意していても その癖がどうしても入り込んでしまいます。ClTensor クラスは np.ndarray を継承しているのですが、デフォルトで浮動小数点タイプの行列やベクトルを生成するようにしてあります。
<p>
敢えて ClTensor を導入するのですから、np.dot(..) 関数を使わなくてもすむように、__mul__(..), __pow__(...) などの加減乗除べき乗算に対応する関数を定義した実装にしました。これにより、日常のメモ書きに近い PythonSf 数式による行列やベクトルの演算が可能にできました。
<p>
ClTensor インスタンスと tuple, list といった Python シーケンスも、そのサイズさえ合えば、ClTensor インスタンスとの加減乗除算をできるようにしています。ですから Matlab などと違って、縦ベクトル・横ベクトルの概念を使うことなく、行列とベクトルとの積や内積演算が行えるようにしてあります。下のような具合です。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 内積
vc=~[1,2,3]; vc ~[4,5,6]
===============================
32.0

# ベクトルとリストの内積
vc=~[1,2,3]; vc  [4,5,6]
===============================
32.0

~[k for k in range(1,4)] [4,5,6]
===============================
32.0

vc=~[1,2,3]; vc range(4,7) 
===============================
32.0

# ベクトルとタプルの内積
vc=~[1,2,3]; vc  (4,5,6)

# 行列とベクトルの積
mt = ~[[1,2],[3,4]]; mt ~[5,6]
===============================
[ 17.  39.]
---- ClTensor ----

# 行列とリストの積
mt = ~[[1,2],[3,4]]; mt  [5,6]
===============================
[ 17.  39.]
---- ClTensor ----

# リストと行列の積
mt = ~[[1,2],[3,4]]; [5,6] mt 
===============================
[ 23.  34.]
---- ClTensor ----

# 行列とタプルの積
mt = ~[[1,2],[3,4]]; mt  (5,6)
===============================
[ 17.  39.]
---- ClTensor ----
</span>
</code>
</pre>
<p>

<h4>numpy package から取り込み</h4>
<p>
scipy より小さいとはいえ、numpy package には PythonSf で頻繁に使うランダム関数、高速フーリエ変換、線形代数パッケージが備わっています。これらは np.random.rand(...) などと呼び出せるのですが、使う頻度からすると np.random などのモジュール名を何度も打ち込むのは面倒すぎます。これらが返すインスタンスのタイプが np.ndarray であることも、行列やベクトルの積演算を面倒にしてくれます。これらの対策として、以下のバッファ関数を PythonSf のグローバル名前空間に追加しています。
<h5>ランダム関数</h5>
<p>
numpy.random モジュールは整数乱数生成関数:randint(..)、0-1一様分布ランダム関数:rad(..)、正規分布ランダム関数:randn(..) といった便利に使える関数が備わっています。これらは行列やベクトルの乱数も生成でき非常に便利です。
<p>
でも np.random.rand(..) と長ったらしく書くのは不必要に PythonSf ワンライナー式を長くします。random モジュールが np.ndarray インスタンスを返すのも、ベクトルとの積などに np.dot(..) 関数を使わねばならず、不便です。なので下のようにグローバル変数に rand(..) 関数を置くためのバッファ関数を設けてあります。返すベクトルや行列は ClTensor インスタンスに変更しています。
<pre>
<code>
<span style="color: #9f009f;">
np.source(rand)
In file: pysf\kNumeric.py

def rand(*sqAg):
    if len(sqAg) == 0:
        return        (sf.sc.random.rand(*sqAg))
    else:
        return sf.krry(sf.sc.random.rand(*sqAg))

===============================
None
</span>
</code>
</pre>
<p>
seed(..), randint(..), randn(..) も同様に置き換えてあるので、次のような PythonSf 式を使った計算が可能になります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# [0,1] の範囲でのランダム変数を返す
seed(0); rand()
===============================
0.548813503927

# [0,1] の範囲でのランダム変数行列を返す
seed(0); rand(2,4)
===============================
[[ 0.5488135   0.71518937  0.60276338  0.54488318]
 [ 0.4236548   0.64589411  0.43758721  0.891773  ]]
---- ClTensor ----

# 正規分布でのランダム変数行列を返す
seed(0); randn(2,4)
===============================
[[ 1.76405235  0.40015721  0.97873798  2.2408932 ]
 [ 1.86755799 -0.97727788  0.95008842 -0.15135721]]
---- ClTensor ----

# 0 から 1 の整数値を要素とするランダムな行列
randint(9,size=[2,5])
===============================
[[5 6 7 3 1]
 [8 1 1 7 4]]
---- ClTensor ----

# デフォルトの浮動小数点タイプ要素からなるランダム行列
~[randint(9,size=[2,5])]
===============================
[[ 1.  0.  5.  2.  4.]
 [ 5.  1.  8.  5.  6.]]
---- ClTensor ----

# BOOL 体：1 or 0 を要素とするランダム行列
~[randint(2,size=[2,5]), oc.BF]
===============================
[[0 1 0 0 1]
 [1 1 0 0 0]]
---- ClFldTns:< class 'pysf.octn.BF'> ----
</span>
</code>
</pre>
<p>
下の PythonSf 式は sin(2θ)==2sin(θ)cos(θ) の公式を数値実験で確認しています。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# sin(2θ)== 2sin(θ)cos(θ) の証明・確認
vc=randn(10); [sin(2θ) for θ in vc] ~== [2 sin(θ) cos(θ) for θ in vc]
===============================
True

# 複素数値でも sin(2θ)== 2sin(θ)cos(θ)
mt=randn(2,10);vc=mt[0,:]+`i mt[1,:];  [sin(2θ) for θ in vc] ~== [2 sin(θ) cos(θ) for θ in vc]
===============================
True
</span>
</code>
</pre>
<p>
上の式を実行することで「正規表現分布するランダムなθに対し sin(2θ) が 2sin(θ)cos(θ) と六桁以上一致することを 10 回確認した」ことになります。~== は neqlyEq(..) 関数を customize.py でアサインしてある PythonSf ユーザー定義の中置演算子です。これは六桁の精度で一致すれば True を返します。(浮動小数点演算ではコンピュータの計算誤差により、数学公式が成り立たないことが普通なので == 演算子は使えません。)負数も含めて、六桁の精度で十回一致することは sin(2θ)==2sin(θ)cos(θ) が成り立つことを証明したといっても過言ではないでしょう。人間の論証による証明では、それよりずっと多くの確率で誤りが入り込むからです。
<p>
このような確認・証明のために random 関連の関数が便利に使えます。
<p>
numpy.random モジュールには shuffle(..) 関数があり、シーケンス引数の中身を置換してくれます。ただし引数シーケンス・レファランスが指しているシーケンス・データを書き換えます。np.random.shuffle(..) 関数の戻り値は None です。でもワンライナーで書くときには、戻り値も引数レファレンスを返すことが強く望まれます。shuflle(..) 関数もグローバル変数名にすることも含めて、PythonSf グローバル変数の shuflle(..) 関数は下のように修正してあります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.source(shuffle)
In file: pysf\kNumeric.py

def shuffle(sqAg):
    sf.sc.random.shuffle(sqAg)
    return sqAg

===============================
None
</span>
</code>
</pre>
<p>
この結果、下のような使い方ができます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
shuffle(range(10))
===============================
[1, 7, 4, 9, 0, 2, 5, 3, 6, 8]

# 比較： numpy の shuffle(..) 関数
np.random.shuffle(range(10))
===============================
None

</span>
</code>
</pre>
<br>
<h5>高速フーリエ変換:FFT</h5>
<p>
高速フーリエ（逆）変換は多くの分野で頻繁に使われます。PythonSf のグローバル名前空間に置くべきです。同時に ClTensor インスタンスを返すようにしたほうが便利です。このように考えて numpy.fft package の fft,ifft 関数のバッファ関数 fft,ifft および fftshift をグローバル変数領域に置いてあります。戻り値も ClTensor インスタンスを返すように修正してあります。
<p>
ただし numpy の fft(..) ifft(..) はベクトルの norm を保存しません。Matlab と同様にスペクトル密度を保つようにフーリエ（逆）変換されます。でも数学的には ノルムを保つフーリエ（逆）変換が望まれることも多くあります。このため nft(..), inft(..):ノルムを保つフーリエ（逆）変換もグローバル変数空間に追加してあります。
<p>
なお FFT といっても、任意のベクトル長を対象にフーリエ変換します。2^N 長に限りません。以下のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
N=7; fft(range(N))
===============================
[ 21.0+0.j          -3.5+7.26782489j  -3.5+2.79115686j  -3.5+0.79885216j
  -3.5-0.79885216j  -3.5-2.79115686j  -3.5-7.26782489j]
---- ClTensor ----

N=7; ifft(fft(range(N)))
===============================
[  2.91830052e-15+0.j   1.00000000e+00+0.j   2.00000000e+00+0.j
   3.00000000e+00+0.j   4.00000000e+00+0.j   5.00000000e+00+0.j
   6.00000000e+00+0.j]
---- ClTensor ----

N=7; nft(range(N))
===============================
[ 7.93725393+0.j         -1.32287566+2.7469796j  -1.32287566+1.05495813j
 -1.32287566+0.30193774j -1.32287566-0.30193774j -1.32287566-1.05495813j
 -1.32287566-2.7469796j ]
---- ClTensor ----

N=7; inft(nft(range(N)))
===============================
[  2.85344905e-15+0.j   1.00000000e+00+0.j   2.00000000e+00+0.j
   3.00000000e+00+0.j   4.00000000e+00+0.j   5.00000000e+00+0.j
   6.00000000e+00+0.j]
---- ClTensor ----

N=7; norm(fft(range(N))) ~== ( sqrt(N) norm(nft(range(N))))
===============================
True
</span>
</code>
</pre>

<!--
2 のべき乗の長さに限りません。
norm の保存
fft,
    ClTensor を返す
-->
<h5>expm,logm, sqrtm, eigvalsh, eigvals, eig, eigh</h5>
<p>
行列の指数関数:expm(.), 対数関数:logm(.), 平方根関数 sqrtm(.) や固有値を求める関数eigvals(.)/eigvalsh(.)、行列の固有値と固有ベクトルを求める関数:eig(.)/eigh(.) もグローバル変数空間におくと同時に ClTensor インスタンスを返すように修正してあります。下のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
t=0.1; expm(`σx t)
===============================
[[ 1.00500417  0.10016675]
 [ 0.10016675  1.00500417]]
---- ClTensor ----

<b>PythonXf ワンライナー</b>
t=0.1; logm( expm(`σx t) )
===============================
[[ -9.02056208e-17   1.00000000e-01]
 [  1.00000000e-01  -9.02056208e-17]]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
t=0.1; sqrtm(`σx t)
===============================
[[ 0.15811388+0.15811388j  0.15811388-0.15811388j]
 [ 0.15811388-0.15811388j  0.15811388+0.15811388j]]
---- ClTensor ----

t=0.1; sqrtm(`σx t)^2
===============================
[[ 0.0+0.j  0.1+0.j]
 [ 0.1+0.j  0.0+0.j]]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
t=0.1; eigvalsh(`σx t)
===============================
[-0.1  0.1]
---- ClTensor ----

t=0.1; eigh(`σx t)
===============================
(ClTensor([-0.1,  0.1]),
ClTensor([[-0.70710678,  0.70710678],
          [ 0.70710678,  0.70710678]]))

<b>PythonSf ワンライナー</b>
t=0.1; mt=`σx t; mt[1,1]=3; eigvals(mt)
===============================
[-0.00332964  3.00332964]
---- ClTensor ----

t=0.1; mt=`σx t; mt[1,1]=3; eig(mt)
===============================
(ClTensor([-0.00332964,  3.00332964]),
ClTensor([[-0.99944614, -0.03327794],
          [ 0.03327794, -0.99944614]]))
</span>
</code>
</pre>
<p>
その他の scipy 非ufunc で頻繁に使うものがあるときは、これらと同様なバッファ関数を作り、ClTensor インスタンスを返すようにして customize.py などに実装しておくと便利です。
<br>
<h3>sympy パッケージの利用</h3>
<p>
sympy パッケージにより symbolic な数式処理を可能にします。sympy はまだ出来立てであり、Mathematica, Maxima などと比較すれば見劣りします。何百行にもなるプログラムで sympy を使いまくれば、たぶん sympy のバグに遭遇するでしょう。でもワンライナーで記述できるようなレベルでは十分に実用的なレベルにあります。
<p>
PythonSf で sympy を利用するには ts() 関数を最初に呼び出します。この関数呼び出しにより「import sympy as ts」が実行されるとともに、`x,`y,`z,`t の sympy シンボリック変数が定義されます。これにより以下のようなシンボリックな演算処理が可能になります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# x+y+z = 6
# x-y   = 0 を x,y 変数に対して解く
ts(); ts.solve( [`x+`y+`z-6, `x-`y], [`x,`y] )
===============================
{x: -z/2 + 3, y: -z/2 + 3}

<b>PythonSf ワンライナー</b>
# (x+z) y = 6
# x-y     = 0 を x,y 変数に対して解く
ts(); ts.solve( [(`x+`z) `y-6, `x-`y], [`x,`y] )
===============================
[(-z/2 + (z**2 + 24)**(1/2)/2, -z/2 + (z**2 + 24)**(1/2)/2),
 (-z/2 - (z**2 + 24)**(1/2)/2, -z/2 - (z**2 + 24)**(1/2)/2)]
</span>
</code>
</pre>

<h3>単位付き計算</h3>
<p>
PythonSf では SI 単位系付の計算が可能です。sympy.physics.unit の単位を利用しています。「`」による名前空間の拡張を利用して customize.py の中で A`,Ω`,V` などに電流、抵抗、電圧などの単位を割り振っています。っています。sympy を利用するので ts() を呼び出してから使えるようになります。下のような具合です。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 電圧／電流--> 抵抗
ts(); V,I=3.0V`, 2  A`; V/I
===============================
1.5*V`/A`

# 電圧／抵抗 --> 電流
ts(); V,R=3.0V`, 1.5Ω`; V/R
===============================
2.0*A`
</span>
</code>
</pre>
<p>
f` p` n` u` mili` k` M` G` hour` min` s` ms` us` ns` ps` kg` g` =1, nm` um` mm` cm` m` met met km` inch` feet` mile` C` A` mA` uA` V` mV` uH` F` uF` pF` Ω` kΩ` ohm` Hz` N` J` mLght` の単位を customize.py で定義してあります。この部分の Python code を追加修正することで、ユーザーの望みの単位を追加できます。

<h4>単位付の物理定数</h4>
<p>
下の主だった物理定数も単位付きで customize.py に定義してあります。
<pre>
<code>
<span style="color: #9f009f;">
<b>Python コード</b>
    #=========== 物理定数 begin ==================================
    # light velosity m/s
    k_c_bq____ = 2.99792458e+8 * ut.m / ut.s            #@:c` --> k__bq__c___

    # プランク定数 h/2π 1.054571628(53)×10-34 J s 
    k_h_bq__bq____ = 1.054571628e-34 * ut.J * ut.s      #@:h`` --> h/(2π)
    k_h_bq____ = 6.62606896e-034 * ut.J * ut.s          #@:h` -->


    #ボルツマン定数   J K^-1。 K は絶対温度の単位です。 Joule/Kelvin
    k_kB_bq____ = 1.380662e-23 * ut.J / ut.K            #@:kB` -->

    #万有引力定数 gU` = 6.67259 ×10-11  N` m`^2 `kg-2 
    k_gU_bq____ = 6.67259e-11 * ut.N * ut.m**2 / ut.kg**2 #@:gU` -->
    #重力加速度 gH`  = 9.80665  m s-2 
    k_gH_bq____ = 9.80665 * ut.m / ut.s**2              #@:gH` -->

    #素電荷 eQ`  = 1.6021892 ×10-19  C 
    k_eQ_bq____ = 1.6021892e-19 * ut.C
    #電子質量 eM`  = 9.10938188 ×10^-31  kg 
    k_eM_bq____ = 9.10938188e-31 * ut.kg
    #陽子質量 pM`  = 1.67262157 ×10^-27  kg 
    k_pM_bq____ = 1.67262157e-27 * ut.kg
    #水素原子質量 HM` = 1.6735 ×10^-27  kg 
    k_HM_bq____ = 1.6735e-27 * ut.kg
    #モル数,Avogadro 数　 NA`  = 6.02214199 ×10^23  mol-1
    k_NA_bq____ = 6.02214199e+23 / ut.mol
    #モル体積 Vm`  = 2.241383 ×10-2  m3mol-1 
    k_Vm_bq____ = 2.241383e-2 * ut.m**3 / ut.mol

    #真空の透磁率 1.2566370614E-06 == 4`π 1e-7, 物理単位 N` A`^-2 == henry/meter == weber/(ampere meter)
    k__sMu_0_bq____ = 1.2566370614e-6 * ut.H/ut.m        #@μ0` -->
    k_u0_bq____ = 1.2566370614e-6 *ut.H/ut.m
    # 真空の誘電率 ε0 == 1/(`c^2 4`π 1e-7)==クーロン**2 / (newton * M ** 2) == farad/meter == coulomb/(volt meter)
    k__sEpsilon_0_bq____ = 8.854187816e-12 * ut.F/ut.m  #@:ε0` -->
    k_e0_bq____ = 8.854187816e-12 * ut.F/ut.m

    #ボルツマン定数   J K^-1 K は絶対温度の単位です。Kg ではありません
    k_kB_bq____  = 1.380662e-23 * ut.J/ut.K     # Joule/ kelvin degree
    #=========== 物理定数 end = ==================================
</span>
</code>
</pre>
<p>
ですから、下のようなワンライナー計算ができます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# E == m c^2 == h ν
# ∴ ν== m c^2/h
# 電子の四次元時空での振動数
ts(); eM` c`^2/h`
===============================
1.23558993864461e+20/s`
</span>
</code>
</pre>

<p>
どんな単位、どんな物理定数が必要なのかはユーザーの専門分野によって大きく変わってきます。PythonSf での物理単位・物理定数は customize.py にある Python code で定まります。この Python code を変更することで、ユーザーの望むとおりに単位系・物理定数変数名をカスタマイズできます。

<h4>実数値のみの単位</h4>
<p>
単位系付きの PythonSf 式の利点の一つとしてドキュメント性の向上があります。「15V` * 1.3A`」と書けば電圧値と電流値を掛け合わせているのであり、電力値：ワットを求めようとしていることまで読み取れます。
<p>
一方で sympy 単位付きの値を引数として扱えるのは sympy の関数と PythonSf の基本関数・その加減乗除べき乗合成関数に限られます。numpy など一般の Python 関数は sympy 単位付きの値を引数として扱えません。たとえ単位どうしが打ち消しあって無次元の物理量になったとしても、普通の関数では扱えません。下のようなエラーになります。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# numpy の sin 関数に sympy 単位付きの引数値を与える
ts(); np.sin( 2pi 50Hz` 0.1s`)
Traceback (most recent call last):
    sniped
AttributeError: sin

# sin 関数を PythonSf 基本関数にして sympy 単位付きの引数値を与える
ts();    sin( 2pi 50Hz` 0.1s`)
===============================
2.32806687965e-15
</span>
</code>
</pre>
<p>
でも、ドキュメント性のためだけならば Hz` などの単位に sympy 単位付きの値を割り振る必要はありません。Hz` や s` に値 1 だけを割り振っておいても、ドキュメント性は損なわれません。ならば ts() を呼び出さないときは、単位系には数値の 1 を入れておくだけにしとくべきだ。sympy 単位系を付けずにおくべきだ。ならば下のようなドキュメント性のある PythonSf 計算式が一般の Python 関数でも可能になる。そうすれば下のような計算が可能になる。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
      np.sin( 2pi 50Hz` 0.1s`)
===============================
2.32806687965e-15
</span>
</code>
</pre>
<p>
このように考えて ts() を実装してあります。興味のある方は pysf.customize.ts(..) 関数のソースを読んでみてください。

<h4>MKSA:SI 単位系と MKSAV 単位系</h4>
<p>
<a href="http://www.nmij.jp/library/units/si/R8/SI8J.pdf">SI 単位系の規格書</a>は理由なしに、如何に使うかのみを説明しています。さらに SI 単位系は歴史的な経緯に妥協して制定されています。大部分の技術者にとって、電流のほかに電圧:V:Volt または抵抗:Ω:ohm も基本単位なのに、SI 単位系では電流:A のみを基本単位としています。結果として、抵抗値や電圧値は MKSA の四つの基本単位の組み合わせとなります。実際 sympy.physics.units の単位系の実装は、SI 単位系規格書どおりの実装となっています。下のような単位付きの計算結果となります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 抵抗値 * 電流値:R I == 電圧値：V
import sympy.physics.units as ut; R,I=1.5ut.ohm, 2ut.A; R I
===============================
3.0*m**2*kg/(A*s**3)

# 電圧値 / 電流値:V/I == 抵抗値：ohm
import sympy.physics.units as ut; V,I=3.0ut.V  , 2ut.A; V/I
===============================
1.5*m**2*kg/(A**2*s**3)
</span>
</code>
</pre>
<p>
でも電圧の単位が「m**2*kg/(A*s**3)」と、また抵抗の単位が「m**2*kg/(A**2*s**3)
」と表記されて分る技術者が、どれだけいるでしょうか。技術者の大部分は A,V の二つを基本単位として電気・電子工学を理解しています。ですから MKSA ではなく MKSAV 単位系として実用的な単位系を構築すべきです。そのように PythonSf の単位系は実装してあります。上の計算は、PythonSf では下のようになります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 抵抗値 * 電流値:R I == 電圧値：V
ts(); R,I=1.5Ω`, 2A`; R I
===============================
3.0*V`

# 電圧値 / 電流値:V/I == 抵抗値：ohm
ts(); V,I=3.0V` , 2A`; V/I
===============================
1.5*V`/A`
</span>
</code>
</pre>
<p>
この MSKAV 単位系という主張は理解してもらいにくいのですが、如何でしょうか。理解してもらえるかとは関係なしに、上のような単位系計算でなければ使い物にならないと考えています。
<p>
ただし MKSAV 単位系は冗長であり W` s` と J`の変換はユーザーが自分で行わねばなりません。V`,A`,s` の組み合わせで作られる電気系の単位と、kg`,m`,s` の組み合わせで作られる機械系の単位の両者の接点： W` s`==J` の電気・機械エネルギー単位による変換を使って、ユーザーが明示的に関係付けねばなりません。下の様にです。少し面倒ですが、これが大部分の方の理解している単位系だと思います。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 電圧値 * 電流値:V I == 電力:W`
ts(); V,I=3.0V` , 2A`; V I
===============================
6.0*A`*V`

# 電圧値 * 電流値:V I == 単位時間当たりの仕事:J`/s`
ts(); V,I=3.0V` , 2A`; V I J`/(W` s`)
===============================
6.0*m`**2*kg`/s`**3
</span>
</code>
</pre>

<a name="■■ グラフ表示"></a>
<h2>■■ グラフ表示</h2>
<p>
Python には pylab, mayavi といったグラフ表示パッケージがあります。これらは 3D 表示まで可能な素晴らしいものです。論文に載せる品質のグラフも描けます。
<p>
でも、グラフを描くのに手間がかかりすぎます。自分のために描くグラフならば凡例なんぞ要りません。多くの場合は横軸スケール値さえ要りません。ユーザー自身が分っていることが多いからです。それよりも最小の手間でグラフ情報を表示させるほうが優先されます。ワンライナーでグラフ表示させるときは、一刻でも早くどんな分布をしているのか見たくてしょうがないのですから。そのために PythonSf では plotGr(..), plotTrajectory(..), plot3dGr(..), renderFaces(..), plotTmCh(..) といった関数を用意しています。
<h3>二次元グラフ表示関数：plotGr(..)</h3>
plotGr(..) 関数は、とにかく最小の手間で二次元グラフを表示するように作ってあります。plotGr(..) に関数引数を与えるだけでも、[0,1] のデフォルト範囲で、デフォルト 50 点の値を直線で繋いだ二次元グラフを表示します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
plotGr(sin( 2pi `X^2)  )
</span>
</code>
</pre>
<br>
<img src="./jpg/1108/plotGrSinMXP2.jpg">
<p>
範囲 [-2,3] データ点数 256 で表示させるときは下のように引数パラメータを増やします
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
plotGr(sin( 2pi `X^2), -2, 3, 256)
</span>
</code>
</pre>
<br>
<img src="./jpg/1108/plotGrSinMXP2_m2p3_s256.jpg">
<p>
tuple, list, array などのシーケンス・データを与えることでもグラフを表示させられます。ただし、このとき横軸は len(シーケンス・データ) になっています。でもユーザーは横軸の範囲が [-2,2] であることは分っているので問題ありません。 plotGr([sin( 2pi `X^2)(t) for t in klsp(-2,2, 128)]) の PythonSf 式を書いたユーザーがグラフを見ているのですから。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
plotGr([sin( 2pi `X^2)(t) for t in klsp(-2,2, 128)])
</span>
</code>
</pre>
<br>
<img src="./jpg/1108/plotGrSinMXP2_m2p2_s128.jpg">
<h3>軌跡表示関数：plotTrajectory(..)</h3>
<p>
plotTrajectory(..) は引数に二次元位置のデータからなるシーケンス・データを与えることで、それらの位置を直線で結んだ二次元グラフを表示させます。下のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
plotTrajectory([(0.9 cos(θ),sin(2θ)) for θ in arsq(0, 256,2pi/256)])
</span>
</code>
</pre>
<br>
<img src="./jpg/1108/plotTrjctryCosSin2.jpg">
<p>
三次元位置のシーケンスを与えると、三次元の軌跡を描きます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
plotTrajectory([(0.9 cos(θ),sin(2θ), θ) for θ in arsq(0, 256,2pi/256)])
</span>
</code>
</pre>
<br>
<img src="./jpg/1108/plotTrjctryCosSin2θ.jpg">
<h3>三次元グラフ表示関数：plot3dGr(..)</h3>
<p>
二変数関数：f(x,y) の三次元形状を調べるには plot3DGr(..) を使います。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
plot3dGr(sin(`X) cos(`Y), [-pi,pi],[pi,-pi])
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliner_sin_cos.jpg">
<p>
複素平面上の複素数値関数：f(x,y) の四次元パラメータ形状も表示できます。位相回転を RGB 三色の混ざり具合で表示します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
plot3dGr(sin(`X) cos(`X), [-pi,pi],[pi `i,-pi `i])
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliner_sin_cos_cmplx.jpg">
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
plot3dGr(log, [-pi,pi],[pi `i,-pi `i])
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliner_log_cmplx.jpg">
<br>
<h3>行列データの三次元描画関数 renderMtrx(..)/renderMtCplx(..)</h3>
<p>
何らかの関数 f(x,y) の長方形領域での値分布行列を可視化したくなることも多いものです。単なる数値の塊だけでは、値分布の傾向を掴むことは困難です。でも、下のように三次元グラフとして可視化してやれば傾向性を一目で掴めます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
seed(0);vc=~[range(10)]; renderMtrx(vc^vc + 3 randn(10,10))
</span>
</code>
<br>
<img src="./jpg/1111/oneliner_render_mtrx_vc_vc.jpg">
<p>
renderMtCplx(..) 関数を使えば、複素数値を要素とする行列の三次元表示ができます。位相回転は RGB の混ざり具合で表します。
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
seed(0); vc=~[range(10)]; renderMtCplx(vc^vc+3(randn(10,10)+`i randn(10,10)))
</span>
</code>
<br>
<img src="./jpg/1111/oneliner_render_mtrx_vc_vc_cplx.jpg">
<br>
<br>
<br>

<h3>三次元曲面描画関数：renderFaces(..)/renderFacesRGB(..)</h3>
<p>
行列要素を三次元の位置ベクトルとする行列値引数を renderFaces(.) 関数に与えてやれば、行列メッシュ平面を そのベクトル要素位置に変換した三次元平面を描画できます。下に例を示します。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
# メビウスの環<br>
dct={}; for idx, (u,v) in enmitr(klsp(0,2pi),klsp(-1,1,10)):dct[idx]=((1+0.5v cos(0.5u))cos(u), (1+0.5v cos(0.5u))sin(u), 0.5v sin(0.5u)); renderFaces(dct,blMesh = True)
</span>
</code>
<br>
<img src="./jpg/1111/oneliner_render_moebius_ring.jpg">
<p>
位置ベクトルを要素とするような行列を作るときは、上のように辞書による行列が便利です。あらかじめデータに整合するサイズの行列を宣言する必要がないからです。位置ベクトルを要素とする行列のような面倒なものを考えずに済むからです。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ブロック</b>
# クラインの壷
//@@
dct,N,M,r={},64,32,5;
for (u,v), index in zip(masq([0,N,2pi/N], [-1,M+1,2pi/M]), mrng(N,M+1) ):
    dct[index]=( (r+cos(u/2) sin(v)-sin(u/2) sin(2v)) cos(u)
                ,(r+cos(u/2) sin(v)-sin(u/2) sin(2v)) sin(u)
                ,sin(u/2) sin(v) + cos(u/2) sin(2*v) )

sf.renderFaces(dct, blMesh = True)
sf.drawAxis()
//@@@
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliner_render_kleins_bottle.jpg">
<p>
位置ベクトルに加えて RGB カラーベクトル値も要素とする辞書行列を renderFacesWithRGB(.) 関数を与えてやれば、三次元の色つき曲面を描画させられます。下に例を示します。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 球面調和関数<br>
m,l=0,2;sy();clAt = ClCplxColor();psCl=λ θ,φ:(λ cplxAg=ss.sph_harm(m,l,φ,θ):(abs(cplxAg) ~[sin(θ)cos(φ),sin(θ)sin(φ),cos(θ)], clAt.GetFltColor(0.99 cplxAg/abs(cplxAg))))();dct={};for idx,(θ,φ) in enmitr(klsp(0,pi),klsp(0,2pi)):dct[idx]=psCl(θ,φ);renderFacesWithRGB(dct)
</span>
</code>
<br>
<img src="./jpg/1111/oneliner_render_harmonic.jpg">
<br>
<br>
<h3>kkRGB 平面複素数値分布表示関数:render2dRGB</h3>
<p>
解析関数の値分布を表示するために、kkRGB 表示と名付けた複素数値行列の値分布表示関数:render2dRGB(..)を用意しています。
<p>
この関数は下のような引数値をとります。mtrxAg は複素数値行列です。この行列要素をピクセル一つづつに対応させ、四角い jpg 画像を作ります。複素数値の位相角に RGB の混ざり具合を対応させ、その絶対値に明度を対応させます。100x100 のような小さな行列では 100 pixcel x 100 pixcel の小さな画像になってしまいます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.info(render2dRGB)
 render2dRGB(mtrxAg, boundary=1.0, limit=10.0, blReverse=False, blBoth=False,
             fileName='kkRGB', blDisplay=True, blMax=False)

' Render a complex value distribution with kkRGB color for matrix argument
        rendered figure is saved at kkRGB.jpg file as a default
    e.g.
vc=klsp(-3,3,300); f=`X^3+`X^2+`X+1; dct={};for idx,(x,y) in enmitr(vc,vc):dct[idx]=f(x+`i y); render2dRGB(dct)
    '
===============================
None
</span>
</code>
</pre>
<p>
`X^3+`X^2+`X+1 多項式の複素数値分布を render2dRGB(..) 関数で表示させて見ましょう。 下のような具合です。(render2dRGB(..) 関数は、Python の Image モジュールを使って mtrxAg データを変換して kkRGB.jpg ファイルをカレント・ディレクトリに作り、それを start 実行します。すなわち jpg 拡張子に OS で関連付けられたプログラムで kkRGB.jpg 画像が表示されます。)
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
vc=klsp(-3,3,300); f=`X^3+`X^2+`X+1; dct={};for idx,(x,y) in enmitr(vc,vc):dct[idx]=f(x+`i y); render2dRGB(dct)
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_render_2d_rgb_xp3_xp2_x_1.jpg">
<p>
上の図で中央に分布している三つのぼやけた黒い丸い領域の中心が、多項式 x^3+x^2+x+1 の複素根の位置に対応しています。根の位置で関数値が 0 になるので、その明度も 0 になっています。(この多項式の根は、下の PythonSf 式で求められます。)
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
poly1d([1,1,1,1],variable='x')
===============================
   3     2
1 x + 1 x + 1 x + 1

<b>PythonSf ワンライナー</b>
poly1d([1,1,1,1]).roots
===============================
[ -1.00000000e+00+0.j  -7.77156117e-16+1.j  -7.77156117e-16-1.j]
</span>
</code>
</pre>
<p>
真ん中の連続的に変化している領域と四色のみで色分けされている領域の境目が、関数値の絶対値が 1 になっているところです。デフォルト引数 boundary=1.0 で絶対値の 1 が指定されいます。
<p>
外側の白い領域との境界が、関数値の絶対値が 10 になるところです。この絶対値 10 は、デフォルト引数 limit=10.0 で指定されています。
<p>
四色のみで色分けされている領域は絶対値が 1 以上 10 以下ということになります。この四色は、複素平面の実数直線と純虚数直線で区切られた四つの領域に対応します。ですから、赤と黄色の境界は、関数値が正の実数値となる位置であり、黄色と緑の境界は、正の純虚数値となる位置です。なまじ RGB の連続的な変化より、四色の境界分布のほうが解析関数の位相の回り方がよく分かると思います。たとえば、解析関数の等高線と等位相線は直行することが、上の kkRGB 図より読み取れます。(これは解析関数一般になりたつ性質です。)如何でしょうか。
<p>
多項式 x^3+x^2+x+1 の複素数値分布は、下のように plot3dGr(..) 関数でも表示させられます。こっちの方が手っ取り早く表示できるのですが、reder2dRGB(..) のほうが値分布の詳細をイメージしやすいと思います。皆様はいかがでしょうか。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
plot3dGr(`X^3+`X^2+`X+1, [-3,3],[3`i,-3`i])
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_render_mt_cplx_xp3_xp2_x_1.jpg">
<br>
<p>
render2dRGB(..) 関数は下のような表示にも使えます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ブロック</b>
<br>
//@@
N=512;
def check(c,z=0,k=0):
    return k>500 and 500 or abs(z) < 2 and check(c,z^2+c,k+1) or k;

dct={};
for idx,(x,y) in enmasq((-2,N,4/N),(2`i,N,-4`i/N)):
    dct[idx]=check(x+y);

def convertTo4cplxVl(inAg):
    return inAg==500 and 0.1+0j or inAg>30 and 1+0j  or inAg>10 and 1j or inAg>5 and -1+0j or -1j

for idx in mrng(N,N):
    dct[idx]=convertTo4cplxVl(dct[idx]);

render2dRGB(dct)
//@@@

</span>
</code>
</pre>
<img src="./jpg/1111/oneliners_render_2d_mandelbrot.jpg">
<br>
<h3>タイムチャート表示関数：plotTmCh(..)</h3>
<p>
plotTmCh(.) 関数に行列引数を与えてやれば、行列の各横ベクトルをタイム・チャート・テータとして表示します。下の 1bit D/A covertor の動作の様子をタイム・チャートとして表示します。
<pre>
<code>
ΔΣ DA converter                   in >= 2**15 --> 1
                                    in <  2**15 --> 0
   16  +┌───┐  +   ┌──┐    ┌────────┐    1           
→─／─┤Adder ├─→○┤z^-1├┬─┤Digtal      1bit├┬─／───／＼／＼／＼／─┬────
    ┌─┤      │   -↑└──┘│  │Comparator  D/A ││                          │
    │ -└───┘    └────┘  └────────┘│                        ─┴─
    │                  integrator                      │                        ─┬─ C/s
    └─────────────────────────┘                          │
                                                                                    ┴  
             Δ            Σ                                                        =
 A:入力                  B:intergrator:countor             C:output: 1 or -1
</code>
</pre>
<p>
下のワンライナーは、上の 1bit D/A convertor の A点、B点、C点の変化の様子をシミュレーション計算して、タイムチャートに表示しています。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
N=256;f=λ sg,ds,out:(λ dsAg=ds+sg-out*2^15:[sg,dsAg,1 if dsAg>0 else -1])();mt=kzrs(3,N); mt[:,0]=(0,0,0);for i in range(N-1):mt[:,i+1]=f(2^15 sin(2pi i/N),*mt[:,i][1:]);plotTmCh(mt)
</span>
</code>
<br>
<img src="./jpg/1111/oneliner_plottmch_1bit_da.jpg">
<h3>ユーザーによるグラフ表示関数の作成</h3>
<p>
PythonSf でのグラフ表示関数はユーザー側でも簡単に実装可能です。pylab のようなグラフ表示パッケージがあるのですから。上に述べたグラフ表示関数も全てソースを公開しています。下のワンライナーで、plotTmCh(..) 関数のソースを見れます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.source(plotTmCh)
In file: pysf\vsGraph.py

def plotTmCh(vctMtrxAg):
    """' plot time chart for vector,array or matrix dictionary data
    '"""
    import pylab as pb
    def __plotTmChX(vctMtrxAg):
        n = len(vctMtrxAg)
        lstYAt = [None]*(2*n)
        lstYAt[0::2] = vctMtrxAg
        lstYAt[1::2] = vctMtrxAg
        lstYAt = [vctMtrxAg[0]]+lstYAt+[vctMtrxAg[-1]]

        lstXAt = [None]*(2*(n+1))
        lstXAt[0::2] = range(n+1)
        lstXAt[1::2] = range(n+1)

        maxAt = max(vctMtrxAg)
        minAt = min(vctMtrxAg)
        pb.plot(lstXAt, lstYAt)

        if maxAt != minAt:
            lstAxisAt = list(pb.axis())
            meanAt = float(maxAt + minAt)/2
            lstAxisAt[2] = minAt + (minAt - meanAt)*0.2 # set Y axis min
            lstAxisAt[3] = maxAt + (maxAt - meanAt)*0.2 # set Y axis max
            pb.axis(lstAxisAt)

    assert '__getitem__' in dir(vctMtrxAg)
    if isinstance(vctMtrxAg, dict) or '__len__' in dir(vctMtrxAg[0]):
        if isinstance(vctMtrxAg, list):
            assert not('__getitem__' in dir(vctMtrxAg[0][0]))
            colSizeAt = len(vctMtrxAg)
        elif isinstance(vctMtrxAg, dict):
            lstAt = vctMtrxAg.keys()
            lstAt.sort()
            shapeAt = lstAt[-1]
            shapeAt = (shapeAt[0]+1, shapeAt[1]+1)
            assert shapeAt[0]*shapeAt[1] == len(lstAt),\
                "dictionary vctMtrxAg index is not alined" + str(objarAg)

            krAt = kzrs(shapeAt)
            for index in sf.mrng(*shapeAt):
                krAt[index] = vctMtrxAg[index]

            vctMtrxAg = krAt
            colSizeAt = shapeAt[0]
        else:
            assert isinstance(vctMtrxAg, sf.sc.ndarray)
            assert len( vctMtrxAg.shape ) == 2

            colSizeAt = vctMtrxAg.shape[0]

        for i, elmAt in enumerate(vctMtrxAg):
            # don't use subplot(,,0) not to shift upper
            pb.subplot(colSizeAt, 1, i+1) 
            __plotTmChX(elmAt)
    else:
        __plotTmChX(vctMtrxAg)

    pb.show()

===============================
None

</span>
</code>
</pre>
<p>
グラフ表示関数の実装なんて大変だと思われるかもしれません。でも vpython または matplotlib パッケージを使っているので、PythonSf のグラフ表示関数は数十行で記述できてしまうものばかりです。これらは全てソースまで公開しています。上の np.source(..) により PythonSf ワン･ライナーでソースを見ることも可能です。必要なグラフ表示機能はユーザーによって異なります。ぜひともユーザー側でのグラフ表示関数の実装にも挑戦してみてください。それらができたら customize.py または sfCrrntIn.py ファイルに書いてやるだけで、PythonSf 式として利用できるようになります。
<a name="■■ 積分:quadR(..), quadC(..), quadAn(..)"></a>
<h2>■■ 積分:quadR(..), quadC(..), quadAn(..)</h2>
<p>
Python の数値積分では scipy.integrate.quad が有名です。でも、この quad(..) 関数は、積分値と、その推測誤差の tuple pair を返してくれます。計算誤差まで返してくれるのは、一見良さそうですが、グラフを描かせたりするときは積分値のみ取り出す必要があり、ワンライナーで短く書くには返って不都合です。
<p>
また複素数値関数や調和関数の積分も行えるようにしたいので、PythonSf では quadR, quadC, quadAn 関数を用意しています。
<h3>quadR </h3>
<p>
quadR(実数値関数, 下限、上限) と引数を与えることで数値積分を計算します。下限・上限値には無限大：sy.inf を指定することも可能です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# pi 
#∫ sin(x) dx == 2
# 0
quadR(sin, 0,pi)
===============================
2.0

<b>PythonSf ワンライナー</b>
# ∞
#∫ exp(-x^2) dx == π^0.5
#-∞
# scipy の quad(..) であり計算誤差の推定値も含めた計算結果を返す
sy();si.quad(exp(-`X^2), -sy.inf, sy.inf)
===============================
(1.7724538509055159, 1.4202636756658795e-08)

# PythonSf の quadR(..) であり積分値の計算結果のみを返す。誤差は返さない。
quadR(exp(-`X^2), -np.inf, np.inf)
===============================
1.77245385091

# 参考 π^0.5
sqrt(pi)
===============================
1.77245385091

print '%1.20f'%sqrt(pi)
1.77245385090551590000
-------------------------------
None
</span>
</code>
</pre>

<h3>quadC </h3>
<p>
quadC(複素数値関数, 下限、上限) と引数を与えることで、複素数値関数の数値積分を計算します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# Fourier Transform function value
~[quadC(exp(2pi `i ν `X) exp(-`X^2), -np.inf, np.inf) for ν in arsq(0,5,1/5)]
===============================
[ 1.77245385+0.j  1.19432452+0.j  0.36539667+0.j  0.05075766+0.j
  0.00320135+0.j]
---- ClTensor ----

# Fourier Transform function of exp(-X^2)
F_f=λ f:( quadC(exp(-2pi `i ν `X) exp(-X^2),-np.inf, np.inf) ).real
Waring: don't use assignment at last sentence.We ignore the assignment.
===============================
<function <lambda> at 0x0213A070>
not picklable

F_f=λ f:( quadC(exp(-2pi `i f `X) exp(-`X^2),-np.inf, np.inf) ).real;F_f(3)
===============================
1.32810429321e-13

# フーリエ変換された関数の実数値分布のグラフ表示
F_f=λ f:( quadC(exp(-2pi `i f `X) exp(-`X^2),-np.inf, np.inf) ).real; plotGr(F_f,-2,2)
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/quad_c_exp.jpg">

<h3>quadAn </h3>
<p>
quadAn(.)に、quadAn(複素領域を定義域とする関数, [複素数値のリスト]) 被積分関数と直線で結んだ積分経路を与えることで、その積分経路に沿った積分値を計算します。下に例を示します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
quadAn(log, [1,`i,-1,-`i,1])
===============================
((-1.1102230246251565e-16-6.283185307179586j), 3.238303350943406e-09, 3.238303350943406e-09)

quadAn(log, [1,`i,-1,-`i,1])[0] ~== (-2 pi `i)
===============================
True
</span>
</code>
</pre>
<p>
quadAn(..) のときは、予測される積分計算誤差も実数部、虚数部ともに返しています。
<br>
<br>
<a name="kOde:常微分方程式"></a>
<h3>kOde:常微分方程式</h3>
<p>
scipy の integrate パッケージには ode(..) 関数が備わっています。でも時不変な系についても t を明示的に記述せねばならないなど使い方が少しばかり面倒です。ワン･ライナーでは ode(..) を使えません。
<p>
そこで kOde(..) 関数を作りました。大部分の場合で kOde(..) の方が使いやすいでしょう。下のように使います。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.info(kOde)

 kOde(f, x0, t, N=50)

' time independent Runge Kutta integral by scipy.integrate.ode.

kOde(f, x0, t, N=50)
  f:a dynamic equation that may return a vector or list
  x0: a initial codition value that may be a scalar,vector or list
  t: integrating time [0,t]
  N: returning data size

  f doesn't include t term unlike scpy.integrate.ode(..)

  e.g.

  kOde(~[-2 `X `Y, -`X], [1,2], 2s`,10)
  ===============================
  [[  4.63620997e-01   1.86108060e+00]
   [  2.23487176e-01   1.79540724e+00]
   [  1.09764092e-01   1.76345232e+00]
   [  5.44058566e-02   1.74768585e+00]
   [  2.70894588e-02   1.73985328e+00]
   [  1.35187020e-02   1.73594893e+00]
   [  6.75396145e-03   1.73399941e+00]
   [  3.37618618e-03   1.73302515e+00]
   [  1.68817038e-03   1.73253807e+00]
   [  8.44242482e-04   1.73229450e+00]]
  ---- ClTensor ----

        snipped
</span>
</code>
</pre>
<p>
上の式で ~[-2,`X `Y, -`X] は下の常微分方程式を意味します。
<pre>
  d  | x |  == |  -2 x y |  
 ---(|   |)    |         |
  dt | y |     |  -x     | 
</pre>
<p>
 `X, `Y は加減乗除べき乗算が可能な恒等関数であり、~[-2,`X `Y, -`X] はベクトル関数です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
~[-2 `X `Y, -`X](2,3)
===============================
[-12.  -2.]
---- ClTensor ----
</span>
</code>
</pre>
 <p>
 kOde(..) を使えば、二次元での N 体問題を解くワンライナーを次のように記述できます。D=2 が二次元を意味しています。inV=[....] に設定する初期位置・速度パラメータの数より、粒子数 N が決まります。
<p>
getFV(v,i,k) 関数は、位置・速度パラメータ群ベクトル v に対して、 i 番目と k 番目の粒子の間に働く力を求める関数です。(λ r=krry(v[D k:D (k+1)])-krry(v[D i:D (i+1)]):r/norm(r)^3 if norm(r)!=0 else ~[0,0])() は closure 関数の記述と呼び出しです。i 番目と k 番目の粒子の間の距離 r を定める let 文の役割をデフォルト引数機能使って実装しています。λ 式中では assign 文を使えないので、このようなテクニックを使います。
<p>
sumFc(v,j) は、位置・速度パラメータ群ベクトル v に対して、j 番目の粒子に働く力を、 getFV(v,j,k) を足し合わせることで求めています。
<p>
粒子数 N 個によって変わる軌跡の色を設定するために、複素数の位相による色指定法：ClCplxColor() を使っています。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
D=2;inV=[-0.97m`,0.243, 0.97,-0.243, 0,0, 1,1,  -0.466m`/s`,-0.432, -0.466,-0.432, 0.932,0.864, 0,0]; N=len(inV)//(2D) ; getFV=λ v,i,k:(λ r=krry(v[D k:D (k+1)])-krry(v[D i:D (i+1)]):r/norm(r)^3 if norm(r)!=0 else ~[0,0])(); sumFc=λ v,j:sum([getFV(v,j,k) for k in range(N) if j!=k]); fnc= λ *v: np.r_[v[D N:],(~[sumFc(v,j) for j in range(N)]).r]; mt=kOde(fnc,inV, 2 s`,400); cl=ClCplxColor(); for k in range(N):plotTrajectory(mt[:,D k:D (k+1)],color=cl.GetFltColor(exp(`i 2pi k/N)))

</span>
</code>
<br>
<img src="./jpg/1111/one_liner_n_bodey_2d.jpg">
<p>
三次元での N 体問題を解くワンライナーは下の様に書けます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
D=3;inV=[-0.97m`,0.243,0, 0.97,-0.243,0, 0,0,1, 1,1,1,  -0.466m`/s`,-0.432,0, -0.466,-0.432,0, 0.932,0.864,0, 0,0,0]; N=len(inV)//(2D) ; getFV=λ v,i,k:(λ r=krry(v[D k:D (k+1)])-krry(v[D i:D (i+1)]):r/norm(r)^3 if norm(r)!=0 else ~[0,0])(); sumFc=λ v,j:sum([getFV(v,j,k) for k in range(N) if j!=k]); fnc= λ *v: np.r_[v[D N:],(~[sumFc(v,j) for j in range(N)]).r]; mt=kOde(fnc,inV, 2 s`,400); cl=ClCplxColor(); for k in range(N):plotTrajectory(mt[:,D k:D (k+1)],color=cl.GetFltColor(exp(`i 2pi k/N)))

</span>
</code>
<br>
<img src="./jpg/1111/one_liner_n_bodey_3d.jpg">
<br>
<br>
<a name="■■ 行列演算 2"></a>
<h2>■■ 行列演算 2</h2>
<p>
Python Sf における、少し高度な行列演算について説明します。
<h3>~[ リスト内包表記 ] によるベクトル・行列生成</h3>
~[...] による行列生成はリスト内包表記にも使えます。生成される要素が int, float, complex のときは ClTensor インスタンスを、それ以外のときは ClFldTns インスタンスを生成します。ClFldTns により、行列・ベクトル演算要素を環にまで広げられます。下のようなぐあいです。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# ~[ リスト内包表記 ] によるベクトル
~[k^2 for k in range(5)]
===============================
[  0.   1.   4.   9.  16.]
---- ClTensor ----

# ~[ リスト内包表記 ] による行列生成
~[[k j for k in range(5)] for j in range(4)]
===============================
[[  0.   0.   0.   0.   0.]
 [  0.   1.   2.   3.   4.]
 [  0.   2.   4.   6.   8.]
 [  0.   3.   6.   9.  12.]]
---- ClTensor ----

# ~[ リスト内包表記 ] による Zp(5) 要素の行列生成
~[[Z5(k j) for k in range(5)] for j in range(4)]
===============================
[[Z5(0) Z5(0) Z5(0) Z5(0) Z5(0)]
 [Z5(0) Z5(1) Z5(2) Z5(3) Z5(4)]
 [Z5(0) Z5(2) Z5(4) Z5(1) Z5(3)]
 [Z5(0) Z5(3) Z5(1) Z5(4) Z5(2)]]
---- ClFldTns:< class 'sfCrrntIni.Z5'> ----

# ~[ リスト内包表記 ] によって生成された、Zp(5) 要素の行列によるベクトルの変換
~[[Z5(k j) for k in range(5)] for j in range(4)] range(3,3+5)
mt=~[[Z5(k j) for k in range(5)] for j in range(4)]; mt range(3,3+5)
===============================
[Z5(0) Z5(0) Z5(0) Z5(0)]
---- ClFldTns:< class 'sfCrrntIni.Z5'> ----

mt=~[[Z5(k j) for k in range(5)] for j in range(4)]; mt range(2,2+5)
===============================
[Z5(0) Z5(0) Z5(0) Z5(0)]
---- ClFldTns:< class 'sfCrrntIni.Z5'> ----
</span>
</code>
</pre>
<h3>テンソル</h3>
<p>
N x M 行列を越えて、N x M x L などの多次元のテンソルも扱えます。それらとベクトルとの積演算も可能です。次のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
ls=range(3); ~[ [[x+y+z for x in ls] for y in ls] for z in ls]
===============================
[[[ 0.  1.  2.]
  [ 1.  2.  3.]
  [ 2.  3.  4.]]

 [[ 1.  2.  3.]
  [ 2.  3.  4.]
  [ 3.  4.  5.]]

 [[ 2.  3.  4.]
  [ 3.  4.  5.]
  [ 4.  5.  6.]]]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
# 3x3x3Tensor * 3Vector
ls=range(3); tns=~[ [[x+y+z for x in ls] for y in ls] for z in ls]; tns ls
===============================
[[  5.   8.  11.]
 [  8.  11.  14.]
 [ 11.  14.  17.]]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
# 3Vector * 3x3x3Tensor * 3Vector
ls=range(3); tns=~[ [[x+y+z for x in ls] for y in ls] for z in ls]; ls tns ls
===============================
[ 30.  39.  48.]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
# テンソルどうしの積：Γ`__[j,k,i]  Γ`__[i,p,q]
ls=range(3); Γ`__=~[ [[x+y+z for x in ls] for y in ls] for z in ls]; Γ`__ Γ`__
===============================
[[[[  5.   8.  11.]
   [  8.  11.  14.]
   [ 11.  14.  17.]]

  [[  8.  14.  20.]
   [ 14.  20.  26.]
   [ 20.  26.  32.]]

  [[ 11.  20.  29.]
   [ 20.  29.  38.]
   [ 29.  38.  47.]]]


 [[[  8.  14.  20.]
   [ 14.  20.  26.]
   [ 20.  26.  32.]]

  [[ 11.  20.  29.]
   [ 20.  29.  38.]
   [ 29.  38.  47.]]

  [[ 14.  26.  38.]
   [ 26.  38.  50.]
   [ 38.  50.  62.]]]


 [[[ 11.  20.  29.]
   [ 20.  29.  38.]
   [ 29.  38.  47.]]

  [[ 14.  26.  38.]
   [ 26.  38.  50.]
   [ 38.  50.  62.]]

  [[ 17.  32.  47.]
   [ 32.  47.  62.]
   [ 47.  62.  77.]]]]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
# Einstein 既約による縮約：Γ`__[j,k,k]  Γ`__[m,k,k]
ls=range(3); Γ`__=~[ [[x+y+z for x in ls] for y in ls] for z in ls]; ~[ [sum([Γ`__[j,k,k] Γ`__[m,k,k] for k in ls]) for j in ls] for m in ls]
===============================
[[ 20.  26.  32.]
 [ 26.  35.  44.]
 [ 32.  44.  56.]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
テンソル演算は手計算では大変すぎて簡単には扱えませんでした。でも PythonSf を使えば、上のようにテンソル演算も簡単であり実用的に使えます。
<h3>ベクトル・行列同士の ^ 演算子とベクトル外積</h3>
<p>
スカラー値への ^ 演算子の適用はべき乗演算子の意味でしたが、ベクトルや行列の組への ^ 演算子の適用はダイアディック・ベクトル積などのテンソル演算の意味にしています。下のような具合です。
<pre>
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
~[1,2,3]^[4,5,6]
===============================
[[  4.   5.   6.]
 [  8.  10.  12.]
 [ 12.  15.  18.]]
---- ClTensor ----

~[1,2,3]^~[4,5,6]^~[7,8,9]
===============================
[[[  28.   32.   36.]
  [  35.   40.   45.]
  [  42.   48.   54.]]

 [[  56.   64.   72.]
  [  70.   80.   90.]
  [  84.   96.  108.]]

 [[  84.   96.  108.]
  [ 105.  120.  135.]
  [ 126.  144.  162.]]]
---- ClTensor ----

`σx ^ `σz
===============================
[[[[ 0.  0.]
   [ 0. -0.]]

  [[ 1.  0.]
   [ 0. -1.]]]


 [[[ 1.  0.]
   [ 0. -1.]]

  [[ 0.  0.]
   [ 0. -0.]]]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
ベクトルの外積演算は Levi-Civita tensor とベクトルとの積によって計算できます。その他にも複数の方法が使えます。
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# Levi-Civita tensor `εL とベクトルとの積演算による外積
a,b=~[1,2,3],~[4,5,6]; -a `εL b
===============================
[-3.  6. -3.]
---- ClTensor ----

# numpy cross 関数による外積
np.cross([1,2,3],[4,5,6])
===============================
[-3  6 -3]

# ^ 演算子による外積
a,b=~[1,2,3],~[4,5,6]; a^b - b^a
===============================
[[ 0. -3. -6.]
 [ 3.  0. -3.]
 [ 6.  3.  0.]]
---- ClTensor ----

# Wedge 積関数 `Λ(..) による外積
a,b=~[1,2,3],~[4,5,6]; `Λ(a,b)
===============================
[[ 0. -3. -6.]
 [ 3.  0. -3.]
 [ 6.  3.  0.]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
三次元だけで使うときは np.cross(..) が良いのかもしれません。
<p>
私自身は a^b-b^a や `Λ(a,b) による外積演算が優れていると思います。任意の N 次元ベクトルにも使えるからです。計算結果をベクトルではなくテンソルにしておいたほうが、外積の数学的・物理学的な意味が明確になるからです。このときは三次元ベクトルどうしの外積が 3x3 反対称行列になってしまいますが、こちらの方が本来の数学的・物理学的な意味を表しています。
<p>
とくに外積の拡張としての Wedge 積関数:`Λ(..) が微分形式に慣れた方に便利だと思います。任意個数、任意次元のベクトルについて Wedge 積を計算できます。ただし行列を引数としたときまでは実装してありません。誤った計算値になります。御注意ください。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
a,b=[1,2,3,4],[5,6,7,8]; `Λ(a,b)
===============================
[[  0.  -4.  -8. -12.]
 [  4.   0.  -4.  -8.]
 [  8.   4.   0.  -4.]
 [ 12.   8.   4.   0.]]
---- ClTensor ----

a,b,c=[1,2,3,4],[5,6,7,8],[9,10,11,12]; `Λ(a,b,c)
===============================
[[[ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]]

 [[ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]]

 [[ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]]

 [[ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]]]
---- ClTensor ----

# 四次元 Zp(3) ベクトルの外積
a,b=~[1,2,3,4,Z3],~[5,6,7,8,Z3]; `Λ(a,b)
===============================
[[Z3(0) Z3(2) Z3(1) Z3(0)]
 [Z3(1) Z3(0) Z3(2) Z3(1)]
 [Z3(2) Z3(1) Z3(0) Z3(2)]
 [Z3(0) Z3(2) Z3(1) Z3(0)]]
---- ClTensor ----

# 下の Pauli 行列の Wedge 積の計算値は誤りです。行列引数はサポートしていません。
`Λ(`σx,`σz)
===============================
[[[[ 0. -1.]
   [-1.  0.]]

  [[ 1.  0.]
   [ 0. -1.]]]


 [[[ 1.  0.]
   [ 0. -1.]]

  [[ 0.  1.]
   [ 1.  0.]]]]
---- ClTensor ----
</span>
</code>
</pre>

<h3>ベクトル分布関数</h3>
<p>
PythonSf の基本関数は加減乗除べき乗算と関数合成が可能です。このような関数を要素とする ClFldTns ベクトルは __call__(..) method を備えており、ベクトル分布関数として扱えます。そのベクトル分布関数は数値微分できます。grad,div,rot を計算できます。次のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>

# ベクトル分布関数
f=~[`X^2 + `Y^2, `X `Y,`Z `X]; f(1,2,3)
===============================
[ 5.  2.  3.]
---- ClTensor ----

# ベクトル分布関数の数値微分インスタンスの (1,2,3) 位置におけるあたい
f=~[`X^2 + `Y^2, `X `Y,`Z `X]; `div(f)(1,2,3)
===============================
4.0

# 3 変数関数の (1,2,3) における grad 数値微分
`grad(λ x,y,z:x^2+y^2+z^2)(1,2,3)
===============================
[ 2.  4.  6.]

# `div(f) が三変数関数であることは分からないので、dim=3 と明示的に指定する。
# λ x,y,z:... ならば三変数引数だと分かるのですが ~[`X ... `Z] 関数では、引数の数が PythonSf には分かりません。
f=~[`X^2 + `Y^2, `X `Y,`Z `X]; `grad(`div(f),dim=3)(1,2,3)
===============================
[  4.00000000e+00  -1.11022302e-08   0.00000000e+00]
---- ClTensor ----

# rotation
f=~[`X^2 + `Y^2, `X `Y,`Z `X]; `rot(f)(1,2,3)
===============================
[[ 0.  2. -3.]
 [-2.  0.  0.]
 [ 3.  0.  0.]]
---- ClTensor ----

# Jacobian
f=~[`X^2 + `Y^2, `X `Y,`Z `X]; ∂J(f)(1,2,3)
===============================
[[ 2.  4.  0.]
 [ 2.  1.  0.]
 [ 3.  0.  1.]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
rot(..) 関数の結果がベクトルではなく反対称テンソルであることに違和感を抱く方がいるかもしれません。でも敢えて反対称テンソルを返しています。テンソルを返すのならば、二次元や、四次元でも、一般の N 次元でも rot(..) の結果を返せるからです。また反対称テンソルにすることで、rot(..) の数学的・物理的意味が明確になるとも思います。

<!--
# ベクトルの連結
np.r_[~[1,2,3],~[4,5,6,7]]
===============================
[ 1.  2.  3.  4.  5.  6.  7.]
<== universal function ではない。np.ndarray インスタンスになっている
list(~[1,2,3])+list(~[4,5,6,7])
===============================
[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0]
<== こっちは、式の値はリスト・インスタンス
dict(`σx)
===============================
{0.0: 1.0, 1.0: 0.0}
ravel()
`σx.r
===============================
[ 0.  1.  1.  0.]
---- ClTensor ----
Levi-Civita テンソル
    wedge 積:`Λ
grad ∇
rot
`rot(~[`X^2 + `Y^2, `X `Y])(1,2)
`rot(~[`X^2 + `Y^2, `X `Y,`Z `X])(1,2,3)
`rot(~[`X^2 + `Y^2, `X `Y,`Z `X, `i `T])(1,2,3,4)
`rot(~[`X^2 + `Y^2, `X `Y,`Z `X, `i `T `X])(1,2,3,4)
`div(~[`X^2 + `Y^2, `X `Y,`Z `X, `i `T `X])(1,2,3,4)
    反対称テンソル値を返す

テンソル演算
seed(0);tns=randint(10,size=(3,3,3)
<h3>quadGN, quadN, quadVctN </h3>
sinm/cosm
expm
['eigvalsh', 'eigvals', 'eig', 'eigh']

<br>
-->
<a name="■■ 代数系"></a>
<h2>■■ 代数系</h2>
<p>
PythonSf は八元数、整数の剰余体：Zp(N), GF(2^8), 置換群：Sn(N) といった代数系も扱えます。一般体の係数からなる多項式も扱えます。その多項式の加減乗除算、整数べき乗算、剰余算も可能です。また ClFldTns クラスは一般の体や環の行列・ベクトル演算も扱えます。これぐらいあれば学部程度（数学課を除く）の代数には十分だと思います。以下これらを見ていきましょう。
<p>
これらの代数系のソースは全て公開してあります。興味の有る方はそちらも追ってみてください。できたら御自分に必要な代数系に修正・拡張してみてください。全て Python で書かれている小さなプログラムたちですから簡単です。
<h3>整数剰余体：Zp(N)</h3>
<p>
素数 p の剰余体:Zp は、整数を素数:p の剰余演算により range(p-1)：[0,1, ... ,p-1] の整数に mapping したときに得られる体です。体ですから加減乗除算が可能です。<!--PythonSf には octn.py モジュール(oc の global name で import 済みです。) に Zp(.) class factory 関数が実装してあり整数剰余体の演算が可能です。-->素数 5 に対して %p 演算は下のような性質を持ちます。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# 和演算における 3 の逆元
p=5; -3%p
===============================
2

# 整数 0,1, ... , 9 を素数 5 の剰余体に mapping します
p=5; [ x%p for x in range(10)]
===============================
[0, 1, 2, 3, 4, 0, 1, 2, 3, 4]

# 整数 0,1, ... , 9 を素数 5 の剰余体の「和の逆元」に mapping します
p=5; [ (-x)%p for x in range(10)]
===============================
[0, 4, 3, 2, 1, 0, 4, 3, 2, 1]

# 整数 0,1, ... , 9 を素数 5 の剰余体の「積の逆元」に mapping します
p=5; [ (x^(p-2))%p for x in range(10)]
===============================
[0, 1, 3, 2, 4, 0, 1, 3, 2, 4]

# %p が和に対して一貫性があることを確認する
N=10; seed(0); p=5; [ (x%p+y%p)%p==(x+y)%p for x,y in randint(-99,99, size=[N,2])]
===============================
[True, True, True, True, True, True, True, True, True, True]

# %p が積に対して一貫性があることを確認する
N=10; seed(0); p=5; [ ((x%p)*(y%p))%p==(x*y)%p for x,y in randint(-99,99, size=[N,2])]
===============================
[True, True, True, True, True, True, True, True, True, True]
</span>
</code>
</pre>
<p>
標準配布の sfCrnntIni.py には Z2,Z3,Z4,Z5,Z7 の剰余体／環が定義してあります。上の演算を下のように Z5 で書き直せます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# 和演算における 3 の逆元
-Z5(3)
===============================
Z5(2)

# 整数 0,1, ... , 9 を素数 5 の剰余体に mapping します
[ Z5(x) for x in range(10)]
===============================
[0, 1, 2, 3, 4, 0, 1, 2, 3, 4]

# 整数 0,1, ... , 9 を素数 5 の剰余体の「和の逆元」に mapping します
[-Z5(x) for x in range(10)]
===============================
[0, 4, 3, 2, 1, 0, 4, 3, 2, 1]

# 整数 0,1, ... , 9 を素数 5 の剰余体の「積の逆元」に mapping します
p=5; [ Z5(x)^(p-2) for x in range(10)]
===============================
[0, 1, 3, 2, 4, 0, 1, 3, 2, 4]

# %p が和に対して一貫性があることを確認する
N=10; seed(0); [ Z5(x)+Z5(y)==Z5(x+y) for x,y in randint(-99,99, size=[N,2])]
===============================
[True, True, True, True, True, True, True, True, True, True]

# %p が積に対して一貫性があることを確認する
N=10; seed(0); [ Z5(x)*Z5(y)==Z5(x*y) for x,y in randint(-99,99, size=[N,2])]
===============================
[True, True, True, True, True, True, True, True, True, True]
</span>
</code>
</pre>
<p>
Zp(N) は体であり、加減乗除算に関連した多くの代数式が実数のときと同じように成り立ちます。例えば 1/a + 1/b == (a+b)/(a b) の等式が 0 ではない任意の Z5 要素についてなりたちます。下の PythonSf 式で実験確認できます。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
a,b=Z5(2),Z5(3); 1/a + 1/b == (a+b)/(a b)
===============================
True

<b>PythonSf ワンライナー</b>
N=10; seed(0); [ 1/a + 1/b == (a+b)/(a b) for a,b     in ~[randint(1,5, size=[N,2]), Z5] ]
===============================
[True, True, True, True, True, True, True, True, True, True]
</span>
</code>
</pre>
<p>
Zp(N) は可換体であり、行列演算についても実数のときと同様な代数式が多く成り立ちます。下のように 2x2 行列の逆行列の公式が Z5 でも成り立っていることを実験確認できます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
N=1 ; seed(0); [ 1/~[[a,b],[c,d]] == ~[[d,-b],[-c,a]]/(a d - b c) for a,b,c,d in ~[randint(1,5, size=[N,4]), Z5] ]
===============================
[ClTensor([[ True,  True],
       [ True,  True]], dtype=bool)]

<b>PythonSf ワンライナー</b>
N=4 ; seed(0); [ 1/~[[a,b],[c,d]] == ~[[d,-b],[-c,a]]/(a d - b c) for a,b,c,d in ~[randint(1,5, size=[N,4]), Z5] if a d - b c != 0]
===============================
[ClTensor([[ True,  True],
       [ True,  True]], dtype=bool), ClTensor([[ True,  True],
       [ True,  True]], dtype=bool), ClTensor([[ True,  True],
       [ True,  True]], dtype=bool)]
</span>
</code>
</pre>
<p>
Zp(N) は要素が有限なので、虱潰しに全部を調べてやることで、上の関係がなりたつことを証明することも可能です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
vc=~[0,1,2,3,4,Z5]; [ 1/~[[a,b],[c,d]] == ~[[d,-b],[-c,a]]/(a d - b c) for a,b,c,d in mitr(vc,vc,vc,vc) if a d - b c != 0]
===============================
[ClTensor([[ True,  True],

    snip

       [ True,  True]], dtype=bool), ClTensor([[ True,  True],
       [ True,  True]], dtype=bool)]
</span>
</code>
</pre>
<h3>四元数・八元数</h3>
<p>
PythonSf は八元数を扱えます。八元数クラス ClOctonion は octn.py モジュールで定義してあるのですが、標準配布の sfCrrntIni.py ファイルによりグローバル変数 Oc に assign し直してあり、 Oc(...) だけで八元数を生成できます。
<p>
八元数は複素数、四元数を含んでいます。この複素数、四元数は加減乗除算に対して閉じています。ですので、Oc(...) の引数に二つの要素だけを指定したときは複素数のような二要素表記になり、上位の六個の 0 要素は八元数値の表記であってもマスクされます。同様に四つの要素で八元数を生成したときは、四要素表記にしてあります。具体的には次のような生成・演算・表記となります。ですから八元数:Oc クラスといっても、Oc(...) は四元数や複素数も対象にできるクラスです。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# 八元数の生成
Oc(1,2,3,4,5,6,7,8)
===============================
Oc(1, 2, 3, 4, 5, 6, 7, 8)

# 八元数の積と和
Oc(1,2,3,4,5,6,7,8) Oc(9,0,1,2,3,4,5,6), Oc(1,2,3,4,5,6,7,8)+Oc(9,0,1,2,3,4,5,6)
===============================
(Oc(-124, 20, 32, 44, 24, 60, 80, 76), Oc(10, 2, 4, 6, 8, 10, 12, 14))

# 八元数：複素数の生成
Oc(1,2)
===============================
Oc(1, 2)

# 八元数：複素数の積と和と、比較のための複素数の積
Oc(1,2) Oc(3,4), Oc(1,2)+Oc(3,4), (1+2j) (3+4j)
===============================
(Oc(-5, 10), Oc(4, 6), (-5+10j))

# 八元数：四元数の生成
Oc(1,2,3,4)
===============================
Oc(1, 2, 3, 4)

# 八元数：四元数の積と和
Oc(1,2,3,4) Oc(5,6,7,8), Oc(1,2,3,4)+Oc(5,6,7,8)
===============================
(Oc(-60, 12, 30, 24), Oc(6, 8, 10, 12))
</span>
</code>
</pre>
<p>
四元数は体ですが積演算の可換性が保証されなくなります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
a,b=Oc(1,2,3), Oc(4,5,6); a b, b a
===============================
(Oc(-24, 13, 18, -3), Oc(-24, 13, 18, 3))
</span>
</code>
</pre>
<p>
八元数になると結合律が成り立たなくなり、体でさえなくなります。でも逆元は存在しますし、分配率は成り立ちます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# 八元数で結合律が成り立たない例
(Oc(0,1) Oc(0,0,1)) Oc(0,0,0,0,1), Oc(0,1) (Oc(0,0,1) Oc(0,0,0,0,1))
===============================
(Oc(0, 0, 0, 0, 0, 0, 0, 1), Oc(0, 0, 0, 0, 0, 0, 0, -1))

# 八元数でも逆元が存在することの確認実験
N=10; seed(0);[ (Oc(x) Oc(x)^-1) ~== 1 for x in randn(N,8)]
===============================
[True, True, True, True, True, True, True, True, True, True]

# 八元数でも分配率が成り立つことの確認実験
N=10; seed(0);[ (a (b+c)) ~== (a b + a c) for a,b,c in randn(N,3,8)]
===============================
[True, True, True, True, True, True, True, True, True, True]
</span>
</code>
</pre>

<h3>O2,O3,O4,O5,O7: Zp(N) の Cayley/Dickson 構成</h3>
<p>
実数を複素数、四元数、八元数に拡張していく方法は<a href="http://ja.wikipedia.org/wiki/ケーリー＝ディクソンの構成法">「Cayley/Dickson の構成法」</a>と呼ばれます。この構成法の適用により、実数以外の体でも四元数や八元数に似た演算を可能にできます。PythonSf では環・体：Z2,Z3,Z4,Z5,Z7 に Cayley/Dickson の構成法を適用した環代数クラス O2,O3,O4,O5,O7 を標準配布の sfCrrntIni.py に定義してあります。これらのクラスを使った次のような演算が可能です。 
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# Z2 複素数の積
O2(0,1) O2(0,1)
===============================
O2(Z2(1))

# Z3 四元数の積
O3(0,1,2) O3(1,2,3,4)
===============================
O3(1, 0, 1, 2)

# Z5 四元数の積の逆元
O5(1,2,4,4)^-1
===============================
O5(3, 4, 3, 3)

# Z7 八元数の積の逆元
O7(1,2,3,4,5,6,7,8)^-1
===============================
O7(1, 5, 4, 3, 2, 1, 0, 6)

# Z7 八元数の積の逆元が本当に逆元であることを確認する
O7(1,2,3,4,5,6,7,8) O7(1, 5, 4, 3, 2, 1, 0, 6)
===============================
O7(Z7(1))
</span>
</code>
</pre>
<p>
具体的に、O3 四元数の性質を少し詳しく考えて見ましょう。代数学で「有元体は可換体である」すなわち「非可換な有限体は存在しない」ことが解っています。一方で O3 四元数の積には下のように非可換な組み合わせが存在します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# O3 四元数積の非可換な例
a,b=(O3(0, 0, 0, 1), O3(0, 0, 1, 0)); a b, b a
===============================
(O3(0, 2), O3(0, 1))
</span>
</code>
</pre>
<p>
ですから、O3 四元数は体にはなれないはずです。体のどんな性質が壊れてくるのでしょうか。一番壊れやすい箇所は積の逆元の存在でしょう。0 因子が紛れ込んできていると推測されます。実際にも下のように O3 四元数の 0 因子を虱潰し法で列挙させられます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# O3 四元数積の 0 因子全てを列挙する
ls=range(3); lO=[ O3(x) for x in mitr(ls,ls,ls,ls)]; [(x,y) for x,y in mitr(lO,lO) if x!=0 and y!=0 and x y == 0 ]
===============================
[(O3(0, 1, 1, 1), O3(0, 1, 1, 1)), ..... ]
# いっぱいありすぎるので、二番目以降を省略しました
</span>
</code>
</pre>
<p>
八元数となると虱潰し法での全部の組み合わせを調べようとすると時間がかかりすぎるようになります。そのときはランダム・データを使っての数値実験が便利です。例えば O3 八元数には結合律がいっぱいありそうだが、O2 八元数では結合律が成り立たなそうなことが下の PythonSf 式より実験的に解ります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# O3 八元数は ランダムに選んだ三つの値の組に対して結合律が成り立たない。
seed(0); N=1   ; [(x,y,z) for x,y,z in randint(3, size=[N,3,8]) if O3(x) (O3(y) O3(z)) != (O3(x) O3(y)) O3(z)]
===============================
[(ClTensor([0, 1, 0, 1, 1, 2, 0, 2], dtype=int), ClTensor([0, 0, 0, 2, 1, 2, 2, 0], dtype=int), ClTensor([1, 1, 1, 1, 0, 1, 0, 0], dtype=int))]


# O2 八元数は ランダムに選んだ 1000 組の値全てに対して結合律が成り立つ。
seed(0); N=1000; [(x,y,z) for x,y,z in randint(2, size=[N,3,8]) if O2(x) (O2(y) O2(z)) != (O2(x) O2(y)) O2(z)]
===============================
[]
</span>
</code>
</pre>
<p>
その他にも「O2 四元数／八元数の積演算が可換である」など、O2,O3,O4,O5,O7 環代数系には様々の性質があります。ぜひとも御自分の手で操作して色々と遊んでみてください。

<p>
O2,O3,O4,O5,O7 は圏論での具体例の検討に便利です。ベクトル空間からベクトル空間への morphing 関数を、行列よりも簡単に作れます。有限代数系であり、虱潰しによる検証が可能です。その上 O2,O3,O4,O5,O7 代数系は部分的に予測のつく性質を備えているからです。これらの性質を使って圏論での functor や natural transformation といった関数群たちの具体例を容易に作れるからです。
<h3>oc.RS: GF(2^8) 有限体</h3>
<p>
バイト値に対して加減乗除べき乗算を可能にする GF(2^8) 有限体を pysf\octn.py モジュールで RS クラスとして実装してあります。その原始多項式は、CD や DVD での Reed-Solomon Code で使われているものを使っています。下のような具合です。 
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.info(oc.RS)
 RS(inAg)

' GF(2^8) for primitive polynomial:x^8 + x^4 + x^3 + x^2 + 1:0x1d
RS.m_lstPwrStt has power values
e.g;; oc.RS.m_lstPwrStt
[1, 2, 4, 8, 16, 32, 64, 128, 29, 58, ... 173, 71, 142]

oc.RS(0x12) + oc.RS(0x43)
===============================
0x51

oc.RS(0x12) - oc.RS(0x43)
===============================
0x51

oc.RS(24) oc.RS(31)
===============================
0x15

oc.RS(24)/oc.RS(31)
===============================
0xd7

oc.RS(2)^8
===============================
0x1d

oc.RS(2)^-8
===============================
0x83

~[ [1,2],[3,4], oc.RS]^-1
===============================
[[0x02 0x01]
 [0x8f 0x8e]]

oc.RS.m_lstPwrStt.index(24)
===============================
28

oc.RS.m_lstPwrStt.index(31)
===============================
113

hex(oc.RS.m_lstPwrStt[28+113])
===============================
0x15
'


Methods:

  inv  --  ' Return inverse instance '
===============================
None
</span>
</code>
</pre>
<p>
oc.RS インスタンスを要素とする行列やベクトルも、下のように殆ど数値のときと同様に扱えます。Reed-Solomon 符号などを考えるとき oc.RS は便利に使えます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# oc.RS インスタンスを要素とする 2x2 行列
~[ [1,2],[3,4], oc.RS]
===============================
[[0x01 0x02]
 [0x03 0x04]]
---- ClFldTns:< class 'pysf.octn.RS'> ----

# oc.RS インスタンスを要素とする、長さ 2 のベクトル
RS=oc.RS; ~[RS(5), RS(6)]
===============================
[0x05 0x06]
---- ClFldTns:< class 'pysf.octn.RS'> ----

# oc.RS インスタンスでの行列とベクトルの積
RS=oc.RS; mt,vc = ~[RS(5), RS(6)],~[ [1,2],[3,4], RS]; mt vc
===============================
[0x0f 0x12]
---- ClFldTns:< class 'pysf.octn.RS'> ----

# oc.RS インスタンスでの逆行列
~[ [1,2],[3,4], oc.RS]^-1
===============================
[[0x02 0x01]
 [0x8f 0x8e]]
---- ClFldTns:< class 'pysf.octn.RS'> ----

</span>
</code>
</pre>
<h3>`1,`0: oc.BF ブール体</h3>
<p>
Z2 とは独立して、ブール体クラス BF を pysf\ocnt.py モジュールに実装してあります。ブール体を使う頻度は高いので customize.py で `1,`0 に BF(1),BF(0) インスタンスを対応させてあります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
type(`1)
===============================
<class 'pysf.octn.BF'>

np.info(oc.BF)
 BF(inAg)

' Bool Field: data member is 1 or 0
    `1 * `0 = `0   # and
    `1 * `1 = `1
    `0 * `0 = `0

    `1 + `0 = `1   # xor
    `1 + `1 = `0
    `0 + `0 = `0
'


Methods:

  inv  --  ' inverse BF(1) '
===============================
None
</span>
</code>
</pre>
<a name="■■ 多項式"></a>
<h2>■■ 多項式</h2>

<h3>np.poly1d: numpy 整数・実数・複素数係数の多項式</h3>
<p>
高校数学で出てくる整数・実数・複素数係数の多項式は numpy の poly1d クラスで扱うのが便利です。下のような計算ができます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# 多項式インスタンスの生成
p=np.poly1d; p([1,2,3,4])
===============================
   3     2
1 x + 2 x + 3 x + 4

# 多項式インスタンスどうしの割り算
p=np.poly1d; p([1,2,3,4])/p([4,5,6])
===============================
(poly1d([ 0.25  ,  0.1875]), poly1d([ 0.5625,  2.875 ]))

# 一次単項多項式 x の定義と、その演算
p=np.poly1d; x=p([1,0]); (x^3+ 4 x^2 + 5)^2
===============================
   6     5      4      3      2
1 x + 8 x + 16 x + 10 x + 40 x + 25

# 項多項式の微分
p=np.poly1d; x=p([1,0]); (x^3+ 4 x^2 + 5).deriv()
===============================
   2
3 x + 8 x

# 多項式の積分
p=np.poly1d; x=p([1,0]); (x^3+ 4 x^2 + 5).integ()
===============================
      4         3
0.25 x + 1.333 x + 5 x

p=np.poly1d; x=p([1,0]); ((x^3+ 4 x^2 + 5)^2 /(x^2+x+1))
===============================
(poly1d([  1.,   7.,   8.,  -5.,  37.]), poly1d([-32., -12.]))

# 多項式割り算の商
p=np.poly1d; x=p([1,0]); ((x^3+ 4 x^2 + 5)^2 /(x^2+x+1))[0]
===============================
   4     3     2
1 x + 7 x + 8 x - 5 x + 37

# 多項式の根
p=np.poly1d; p([1,2,3,4]).roots
===============================
[-1.65062919+0.j         -0.17468540+1.54686889j -0.17468540-1.54686889j]

# 複素数係数の多項式
p=np.poly1d; p([1,2+5j,3,4])
===============================
   3            2
1 x + (2 + 5j) x + 3 x + 4

# 複素数係数の多項式の根
p=np.poly1d; p([1,2+5j,3,4]).roots
===============================
[-1.73932579-5.4296024j   0.32545721+0.88631641j -0.58613142-0.45671402j]

# 一次単項多項式 x で定義した関数のグラフ
p=np.poly1d; x=p([1,0]); f=(x^3+ 4 x^2 + 5)^2; plotGr(f, -5,2)
</span>
</code>
</pre>
<img src="./jpg/1111/oneliners_float_coef_plnml.jpg">
<a name="general_field_polynomials"></a>
<h3>一般体係数の多項式</h3>
<p>
学部数学になると Zp(N) など様々の可換体の値を係数とする多項式を扱う必要がでてきます。np.poly1d では、そんなのは扱えません。PythonSf では pysf\octn.py モジュールに一般体係数の多項式クラス Pl が定義してあるので、Zp(N) などの可換体係数多項式を扱えます。下のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.info(oc.Pl)
 Pl(*sqAg, **kwDctAg)

' polynomial for algebraic coefficients

usages:
    import octn as oc
    oc.Pl(1,2,3,4)                  # a integer coefficient polynomial
    =============================== # int type is estimated from paramters
    1x^3+2x^2+3x+4

    lst=[1,2,3,4];oc.Pl(lst)        # can use sequence argment too
    ===============================
    1x^3+2x^2+3x+4

    oc.Pl(1,2,3,4, variable='D')    # assign polynomial variable string
    ===============================
    1D^3+2D^2+3D+4

    oc.Pl(1,2,3,4,       oc.BF)     # assgin bool field coefficient
    ===============================
    x^3+x                           # 0 suppressed

    oc.Pl(1,2,3,4, dtype=oc.BF)     # assgin bool field coefficient with dtype key word
    ===============================
    x^3+x                           

    oc.Pl(1,2,3,`1)                 # assign type estimating from argments
    =============================== # ;;type(sum([1,2,3,`1]))   #== oc.BF
    x^3+x+1

    P=oc.Pl; P([1,2,3,4],Z3)
    ===============================
    Z3(1)x^3+Z3(2)x^2+Z3(1)

    P=oc.Pl; P([5,6,7,8],Z3)
    ===============================
    Z3(2)x^3+Z3(1)x+Z3(2)

    P=oc.Pl; P([1,2,3,4],Z3) + P([5,6,7,8],Z3)  # add
    ===============================
    Z3(2)x^2+Z3(1)x

    P=oc.Pl; P([1,2,3,4],Z3) - P([5,6,7,8],Z3)  # subtract
    ===============================
    Z3(2)x^3+Z3(2)x^2+Z3(2)x+Z3(2)

    P=oc.Pl; P([1,2,3,4],Z3) * P([5,6,7,8],Z3)  # multiply
    ===============================
    Z3(2)x^6+Z3(1)x^5+Z3(1)x^4+Z3(1)x^2+Z3(1)x+Z3(2)

    P=oc.Pl; P([1,2,3,4],Z3) / P([5,6,7,8],Z3)  # divide and (quotient,residual)
    ===============================
    (Pl(Z3(2)), Pl(Z3(2)x^2+Z3(1)x))

    P=oc.Pl; P([1,2,3,4],Z3) % P([5,6,7,8],Z3)  # residual
    ===============================
    Z3(2)x^2+Z3(1)x

    P=oc.Pl; P([1,2,3,4],Z3) // P([5,6,7,8],Z3) # quotient
    ===============================
    Z3(2)

    P=oc.Pl; P([1,2,3,4],Z3)^3                  # power
    ===============================
    Z3(1)x^9+Z3(2)x^6+Z3(1)

    P=oc.Pl; P([1,2,3,4],Z3)(P([5,6,7,8],Z3))   # composition
    ===============================
    Z3(2)x^9+Z3(2)x^6+Z3(2)x^4+Z3(2)x^3+Z3(2)x^2+Z3(2)x+Z3(2)
</span>
</code>
</pre>

<h3>ブール代数体とブール体係数多項式</h3>
<p>
CRC 多項式など、ブール体係数の多項式は使う頻度が高いので、 customize.py の中で oc.Pl を継承したブール体専用の多項式クラス PB を定義してあり、それを使って `P ラベルに単項一次式を割り当ててあります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
type(`P)
===============================
<class 'pysf.customize.PB'>

np.source(PB)
In file: pysf\customize.py

class PB(oc.Pl):
    """' BF:Bool Field `P polynomial '"""
    def __init__(self, *sqAg):
        oc.Pl.__init__(self, dtype = oc.BF, variable='`P', *sqAg)

===============================
None
</span>
</code>
</pre>
`P を使うことで、教科書に書いてある多くのブール体系数多項式をエディタ上で計算できるようになります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# ブール体係数多項式における商と余りの計算
(`P^5+1)/(`P+1)
===============================
(Pl(`P^4+`P^3+`P^2+`P+1), Pl(0))

# ブール体係数多項式における商の計算
(`P^5+1)//(`P+1)
===============================
`P^4+`P^3+`P^2+`P+1

# ブール体係数多項式における剰余の計算
(`P^5+1)%(`P^2+1)
===============================
`P+1
</span>
</code>
</pre>
<p>
`P を使えば、`P^3+`P+1 ブール体係数多項式が既約多項式であること、すなわち 1 以外の多項式では割り切れないことを下のように虱潰し証明できます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# `P^3+`P+1 が既約多項式であることの虱潰し証明 
# 二次までのブール体係数多項式全ての内から(0 を除く)、剰余多項式が 0 になるものを列挙する ==> 1 のみ
ls=[`0,`1]; [ x for x in mitr(*[ls]*3) if PB(x) !=0 and (`P^3+`P+1)%PB(x) ==0]
===============================
[(BF(0), BF(0), BF(1))]
</span>
</code>
</pre>

<!--
BF:Bool Field:`1,`0
    `P 多項式
Zp(N)
-->
<a name="■■ 無限長数列と itertools"></a>
<h2>■■ 無限長数列と itertools</h2>
<p>
Python には builtin itertools モジュールがあり無限長シーケンスを扱えます。でも それは無限繰り返し処理のためのモジュールであり、無限長数列のためのモジュールではありません。ですから unsubscriptable であり、数列を扱うのに必須な [..] によるインデックスを使えません。
<p>
でも [..] によるインデックスは __getitem__(..) を実装するだけで使えるようになります。__iter__(..) method を前提とすれば、その実装は簡単です。実際 tn.idx クラスとして実装してあります。その tn.idx を itertools の各関数に適用したものを pysf\tlRcGn.py に実装してあります。pysf.tlRcGn モジュールは tn のラベルに割り当ててあります。これにより次のような PythonSf 式計算が可能になります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.info(tn)
'
extended itertools usages:

tn.count(3)[1:10]
===============================
[4, 5, 6, 7, 8, 9, 10, 11, 12]

(tn.imap(lambda x:x^2, tn.count(10) )[1:10])
===============================
[121, 144, 169, 196, 225, 256, 289, 324, 361]

tn.cycle(xrange(3))[1:10]
===============================
[1, 2, 0, 1, 2, 0, 1, 2, 0]

tn.repeat('s',100)[1:10]
===============================
['s', 's', 's', 's', 's', 's', 's', 's', 's']

tn.repeat(True)[1:10]
===============================
[True, True, True, True, True, True, True, True, True]

tn.repeat(`1)[1:10]
===============================
[BF(1), BF(1), BF(1), BF(1), BF(1), BF(1), BF(1), BF(1), BF(1)]

tn.izip(range(100), xrange(3,100))[1:10]
===============================
[(1, 4), (2, 5), (3, 6), (4, 7), (5, 8), (6, 9), (7, 10), (8, 11), (9, 12)]

tn.izip(range(100), xrange(3,100), tn.count() )[1:10]
===============================
[(1, 4, 1), (2, 5, 2), (3, 6, 3), (4, 7, 4), (5, 8, 5), (6, 9, 6), (7, 10, 7), (8, 11, 8), (9, 12, 9)]

(tn.ifilter(lambda x:x%2==0, tn.count(10) )[1:10])
===============================
[12, 14, 16, 18, 20, 22, 24, 26, 28]

(tn.ifilter(None, tn.count() )[1:10])
===============================
[2, 3, 4, 5, 6, 7, 8, 9, 10]

(tn.ifilterfalse(lambda x:x%2==0, tn.count(10) )[1:10])
===============================
[13, 15, 17, 19, 21, 23, 25, 27, 29]

(tn.ifilterfalse(None, tn.count() )[0])
===============================
0

tn.islice(tn.count(),1,30,3 )[3:10]
===============================
[10, 13, 16, 19, 22, 25, 28]

tn.startmap(lambda *tplAg:sum(tplAg), tn.izip(range(15), range(3,100)) )[1:10]
===============================
[5, 7, 9, 11, 13, 15, 17, 19, 21]
'
===============================
None
</span>
</code>
</pre>
<p>
pi/4 == 1 - 1/2 + 1/5 - 1/7 + ... + (-1)^n 1/(2n+1) ... の公式を使って、少し PythonSf の tn の itertools で遊んでみましょう。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# pi/4 となる無限長数列のインデックス 10 までの数列
ts();  tn.imap(λ n:(-`1r)^n 1/(2n+1), tn.count() )[:10]
===============================
[1, -1/3, 1/5, -1/7, 1/9, -1/11, 1/13, -1/15, 1/17, -1/19]

# 上の無限長数列のインデックス 50 までの和
ts(); sum(tn.imap(λ n:(-`1r)^n 1/(2n+1), tn.count() )[:50])
===============================
850151369116051611488718369170287588082/1089380862964257455695840764614254743075

# pi/4 と、上の無限長数列のインデックス 50 までの和の浮動小数点値
ts(); pi/4, float(sum(tn.imap(λ n:(-`1r)^n 1/(2n+1), tn.count() )[:50]))
===============================
(0.7853981633974483, 0.7803986631477526)

# atan(.) の 1 における厳密値
ts(); ts.atan(1)
===============================
pi/4

#atan の Taylor 展開
ts(); ts.series(ts.atan(`x),`x,n=20)
===============================
x - x**3/3 + x**5/5 - x**7/7 + x**9/9 - x**11/11 + x**13/13 - x**15/15 + x**17/17 - x**19/19 + O(x**20)

</span>
</code>
</pre>
<!--
無限長数列
print tn.count(3)[1:10]
#print (it.imap(lambda x:x^2, fcount(10) )[1:10])
print (tn.imap(lambda x:x^2, tn.count(10) )[1:10])
print tn.cycle(xrange(3))[1:10]
print tn.repeat('s',100)[1:10]
print tn.repeat(True)[1:10]
print tn.repeat(`1)[1:10]
print tn.izip(range(100), xrange(3,100))[1:10]
print tn.izip(range(100), xrange(3,100), tn.count() )[1:10]
print (tn.ifilter(lambda x:x%2==0, tn.count(10) )[1:10])
print (tn.ifilter(None, tn.count() )[1:10])
print (tn.ifilterfalse(lambda x:x%2==0, tn.count(10) )[1:10])
#print (ffilterfalse(None, it.count() )[1:10])  # infinite loop finding 1:9 false
print (tn.ifilterfalse(None, tn.count() )[0])
print tn.islice(tn.count(),1,30,3 )[3:10]
print tn.startmap(lambda *tplAg:sum(tplAg), tn.izip(range(15), range(3,100)) )[1:10]
#print          (lambda *tplAg:sum(tplAg), tn.tee(range(15), 3) )
print "=========================="
print tn.chain(range(3), tn.count(10) )[1:10]
Python には builtin itertools モジュールがあり無限長シーケンスを扱えます。でも unsubscriptable であり、[..] によるインデックスを使えません。__getitem__
    __getitem__ を実装してあり、[..] によるインデックス
    スライスを扱えるようにしてあります

正則連分数への分解ルーチン
    理由もデバッガなりで変化の様子を追跡してみれば解る
//@@
ts()
def f(x,M=10):
    ls=[]
    for _ in range(M):
        inAt = ts.floor(x)
        ls.append(inAt)
        x =  1 /(x-inAt)

    return ls

#print f(ts.pi, 30)
print f(ts.pi, 242)
//@@@
上のルーチンをワン･ライナーで
<== ls[0] に x を入れる
N=100; ts(); x=ts.pi; ls=[x];for _ in range(N):ls.append(ts.floor(ls[0])) or ls.insert(0,1/(ls[0]-ls[-1])) or ls.pop(1); ls[1:]
===============================
[3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2, 2, 2, 1, 84, 2, 1, 1, 15, 3, 13, 1, 4, 2, 6, 6, 99, 1, 2, 2, 6, 3, 5, 1, 1, 6, 8, 1, 7, 1, 2, 3, 7, 1, 2, 1, 1, 12, 1, 1, 1, 3, 1, 1, 8, 1, 1, 2, 1, 6, 1, 1, 5, 2, 2, 3, 1, 2, 4, 4, 16, 1, 161, 45, 1, 22, 1, 2, 2, 1, 4, 1, 2, 24, 1, 2, 1, 3, 1, 2, 1, 1, 10]
ts();ts.exp(1)
ts();ts.floor( ts.E )

N=100; ts(); x=ts.E; ls=[x];for _ in range(N):ls.append(ts.floor(ls[0])) or ls.insert(0,1/(ls[0]-ls[-1])) or ls.pop(1); ls[1:]
===============================
[2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, 1, 1, 10, 1, 1, 12, 1, 1, 14, 1, 1, 16, 1, 1, 18, 1, 1, 20, 1, 1, 22, 1, 1, 24, 1, 1, 26, 1, 1, 28, 1, 1, 30, 1, 1, 32, 1, 1, 34, 1, 1, 36, 1, 1, 38, 1, 1, 40, 1, 1, 42, 1, 1, 44, 1, 1, 46, 1, 1, 48, 1, 1, 50, 1, 1, 52, 1, 1, 54, 1, 1, 56, 1, 1, 58, 1, 1, 60, 1, 1, 62, 1, 1, 64, 1, 1, 66, 1]

N=100; ts(); x=ts.E; ls=[x];for _ in range(N):ls.append(ts.floor(ls[0])) or ls.insert(0,1/(ls[0]-ls[-1])) or ls.pop(1); reduce(λ x,y:`1r/x + y,ls[1:][::-1], `1r)
===============================
13823891428306770374331665289458907890372191037173036666131/5085525453460186301777867529962655859538011626631066055111

exp(1)-13823891428306770374331665289458907890372191037173036666131/5085525453460186301777867529962655859538011626631066055111
===============================
0.0
N=30 ; ts(); x=ts.E^2; ls=[x];for _ in range(N):ls.append(ts.floor(ls[0])) or ls.insert(0,1/(ls[0]-ls[-1])) or ls.pop(1); ls[1:]
===============================
[7, 2, 1, 1, 3, 18, 5, 1, 1, 6, 30, 8, 1, 1, 9, 42, 11, 1, 1, 12, 54, 14, 1, 1, 15, 66, 17, 1, 1, 18]

N=30 ; ts(); x=ts.sqrt(3); ls=[x];for _ in range(N):ls.append(ts.floor(ls[0])) or ls.insert(0,1/(ls[0]-ls[-1])) or ls.pop(1); ls[1:]
===============================
[3**(1/2), oo, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan]
-->
<a name="■■ その他"></a>
<h2>■■ その他</h2>
<p>
Python は開かれた言語です。パッケージやモジュールを import することで、数値計算の他にも多様な処理が可能になります。それらの多くはワンライナーで実行可能です。以下それらの便利な処理を見ていきましょう。
<h3>Python テスト・コードの実行</h3>
<p>
短い Python コードをテスト実行したくなることがよくあります。Python の全てを頭の中に入れるのは無理だからです。皆様は Python で下のように書けるのをご存知でしょうか。これらの動作結果をデバッガなどを立ち上げることなく、思いつくままにエディタ上で確認できてしまいます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# == 演算子の一括比較
a,b,c=1+1,2+0,3-1; a==b==c
===============================
True

# != の一括比較は無理
a,b,c=1+1,2+0,3+1; a!=b!=c
===============================
False

# <= 演算子の一括比較
a,b,c=1  ,2  ,3  ; a<=b<=c
===============================
True

<b>PythonSf ワンライナー</b>
# 整数／実数の hash 値 
x=124; hash(x), hash(124.0),hash(124.1)
===============================
(124, 124, -924195431)

<b>PythonSf ワンライナーたち</b>
# ベクトルのリストのような和 1
np.r_[~[1,2,3],~[4,5,6,7]]
===============================
[ 1.  2.  3.  4.  5.  6.  7.]

# ベクトルのリストのような和 2
np.r_[np.array([1,2,3]), 0, 0, np.array([4,5,6])]
===============================
[1 2 3 0 0 4 5 6]

# ellipsis 演算: ...
arange(3*4).reshape(3,4)[..., :2]
===============================
[[0 1]
 [4 5]
 [8 9]]

<b>PythonSf ワンライナーたち</b>
# 実数に対する %,// 演算
pi%1
===============================
0.14159265359

pi//1
===============================
3.0

# 負の実数に対する %,// 演算
-2.345% 1
===============================
0.655

-2.345//1
===============================
-3.0

# 複素数では、虚数側は元の値のまま
(pi+`i 3.456 )%1
===============================
(0.14159265359+3.456j)

</span>
</code>
</pre>
<h3>カレンダ表示</h3>
<p>
予定を検討するときなどで特定月のカレンダーを見たいことが良くあります。PythonSf があれば、次のワン･ライナーで指定した年月の曜日を打ち出せます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
import calendar as cl; cl.prmonth(2011, 8)
    August 2011
Mo Tu We Th Fr Sa Su
 1  2  3  4  5  6  7
 8  9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28
29 30 31
===============================
None
</span>
</code>
</pre>
<p>
予定表も書き込めるカレンダーを欲しいときは、下のように w,l のキーワード引数に空き幅を指定します。
<pre>
<code>
<span style="color: #9f009f;">
import calendar as cl; cl.prmonth(2011, 8, w=11, l=2)
                                    August 2011

   Monday     Tuesday    Wednesday    Thursday     Friday     Saturday     Sunday

      1           2           3           4           5           6           7

      8           9          10          11          12          13          14

     15          16          17          18          19          20          21

     22          23          24          25          26          27          28

     29          30          31

===============================
None
</span>
</code>
</pre>
<p>
毎月の業務メモのテンペレートの一行目に、このカレンダー・ワンライナーを置いておくのも便利ではないでしょうか。

<h3>zip,tar の解凍</h3>
<p>
python には zipfile, tarfile といったファイルの圧縮・解凍のための package が備わっています。それらを利用すれば、エディタ上でファイルの圧縮・解凍操作が可能です。

<pre>
<code>
<span style="color: #9f009f;">
# 雛形
import tarfile as tr;tr.open('', 'r').extractall()
import tarfile as tr;tr.open('', 'r').list()
import tarfile as tr;tr.open('D:/lng/msysgit/bin/sfepy/gmsh/gmsh-2.5.0-source.tgz', 'r').list()

# 解凍　ワン・ライナーの例
import tarfile as tr;tr.open('D:/lng/msysgit/bin/sfepy/gmsh/gmsh-2.5.0-source.tgz', 'r').extractall()

# 雛形;;ss='';import tarfile as tr;tr.open(ss, 'r').list()
ss='D:/lng/msysgit/bin/sfepy/gmsh/gmsh-2.5.0-source.tgz';import tarfile as tr;tr.open(ss, 'r').list()

</span>
</code>
</pre>

<h3>電源回路の電圧と電流</h3>
<p>
<pre>
Vi         Rs         Vx
───|>|-─MWMW───┬───┐
                      │      │
                    ─┴─    ≧
                    ─┬─ C  ≦Rl
                      │      │
───────────┴───┘
</pre>
<p>
上のようなシリーズ・レギュレータ回路の電流・電圧値を正確に計算した経験のある方は少ないと思います。整流ダイオードのために系が非線形なってしまい、まともに取り扱うのが面倒だからです。でも常微分方程式のソルバー： kOde(..) を使えば、下のように簡単に計算できてしまいます。
<p>
電圧 Vi,Vx と抵抗、コンデンサの間には下のような関係があります。
<pre>
<span style="color: #9f009f;">
<b>関係式</b>
C dVx/dt = (Vi-Vx)/Rs - Vx/Ri  if Vi > Vx
C dVx/dt =            - Vx/Ri  if Vi < Vx
 
 dVx/dt = ((Vi-Vx)/Rs - Vx/Rl)/C  if Vi > Vx
 dVx/dt = (           - Vx/Rl)/C  if Vi < Vx
</span>
</code>
</pre>
これだけ分っていれば、kOde(..) で上の系の挙動をシミュレーション計算できます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
# 出力電圧:Vx<br>
sy(); f0=50Hz`; f=7V` absF(sin(2pi f0 `T)); C,Rs,Rl=1000uF`, 1Ω`,33Ω`;mt=kOde(λ t,Vx:[1,((f(t)-Vx)/Rs-Vx/Rl)/C if f(t)>=Vx else (-Vx/Rl)/C],[0,0],100ms`,256); plotGr(mt[:,1])
</span>
</code>
<br>
<img src="./jpg/1111/oneliner_powe_vx.jpg">
<br>
<br>
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
# 入力電流<br>
sy(); f0=50Hz`; f=7V` absF(sin(2pi f0 `T)); C,Rs,Rl=1000uF`, 1Ω`,33Ω`;mt=kOde(λ t,Vx:[1,((f(t)-Vx)/Rs-Vx/Rl)/C if f(t)>=Vx else (-Vx/Rl)/C],[0,0],100ms`,256); plotGr([(f(t)-Vx)/Rs if f(t)>=Vx else 0 for t,Vx in mt])

</span>
</code>
<br>
<img src="./jpg/1111/oneliners_power_vi.jpg">
<br>
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
# 入力電流:Vi と出力電圧:Vx<br>
sy(); f0=50Hz`; f=7V` absF(sin(2pi f0 `T)); C,Rs,Rl=1000uF`, 1Ω`,33Ω`;mt=kOde(λ t,Vx:[1,((f(t)-Vx)/Rs-Vx/Rl)/C if f(t)>=Vx else (-Vx/Rl)/C],[0,0],100ms`,256); plotGr([(f(t)-Vx)/Rs if f(t)>=Vx else 0 for t,Vx in mt]);plotGr(mt[:,1],color=red)
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_power_vi_vx.jpg">
<p>
縦軸が電圧値と電流値の両方を兼ねています。単位が異なります。物理的には許されません。でも自分だけが見るグラフならば、意味が分っていますから許されるでしょう。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
# 最大突入電流:Vi<br>
sy(); f0=50Hz`; f=7V` absF(cos(2pi f0 `T)); C,Rs,Rl=1000uF`, 1Ω`,33Ω`;mt=kOde(λ t,Vx:[1,((f(t)-Vx)/Rs-Vx/Rl)/C if f(t)>=Vx else (-Vx/Rl)/C],[0,0],100ms`,256); plotGr([(f(t)-Vx)/Rs if f(t)>=Vx else 0 for t,Vx in mt])
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_power_vi_max.jpg">
<p>
最大突入電流を計算するため、入力電圧関数を sin(.) ではなく cos(.) にしました。
<br>
シリコンの 0.6V 分も含めた計算も簡単です。λ式を二重に使い、キーワード引数を O'Caml などの let 文の代わりにしています。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
sy(); f0=50Hz`; f=λ t:(λ v=7V` cos(2pi f0 t):v-0.6V` if v>0.6V` else 0)(); C,Rs,Rl=1000uF`, 1Ω`,33Ω`;mt=kOde(λ t,Vx:[1,((f(t)-Vx)/Rs-Vx/Rl)/C if f(t)>=Vx else (-Vx/Rl)/C],[0,0],100ms`,256); plotGr([(f(t)-Vx)/Rs if f(t)>=Vx else 0 for t,Vx in mt])
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_power_06v.jpg">
<br>


<a name="Laplace 演算子:`s および遅延演算子 z^-1"></a>
<a name="■■ Laplace 演算子:`s および遅延演算子 z^-1"></a>
<h2>■■ Laplace 演算子:`s および遅延演算子 z^-1</h2>
<p>
PythonSf には、ラプラス演算子 s に対応する有理関数クラスの単項式 `s が備わっています。`s は z 変換の単項式としても扱えます。。これを使えばアナログ・フィルタ、デジタル・フィルタの挙動が短い PythonSf ワン･ライナー式で簡単に計算できます。Matlab,Mathematica など他の数学ソフトでは、ここまで簡単には計算できないと思います。以下の one-liners を見てやってください。

<h3>`s を使った LCR 回路の検討</h3>
<p>
    標準配布の PythonSf に備わっている `s を使えば、回路の Laplace 演算子を使った式を扱えます。そのボード線図、インパルス応答、インディシャル応答が簡単に求められます。この `s を使って下の L C R を組み合わせた回路の動作を検討してみましょう。
<pre>
<code>
<span style="color: #9f009f;">
<b>L C R 回路</b>
                      11mH       10Ω
            Vi ──∩∩∩∩ ─WMWM─┐ ──→ Vo
                                    │   
                                  ─┴─ 
                                  ─┬─ 
                                    │1uF
                                    │
                                    Ξ   

</span>
</code>
</pre>
<p>
コイル L は微分要素であり、その Lapalace 演算子表現は L `s です。C は積分要素であり、その Laplace 演算子表現は 1/(C `s) です。ですから L C R 三つを直列につないだときの impedence の Laplace 演算子表現 (L `s + 1/(C `s) + R) となります。
<p>
ですから、上の回路の電圧伝達関数 Vo/Vi は下のように PythonSf 式で計算できます。この伝達関数を何回か再利用するため、ファイル変数 G としてカレント・ディレクトリに残すことも、下の PythonSf 式の G:= ... の式で行わせています。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
L,C,R=1000uH`, 1uF`, 10Ω`; G:=1/(C `s)/(L `s + 1/(C `s) + R)
===============================
        
       1e+09
-------------------
 2
s + 1e+04 s + 1e+09
</span>
</code>
</pre>
<p>
この伝達関数 G が どんなものか Python に備わっている自己ドキュメント機能を使って調べてみましょう。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# G は どんなクラス？ ----- ClRtnl クラス
=:G; type(G)
===============================
&lt;class 'pysf.rational.ClRtnl'&gt;

# ClRtnl はどんなメソッドを備えている？
np.info(ClRtnl)
 ClRtnl(numerAg, denomAg=1, variable='s')

' Ratianal Function class
    The highest coefficient of demoninator is always 1
'


Methods:

  getAnRspns  --  
  getDgRspns  --  
  deriv  --  Return the derivative of this rational funciton.
  plotDgGnPh  --  
  getAnImpls  --  
  plotBode  --  
  getRtnlOfRtnl  --  
  getDgImpls  --  
  plotAnRspns  --  
===============================
None

# G が保持しているデータは？ ---- 分母と分子の多項式
=:G; vars(G)
===============================
{'m_plNumer': poly1d([  1.00000000e+09]), 'm_plDenom': poly1d([  1.00000000e+00,   1.00000000e+04,   1.00000000e+09])}

</span>
</code>
</pre>
<p>
G は plotBode(..) 関数を備えています。この関数で Bode 線図を描きます。名前から Bode 線図を描かせる関数だと分かります。どんな使い方をするのでしょうか調べましょう。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# ClRtnl:plotBode 関数の使い方を調べる
=:G; np.info(G.plotBode)
 plotBode(lowerFreq, higherFreq=None)

'  plot Bode diagram using matplotlib
    Default frequency width is 3 decades
'
===============================
None
</span>
</code>
</pre>
<p>
Bode 線図を描かせるには周波数範囲を指定してやる必要があるようです。伝達関数 G は m_plDenon: poly1d 多項式のインスタンスを備えています。ならば、その根が判れば Bode 線図の周波数範囲も決まります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:G; G.m_plDenom.roots
===============================
[-5000.+31224.98999199j -5000.-31224.98999199j]
</span>
</code>
</pre>
<p>
上の計算結果:分母多項式の根は 3kHz 周波数近辺に共振することを示しています。ならば その二桁下 10Hz から二桁上 100kHz の範囲の周波数でボード線図を描けば良さそうです。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:G; G.plotBode(10Hz`, 100k` Hz`)
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_lcr_bode.jpg">
<br>
<p>
plotAnImpls(..) 関数を使って、上の回路のインパルス応答を見てみましょう。グラフの時間表示範囲は 3kHz より判断して、時間の範囲は 0 -- 2ms としましょう。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:G; plotGr(G.getAnImpls( 2ms`))
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_lcr_impulse.jpg">
<br>
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:G; G.()
</span>
</code>
</pre>
<p>
インパルス応答の次は plotAnRspns(..) メソッドを使ってステップ応答を見てみましょう。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:G; G.plotAnRspns( 2ms`)
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_lcr_inditial.jpg">
<br>
<p>
今度は上の回路に 1kHz 正弦波を入力したときの応答をみてみましょう。
1kHz 正弦波関数は sin(2pi 1k` Hz` `T) と記述できます。(0,2ms) の区間を 256 等分したベクトル・データは klsp(0,2ms`,256) で作れます。これを引数にして sin(2pi 1k` Hz` `T)(klsp(0,2ms`,256) を計算してやれば、ikHz 正弦波の 2ms までの 256 点のベクトル・データが得られます。このデータを上の .getAnRspns(..) の二番目の引数に与えれやれば、上の回路に正弦波入力を与えたときの応答が得られます。 
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:G;G.plotAnRspns(2ms`,sin(2pi 1k` Hz` `T)(klsp(0,2ms`, 256)))
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_lcr_sin_1khz_rspns.jpg">
<br>
<p>
コンデンサ 1uF に充電が完了するまでの時間:初期の 0.5ms までは L C 共振成分が見られますが、それ以後は 1kHz の正弦波になっています。
<p>
ちなみに、矩形波入力を入れたときは次のような応答波形になります
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:G;G.plotAnRspns(2ms`,[(λ t:-1-2np.floor(2 (-0.5+ t 1k` Hz` -int(t 1k` Hz`)) ))(x) for x in klsp(0,2ms`, 256)])
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_lcr_square_wave_1khz_rspns.jpg">
<br>
<p>
上の PythonSf 式で矩形波を作っている λ t:-1-2np.floor(2 (-0.5+ t 1k` Hz` -int(t 1k` Hz`)) ) が少しく技巧的です。こんなのは、すらすらとは出てこないでしょう。矩形波を表す関数を手続き的にプログラムするべきかもしれません。実際には下のような順序で導出しています。こっちは関数プログラミング的な導出方だと思います。こちらの方が数学的思考に集中できます。手続き的なプログラム作成に伴うデバッグが入らないからです。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
plotGr(λ t: t-int(t 1k` Hz`), 0,10ms`)
plotGr(λ t: t 1k` Hz` -int(t 1k` Hz`), 0,10ms`)
plotGr(λ t: np.floor(2 (-0.5+ t 1k` Hz` -int(t 1k` Hz`)) ), 0,10ms`)
plotGr(λ t: np.floor(2 (-0.5+ t 1k` Hz` -int(t 1k` Hz`)) ), 0,2.5ms`)
plotGr([(λ t: np.floor(2 (-0.4+ t 1k` Hz` -int(t 1k` Hz`)) ))(x) for x in klsp(0,2ms`, 256)])
plotGr([(λ t: np.floor(2 (-0.5+ t 1k` Hz` -int(t 1k` Hz`)) ))(x) for x in klsp(0,2ms`, 256)])
plotGr([(λ t: 1+2np.floor(2 (-0.5+ t 1k` Hz` -int(t 1k` Hz`)) ))(x) for x in klsp(0,2ms`, 256)])
plotGr([(λ t:-1-2np.floor(2 (-0.5+ t 1k` Hz` -int(t 1k` Hz`)) ))(x) for x in klsp(0,2ms`, 256)])
</span>
</code>
</pre>

<h3>F 行列と RIAA 回路</h3>
<pre>
<code>
<span style="color: #9f009f;">
<b>RIAA 回路</b>
         R1:82kΩ                R3:1kΩ               
────WMWM───┬──────WMWM────┬────
                  │                        │        
                  ≧                        │        
                  ≦R2:12kΩ                │        
                  │                        │        
                ─┴─                    ─┴─      
                ─┬─ C1:0.027uF         ─┬─ C2:8200pF
                  │                        │        
─────────┴────────────┴────

</span>
</code>
</pre>
ここでは二端子網回路の F 行列を使って、上の RIAA 回路の電圧伝達関数を計算します。
<p>
標準配布 PythonSf の sfCrrntIni.py には、直列接続または並列接続の二端子網回路の F 行列を返す Fs(.) と Fp(.) が実装されています。これを使えば、上の RIAA 回路の R1 直列抵抗や R1 + 1/(C1 `s) 並列要素の F 行列は下のように計算できます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
R1=82kΩ`;  Fs(R1)
===============================
[[ClRtnl([ 1.],[ 1.]), ClRtnl([ 0.],[1])],
       [ClRtnl([-82000.],[ 1.]), ClRtnl([ 1.],[ 1.])]]
---- ClFldTns:< class 'pysf.rational.ClRtnl'> ----

R2,C1=12kΩ`,0.027uF`; Fp(R2+1/(C1 `s))
===============================
[[ClRtnl([ 1.],[ 1.]),
        ClRtnl([ -8.33333333e-05,   0.00000000e+00],[  1.00000000e+00,   3.08641975e+03])],
       [ClRtnl([ 0.],[1]), ClRtnl([ 1.],[ 1.])]]
---- ClFldTns:< class 'pysf.rational.ClRtnl'> ----
</span>
</code>
</pre>
<p>
RIAA 回路の要素ごとに F 行列が求められるのならば、それを掛け合わせてやれば RIAA 回路の F 行列が計算できます。下のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
R1,R2,R3,C1,C2=82kΩ`,12kΩ`,1kΩ`,0.027uF`,8200pF`;  Fp(1/(C2 `s)) Fs(R3) Fp(R2+1/(C1 `s)) Fs(R1)
===============================
[[ ClRtnl([  7.36633333e-04,   9.93395062e+00,   3.08641975e+03],[  1.00000000e+00,   3.08641975e+03]),
        ClRtnl([ -8.88333333e-09,  -1.08641975e-04,   0.00000000e+00],[  1.00000000e+00,   3.08641975e+03])],
       [ ClRtnl([ -8.98333333e+04,  -2.56172840e+08],[  1.00000000e+00,   3.08641975e+03]),
        ClRtnl([  1.08333333e+00,   3.08641975e+03],[  1.00000000e+00,   3.08641975e+03])]]
---- ClFldTns:< class 'pysf.rational.ClRtnl'> ----
</span>
</code>
</pre>
<p>
F 行列が定まれば、その電圧伝達関数は -F[1,0] F[0,1]/F[0,0] + F[1,1] で計算できます。下のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
R1,R2,R3,C1,C2=82kΩ`,12kΩ`,1kΩ`,0.027uF`,8200pF`;F=Fp(1/(C2 `s)) Fs(R3) Fp(R2+1/(C1 `s)) Fs(R1);(-F[1,0] F[0,1]/F[0,0] + F[1,1])
===============================
           3             2
     1358 s + 1.257e+07 s + 3.88e+10 s + 3.991e+13
-------------------------------------------------------
 4             3             2
s + 1.966e+04 s + 9.696e+07 s + 1.543e+11 s + 3.991e+13


R1,R2,R3,C1,C2=82kΩ`,12kΩ`,1kΩ`,0.027uF`,8200pF`;F=Fp(1/(C2 `s)) Fs(R3) Fp(R2+1/(C1 `s)) Fs(R1);(-F[1,0] F[0,1]/F[0,0] + F[1,1]).plotBode(1Hz`,100k` Hz`)
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_riaa_bode.jpg">
<br>
<p>
F 行列以外に Z 行列 Y 行列 などを返す関数を作ってやれば任意トポロジーの伝達関数を計算できるようになると思いますが、そこまでは実装していません。回路のプロのどなたか、この実装をしてみませんか。理屈さえわかっていれば、それらの実装は簡単です。Fs(.), Fp(.) 関数は下のような超が付くほどの簡単な実装で済んでいます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.source(Fs)
In file: sfCrrntIni.py

Fs = lambda Z:sf.krry__(*[[1.0,0.0],[-Z*1.0,1.0], sf.ClRtnl])

===============================
None

<b>PythonSf ワンライナー</b>
np.source(Fp)
In file: sfCrrntIni.py

Fp = lambda Z:sf.krry__(*[[1.0,-1.0/Z],[0.0,1.0], sf.ClRtnl])

===============================
None
</span>
</code>
</pre>

<h3>`s を使った z 変換</h3>
<p>
`s を作っているクラス ClRtnl には、デジタル・フィルタ向けのインパルスも応答関数：getDgImpls(..)、ステップ応答・一般応答関数：getDgRspns(.;)、ゲイン・位相表示関数：plotDgGnPh(..) も備えています。ですから下のような z 変換を使った算計処理が可能です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# FIR インパルス応答
z_=1/`s; (z_^1 + 2z_^2+ 3z_^3).getDgImpls()[:10]
===============================
[ 0.  1.  2.  3.  0.  0.  0.  0.  0.  0.]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
# FIR ステップ応答
z_=1/`s; (z_^1 + 2z_^2+ 3z_^3).getDgRspns()[:10]
===============================
[ 0.  1.  3.  6.  6.  6.  6.  6.  6.  6.]

<b>PythonSf ワンライナー</b>
# IIR ステップ応答
z=`s; ((z +1)/(z^1 + 2z^2+ 3z^3)).getDgImpls()[:10]
===============================
[ 0.          0.          0.33333333  0.11111111 -0.18518519  0.08641975
  0.00411523 -0.03155007  0.01966164 -0.00259107]
---- ClTensor ----

<b>PythonSf ワンライナー</b>
# IIR ゲイン・位相図の描画
z=`s; (z^-1 + 2z^-2+ 3z^-3).plotDgGnPh()
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_dgtl_fltr_gain_phase.jpg">
<br>
<p>
<!--
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
              ┌───┬───┬──────┐  ──→ Vo
              │      │      │            │
            ─┴─    ⊃      ≧ -225Ω     ≧RL
            ─┬─    ⊃      ≦            ≦ 1Ω
              │1uF   ⊃1H    │            │
              │      │      │            │
              └───┼───┘            │
                      │                    │
                    ┌┴┐                  │
                    │Sg│                  │
                    └┬┘                  │
                      │                    │
                      Ξ                    Ξ

<b>PythonSf ワンライナー</b>
L,C,R, RL=1e6uH`, 1uF`, -225Ω`, 1Ω`;Gs=L `s + R + 1/(C `s); (RL/(RL+Gs)).plotAnRspns(100ms`, [1V`,-1V`]+[0V`]*256)

<b>PythonSf ワンライナー</b>
L,C,R, RL=1e6uH`, 1uF`, -225Ω`, 1Ω`;Gs=L `s + R + 1/(C `s); (RL/(RL+Gs)).m_plDenom.roots
===============================
[ 112.+993.70820667j  112.-993.70820667j]

<b>PythonSf ワンライナー</b>
L,C,R, RL=1e6uH`, 1uF`, -225Ω`, 1Ω`;Gs=L `s + R + 1/(C `s); (RL/(RL+Gs)).plotBode(0.01Hz`, 10Hz`)

L,C,R, RL=1e6uH`, 1uF`, -225Ω`, 1Ω`;Gs=L `s + R + 1/(C `s); plotBode(RL/(RL+Gs), 0.01Hz`, 10Hz`)

</span>
</code>
</pre>
impedence 計算
Bode 線図
根軌跡
F 行列
-->

<!--
<h2>Reed Solomon Code</h2>
GF(2^8) 係数多項式のインスタンスも picka le であり、ファイル変数にできる。
RS:GF(2^8)
<== 8bit データに加減乗除べき乗算を適用できる。
α=oc.RS(2); (`X-α^0) (`X-α^1) (`X-α^2) (`X-α^3)
===============================
<pysf.basicFnctns.ClAfOp object at 0x027F4630>
下の多項式で割り切れるようなデータのみにしてある
α,P=oc.RS(2), oc.Pl([1,0], oc.RS); (P-α^0) (P-α^1) (P-α^2) (P-α^3)
===============================
0x01x^4+0x0fx^3+0x36x^2+0x78x+0x40
# random 128 byte data の多項式
seed(0); G=oc.RS;α,P=G(2), oc.Pl([1,0], G); vc:=sum( ~[ g P^k for k,g in enumerate( randint(256, size=128) )])
===============================
0x45x^127+0x31x^126+0x30x^125+0x55x^124+0x75x^123+0x8dx^122+0xcfx^121+0x17x^120+0xbax^119+0xe3x^118+0x94x^117+0x8fx^116+0x4ex^115+0xe8x^114+0xb4x^113+0x64x^112+0xccx^111+0x83x^110+0xf4x^109+0x7fx^108+0x2fx^107+0xc4x^106+0x06x^105+0x44x^104+0xcbx^103+0x54x^102+0xaax^101+0x79x^100+0x8cx^99+0x35x^98+0x63x^97+0x8ex^96+0x80x^95+0x5bx^94+0x52x^93+0xaex^92+0x0bx^91+0x77x^90+0x66x^89+0x23x^88+0x39x^87+0xa9x^86+0xe7x^85+0x41x^84+0x01x^83+0x78x^82+0x1fx^81+0xbax^80+0x2ax^79+0x69x^78+0x84x^77+0x4fx^76+0x11x^75+0xf4x^74+0xe8x^73+0x26x^72+0x85x^71+0x35x^70+0xa4x^69+0x80x^68+0x80x^67+0x22x^66+0x1cx^65+0xb7x^64+0x72x^63+0xcbx^62+0xfex^61+0xa3x^60+0x97x^59+0xf4x^58+0xcax^57+0x1fx^56+0x20x^55+0x7fx^54+0xb9x^53+0x09x^52+0xc1x^51+0x20x^50+0xa7x^49+0x8ex^48+0x93x^47+0x93x^46+0x1dx^45+0xf3x^44+0xb1x^43+0xd8x^42+0x63x^41+0x52x^40+0xc0x^39+0xafx^38+0x4fx^37+0xfex^36+0xc5x^35+0xf3x^34+0xd0x^33+0x73x^32+0x94x^31+0x09x^30+0x48x^29+0x4dx^28+0x19x^27+0xa5x^26+0x51x^25+0x58x^24+0xaex^23+0x57x^22+0x27x^21+0xe6x^20+0xc1x^19+0x3ax^18+0x8cx^17+0x58x^16+0xd8x^15+0x46x^14+0x57x^13+0x24x^12+0xf2x^11+0x15x^10+0xd3x^9+0x09x^8+0x67x^7+0xc3x^6+0xfbx^5+0x43x^4+0xc0x^3+0x75x^2+0x2fx+0xac

copy _dt.pvl vc.pvl /y

# f(α^0) == f(α^1) == f(α^2) == f(α^3) == 0
seed(0); G=oc.RS;α,P=G(2), oc.Pl([1,0], G); =:vc; f=vc P^4 +  0x3dP^3+0x24P^2+0xe9P+0x02; [f(α^k) for k in range(10)]
===============================
[RS(0x00), RS(0x00), RS(0x00), RS(0x00), RS(0x89), RS(0x63), RS(0x5f), RS(0x26), RS(0x57), RS(0x77)]

seed(0); G=oc.RS;α,P=G(2), oc.Pl([1,0], G); =:vc; f=vc P^4 +  0x3dP^3+0x24P^2+0xe9P+0x02; f(α^0) == f(α^1) == f(α^2) == f(α^3) == 0
===============================
True

-->


<a name="■■ 置換群：Sn(N)"></a>
<h2>■■ 置換群：Sn(N)</h2>
<p>
置換群 Sn(N) を実装しました。ただし群論に詳しくない素人の愚直な実装であり、計算時間を短くする対策が入っていません。N が 10 を超えた Sn(N) 置換群全体を iterate 処理させると計算に何時間もかかってしまいます。でも N が 8 ぐらいまでならば Sn(8) 全部を実用的に iterate することもできます。これぐらいまでの処理でも多くの有限群の性質を確認できます。これならば学部での群論の勉強には十分だと考えています。
<p>
標準配布の sfCrrntIni.py には置換群インスタンスのクラス：Sb、巡回置換インスタンスを返す関数 Cy、置換群インスタンスを要素とする frozenset クラス：kfs(..)、群生成関数：grp(..) をグローバル変数として定義し直してあるので、PythonSf 式で直接に使えます。
また標準配布のディレクトリには置換群の集合インスタンス SS2,SS3,SS4,SS5、交代群の集合インスタンス SA3,SA4 のファイル変数を置いてあります。
これぐらい用意されていれば初等的な群論の検討には不便ないでしょう。
<p>
数学ソフトに詳しい方は「GAP を使えよ」と仰ると思います。同意します。複雑な群論の処理、大規模な対象を扱うときは GAP を使うべきです。でも Sn(8) ぐらいまでの小規模な群までならば、vim などから PythonSf 式で扱える Sb, Cy, ksf, grp のほうが便利です。以下の PythonSf 式による群の扱いを見てください。
<h3>Sn(N) 置換群と Sb, Cy, group kfs</h3>
<p>
以下有限置換群 Sn(N) を扱う Sb,Cy,group,kfs といったクラスや関数の詳細を見ていきます。
<h4>Sb 置換クラス</h4>
<p>
Sb(...) は 0 から n までの整数を並べ替えたシーケンスを引数に与えることで置換インスタンスを作ります。この並べ替えたシーケンス引数は、多変数引数として与えます。またリストあるいはタプル引数でも与えられます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# 多変数引数
Sb(1,3,2,0)
===============================
Sb(1,3,2,0)

# リスト引数
x=[1,3,2,0]; Sb(x)
===============================
Sb(1,3,2,0)

# タプル引数
x=(1,3,2,0); Sb(x)
===============================
Sb(1,3,2,0)
</span>
</code>
</pre>
<p>
Sb インスタンスどうしの掛け算と Sb インスタンスへの整数べき乗算が可能です。長さの異なる Sb インスタンスの積も可能です。下のような PythonSf 式として置換インスタンスの計算を扱えます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# Sb インスタンスどうしの積
a,b=Sb(1,3,2,0), Sb(3,0,2,1); a b
===============================
Sb(0,1,2,3)

# Sb インスタンスの 2 乗
Sb(1,3,2,0)^2
===============================
Sb(3,0,2,1)

# Sb インスタンスの -1 乗：逆元
Sb(1,3,2,0)^-1
===============================
Sb(3,0,2,1)

# Sb インスタンスの  2 乗
Sb(1,3,2,0)^-2
===============================
Sb(1,3,2,0)

# Sb インスタンスの  3 乗：単位元に戻る
Sb(1,3,2,0)^3
===============================
Sb(0,1,2,3)

# 異なる長さの Sb インスタンスの積
Sb(1,3,2,0) Sb(1,3,2,0,4)
===============================
Sb(3,0,2,1,4)

# 異なる長さの Sb インスタンスの積 2
Sb(1,3,2,0) Sb(1,4,2,0,3)
===============================
Sb(3,4,2,1,0)

# 巡回群リストの生成
a=Sb(1,3,2,0); [a^k for k in range(4)]
===============================
[Sb(0,1,2,3), Sb(1,3,2,0), Sb(3,0,2,1), Sb(0,1,2,3)]

# 長い Sb インスタンス
seed(0);Sb(shuffle(range(20)))
===============================
Sb(16,9,19,10,2,11,15,13,4,7,0,18,1,17,5,8,3,6,12,14)
</span>
</code>
</pre>
<h4>Cy 巡回置換関数</h4>
<p>
Cy(..) 関数は巡回置換 Sb(..) インスタンスを返します。Sb(..) のときとは違って、必要な整数の組み合わせだけを引数に与えれば済むので、置換群の PythonSf 式の記述が簡単になることが多くあります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
Cy(1,2,3)
===============================
Sb(0,2,3,1)

Cy(1,3)
===============================
Sb(0,3,2,1)

Cy(1,3) Sb(range(10))
===============================
Sb(0,3,2,1,4,5,6,7,8,9)
</span>
</code>
</pre>

<h4>集合クラス：kfs</h4>
<p>
Sb インスタンスを要素とする置換群の集合を扱うとき、その集合は frozenset の方が望ましいことが多くあります。関数で引き渡した先で変更されないことが保証されます。set のときのように copy/deep_copy に注意を払わなくて済むからです。そして置換要素の集合としての群は kfs:frozenset で扱うことに統一しておかないと、== 演算子での判断が面倒になってしまいます。
<p>
でも frozenset のスペルは PythonSf 式の one-liner 記述には長すぎます。そこで frozenset を継承した kfs クラスを設けました。ついでに kfs 集合の union(..) は + 演算子で可能にしました。kfs 集合の meet(..) は * 演算子で可能にしました。

<p>
ついでに frozenset を iterate するとき、その繰り返し順序が判らないと困ることが多いので sortedList:sl プロパティを設けて、sort 済みのリストを返すようにしました。これでデバッグが楽になります。ループ処理ごとに、どのインスタンスをを処理しているのかが判るからです。kfs(..) 集合をプリントするときも sorted 済みの結果で表示します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# Sb インスタンスよりなる kfs 集合の生成
kfs([Sb(0,1), Sb(2,1,0)])
===============================
kfs([Sb(0,1), Sb(2,1,0)])

# 巡回群集合の生成
a=Sb(1,3,2,0); kfs( [a^k for k in range(4)] )
===============================
kfs([Sb(0,1,2,3), Sb(1,3,2,0), Sb(3,0,2,1)])

# 集合の和：union
a=Sb(1,3,2,0); b,c=kfs( [a^k for k in range(4)] ), kfs([Sb(0,1), Sb(2,1,0)]); b+c
===============================
kfs([Sb(0,1), Sb(2,1,0), Sb(0,1,2,3), Sb(1,3,2,0), Sb(3,0,2,1)])

# 集合の積：meet
a=Sb(1,3,2,0); b,c=kfs( [a^k for k in range(4)] ), kfs([Sb(0,1), Sb(3,0,2,1)]); b*c
===============================
kfs([Sb(3,0,2,1)])
</span>
</code>
</pre>
<p>
ただし kfs クラスの要素にできるのは sort 可能なインスタンスに限られます。最後の結果をコンソールに質力するときに sort 作業がなされるからです。ですから整数・実数・複素要素値のベクトルや行列を要素とするkfs 集合は作れません。コンソールに出力するときの sorting でエラーになります。下のような具合です
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
kfs([~[1,2],~[3,4]])
===============================
The truth value of an array with more than one element is ambiguous. Use a.any() or a.all() at excecuting:kfs([krry__(*[1,2]),krry__(*[3,4])])

<b>PythonSf ブロック実行</b>
//@@
a=kfs([~[1,2],~[3,4]])
print a+5
//@@@
Traceback (most recent call last):
  File "__tempConverted.py", line 9, in <module>
    print a+5
  File "D:\my\vc7\mtCm\pysf\ptGrp.py", line 432, in __str__
    return "kfs(" + str(self.sl) + ")"
  File "D:\my\vc7\mtCm\pysf\ptGrp.py", line 357, in __getattr__
    return sorted((self))
ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
</span>
</code>
</pre>

<p>
置換群の集合インスタンス SS2,SS3,SS4,SS5、交代群の集合インスタンス SA3,SA4 のファイル変数を、標準配布のカレント・ディレクトリに置いてあります。 これらは kfs クラスのインスタンスです。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
=:SS3; SS3
===============================
kfs([Sb(0,1,2), Sb(0,2,1), Sb(1,0,2), Sb(1,2,0), Sb(2,0,1), Sb(2,1,0)])

=:SA3; SA3
===============================
kfs([Sb(0,1,2), Sb(1,2,0), Sb(2,0,1)])
</span>
</code>
</pre>
<p>
群論の剰余類・共役類などを扱うのを容易にするため、kfs 集合インスタンスと 置換要素との積を可能にしています。同様な意味で kfs 集合インスタンスと要素との和も可能にしています。もちろん置換群の kfs 集合インスタンスと置換群要素の和演算は無意味でありエラーになります。でも整数集合などでは意味がある分野もあるでしょう。次のような PythonSf 式計算ができます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# 置換集合と置換の積
a=Sb(1,3,2,0); SG=kfs( [a^k for k in range(4)] ); g=Sb(3,2,1,0); SG g 
===============================
kfs([Sb(0,2,3,1), Sb(1,2,0,3), Sb(3,2,1,0)])

# 共役集合の計算 1
a=Sb(1,3,2,0); SG=kfs( [a^k for k in range(4)] ); g=Sb(3,2,1,0); g SG g^-1 
===============================
kfs([Sb(0,1,2,3), Sb(2,1,3,0), Sb(3,1,0,2)])

# 共役集合の計算 2
a=Sb(1,3,2,0); SG=kfs( [a^k for k in range(4)] ); g=Sb(3,2,1,0); g^-1 SG g 
===============================
kfs([Sb(0,1,2,3), Sb(2,1,3,0), Sb(3,1,0,2)])

# 整数集合と整数の積
kfs([1,2,3]) 4
===============================
kfs([4, 8, 12])

# 整数とタプルの集合と整数の積
kfs([1,  (2,3)]) 4
===============================
kfs([4, (2, 3, 2, 3, 2, 3, 2, 3)])

# 整数集合と整数の積
kfs([1,2,3]) + 4
===============================
kfs([5, 6, 7])
</span>
</code>
</pre>
<p>
一つだけ kfs 要素が Sb インスタンスであることを前提としているのが / 演算子です。ksf 集合を、その部分集合で割ることで左剰余類群の集合を返します。この機能は kfs 要素が Sb 以外であると旨く働きません。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:SS3,SA3; SS3/SA3
===============================
kfs([Sb(0,1,2), Sb(0,2,1)])
</span>
</code>
</pre>

<h4>群生成関数：group(..)</h4>
<p>
group(..) 関数の引数に Sb インスタンスのリスト or タプル or セットを与えると、その Sb インスタンスたちによって生成される群の kfs 集合を返します。下のような PythonSf 式が使えます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# group({ Sb(1,0), Cy(range(N)}) による Sn(N) 置換群全体集合の生成
N=3; group({Sb(1,0),Cy(range(N))})
===============================
kfs([Sb(0,1,2), Sb(0,2,1), Sb(1,0,2), Sb(1,2,0), Sb(2,0,1), Sb(2,1,0)])

# group({ Sb(1,0), Cy(range(4)}) による置換群全体集合が Sn(4) であることの確認 
=:SS4; N=4; group({Sb(1,0),Cy(range(N))}) == SS4
===============================
True
</span>
</code>
</pre>
<p>
group(..) 関数は、全ての積の組み合わせで作られる集合を作ります。それにより集合の新たな要素が追加されなくなるまでリカーシブに新たに集合を作り直します。ですから Sn(N):N が 10 以上の長い Sb インスタンスを group(..) に渡してやると、それ返す集合要素数は n! となるかも知れません。そうなると一時間でも計算が終わらなくなるでしょう。ご注意ください。

<h3>交換子群</h3>
<p>
PythonSf 有限群論の最後に交換子群を実際に計算してみます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# SN(3) の交換子積の集合
SS=:SS3; {x y x^-1 y^-1 for x,y in mitr(SS,SS)}
===============================
set([Sb(0,1,2), Sb(1,2,0), Sb(2,0,1)])

# SN(3) の交換子群:交換子積の集合と同じ
SS=:SS3; group([x y x^-1 y^-1 for x,y in mitr(SS,SS)])
===============================
kfs([Sb(0,1,2), Sb(1,2,0), Sb(2,0,1)])

# SN(4) の交換子積の集合
SS=:SS4;   kfs([x y x^-1 y^-1 for x,y in mitr(SS,SS)])
===============================
kfs([Sb(0,1,2,3), Sb(0,2,3,1), Sb(0,3,1,2), Sb(1,0,3,2), Sb(1,2,0,3), Sb(1,3,2,0), Sb(2,0,1,3), Sb(2,1,3,0), Sb(2,3,0,1), Sb(3,0,2,1), Sb(3,1,0,2), Sb(3,2,1,0)])

# SN(4) の交換子群:交換子積の集合と同じ
SS=:SS4; group([x y x^-1 y^-1 for x,y in mitr(SS,SS)])
===============================
kfs([Sb(0,1,2,3), Sb(0,2,3,1), Sb(0,3,1,2), Sb(1,0,3,2), Sb(1,2,0,3), Sb(1,3,2,0), Sb(2,0,1,3), Sb(2,1,3,0), Sb(2,3,0,1), Sb(3,0,2,1), Sb(3,1,0,2), Sb(3,2,1,0)])

# SN(4) の交換子群は交代群：An(4) になる
SS=:SS4; =:SA4; group([x y x^-1 y^-1 for x,y in mitr(SS,SS)]) == SA4
===============================
True

# An(4) の交換子群
SS       =:SA4; group([x y x^-1 y^-1 for x,y in mitr(SS,SS)])
===============================
kfs([Sb(0,1,2,3), Sb(1,0,3,2), Sb(2,3,0,1), Sb(3,2,1,0)])
</span>
</code>
</pre>

<a name="■■ PythonSf を使った遊び"></a>
<h2>■■ PythonSf を使った遊び</h2>
<p>
PythonSf を使うということは、Ramanujan 級の計算能力を得られたということです。この能力を使えば様々の分野で数学を使った遊びが可能になります。以下、その遊びの幾つかを見ていきましょう。

<h3>PythonSf でおっぱい曲面</h3>
<code>
<span style="color: #9f009f;">
<b>元の Maxima の式</b>
<br>
plot3d((1/8)*(6*exp(-(((2/3)*abs(x) - 1)^2 + ((2/3)*y)^2) - (1/3)*((2/3)*y + (1/2))^3) + (2/3)*exp(-%e^11*( (abs((2/3)*x) - 1)^2 + ((2/3)*y)^2)^2) + (2/3)*y - ((2/3)*x)^4),
<br>
http://www.rainbowseeker.jp/xoops/modules/newbb/viewtopic.php?topic_id=369&forum=10&noreadjump=1

<br>
<br>
<b>PythonSf ワンライナー</b>
<br>
x,y,e=`X,`Y,exp(1); plot3dGr((1/8)*(6*exp(-(((2/3)*absF(x) - 1)^2 + ((2/3)*y)^2) - (1/3)*((2/3)*y + (1/2))^3) + (2/3)*exp(-e^11*( (absF((2/3)*x) - 1)^2 + ((2/3)*y)^2)^2) + (2/3)*y - ((2/3)*x)^4),klsp(-3,3,100))
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_oppai.jpg">
<br>
<p>
絶対値関数は Python に備わっている abs(..) 関数ではなく、PythonSf が用意している加減乗除べき乗算と関数合成が可能な absF(..) 関数を使います。
abs(..) 関数は python 文法に組み込まれており、これを呼び出すと引数オブジェクトの __abs__(self) method が呼び出されるからです。
<p>
なお左乳首が赤いのは意識してプログラムしたわけではありません。plot3dGr(..) は最初に出てくる最大値の位置に赤い丸を、最小値の位置に緑の丸を追加するため、左乳首の位置に赤い丸が置かれてしまいました。
<h3>Fermat's Last Theorem</h3>
<p>
<a href="http://ja.wikipedia.org/wiki/フェルマーの最終定理">フェルマーの最終定理</a>:「n>=3 のとき x^n+y^n=z^n を満たす 0 でない自然数の組み合わせは存在しない」という定理は有名です。近年この問題は肯定的に証明されたようですが、素人に解る証明ではないでしょう。
<p>
単純な別証明なんて作れませんが、x^n + y^n よりは小さいが できるだけ近い z^n は存在するはずです。その z^n と x^n+y^n の差分がどんな分布をしているのか見てみましょう。n=3 のとき その分布は下の PythonSf ワン・ライナー式で計算できます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
N,n=16 ,3; ls=range(N); krry([ [(x^n+y^n)-((x^n+y^n+10^-9)^(1/n)//1)^n for x in ls] for y in ls], int)
===============================
[[  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0]
 [  0   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1]
 [  0   1   8   8   8   8   8   8   8   8   8   8   8   8   8   8]
 [  0   1   8  27  27  27  27  27  27  27  27  27  27  27  27  27]
 [  0   1   8  27   3  64  64  64  64  64  64  64  64  64  64  64]
 [  0   1   8  27  64  34 125 125 125 125 125 125 125 125 125 125]
 [  0   1   8  27  64 125  89  47 216 216 216 216 216 216 216 216]
 [  0   1   8  27  64 125  47 174 126  72  12 343 343 343 343 343]
 [  0   1   8  27  64 125 216 126  24 241 181 115  43 512 512 512]
 [  0   1   8  27  64 125 216  72 241 127   1 332 260 182  98   8]
 [  0   1   8  27  64 125 216  12 181   1 272 134 531 453 369 279]
 [  0   1   8  27  64 125 216 343 115 332 134 465 315 153 700 610]
 [  0   1   8  27  64 125 216 343  43 260 531 315  81 550 376 190]
 [  0   1   8  27  64 125 216 343 512 182 453 153 550 298  28 659]
 [  0   1   8  27  64 125 216 343 512  98 369 700 376  28 575 287]
 [  0   1   8  27  64 125 216 343 512   8 279 610 190 659 287 918]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
上の値分布は規則性を感じます。でも その規則を明晰には述べられません。N を 50 にまで広げて、その分布を三次元グラフとして表示してみましょう。
<p>
上の行列数値で感じたものに近い規則性があると思います。皆様は如何でしょうか。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
N,n=50,3; ls=range(N); renderMtrx(krry([ [(x^n+y^n)-((x^n+y^n+10^-9)^(1/n)//1)^n for x in ls] for y in ls], int))
</span>
</code>
</pre>
<img src="./jpg/1111/oneliners_fermas_last_theorem.jpg">
<br>
<h3>random 行列</h3>
<p>
[0,1] 区間上のランダム値を返す rand(..) 関数, 平均値 0 分散 1 の正規分布ランダム値を返す randn(..) 関数、指定された範囲の整数値を返す randint(..) は、行列データも返せるので、手軽に様々な数値実験が可能です。その幾つかを示してみます。直感とは異なることも幾つかあるでしょう。ぜひとも、御自分の手で、様々の別パラメータ値で再実験をしてみてください。
<h4>一次元の酔歩</h4>
<p>
1000 点の正規分布ノイズによる一次元の酔歩:Random Walk を下のように可視化できます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
#一次元の酔歩
N=1000; seed(0); lst=[0]; for v in randn(N):lst.append(lst[-1]+v); plotGr(lst)
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliner_1d_random_walk_normal.jpg">
<p>
上の図は株価変動に似ています。でもランダムなノイズによる Random Walk なのに変化に傾向性があるのが気になります。上の図を株価のグラフとして見せられたら、値下がりのトレンドにあると見なしてしまいます。
<p>
numpy の random 関数に誤りがありトレンドが出やすくなっているのでしょうか。それとも本当にランダムであっても上のグラフ程度のトレンドは簡単に現れるものなのでしょうか。
<p>
分からんときに何かを変えてやると別の視点から見れることが多くあります。1000 点の一様ノイズによる一次元の酔歩:Random Walk を見てみましょう
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
N=1000; seed(0); lst=[0]; for v in rand(N)-0.5:lst.append(lst[-1]+v); plotGr(lst)
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliner_1d_random_walk_uniform.jpg">
<p>
より変動が激しくなりました。これでもトレンドが伺えます。
<p>
もっと自然なランダム・データを使って、トレンドが出てくるかみれば、上のトレンドのようなものがランダムなデータにも出てくるか見えてくるはずです。円周率 1000 桁をランダムなデータとして Random Walk を描かせて見ましょう。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ブロック</b>
//@@
strData=(
"31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679"
+"8214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196"
+"4428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273"
+"7245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094"
+"3305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912"
+"9833673362440656643086021394946395224737190702179860943702770539217176293176752384674818467669405132"
+"0005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235"
+"4201995611212902196086403441815981362977477130996051870721134999999837297804995105973173281609631859"
+"5024459455346908302642522308253344685035261931188171010003137838752886587533208381420617177669147303"
+"5982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989" 
)

lst=[0]
#;; 4.5 == sum(range(10))/10
for ch in strData:lst.append(lst[-1]+int(ch)-4.5); plotGr(lst)
//@@@
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliner_1d_random_walk_circle_ratio.jpg">
<p>
円周率にランダムではないなんらかの傾向性があれば誰かが発表しているはずですが、そんな話は見られません。上の 1000 点の円周率のデータは、自然なランダム・データだと思ってよいでしょう。
<p>
この円周率データによる一次元の酔歩:Random Walk でもトレンドのようなものが見られます。どうも株価でトレンドといっているものにはランダムであることに起因する偶然なものも多くありそうです。
<p>
皆様も seed(.) の引数値を変えるなどしてランダム・データによるトレンドの具合の変化を、自分で体験してみてください。

<h4>二次元／三次元の酔歩</h4>
<p>
二次元、三次元の酔歩も容易に描けます。下のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 二次元の酔歩
N=1000; seed(0); lst=[~[0,0]]; for vc in randn(N,2):lst.append(lst[-1]+vc); plotTrajectory(lst)
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliner_2d_random_walk_normal.jpg">
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 三次元の酔歩
N=1000; seed(0); lst=[~[0,0,0]]; for vc in randn(N,3):lst.append(lst[-1]+vc); plotTrajectory(lst)
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliner_3d_random_walk_normal.jpg">
<p>
こんな図を見ていると、昔顕微鏡下の花粉の動きを生物としての動きと誤解したのも納得できます。

<h3>抵抗値のばらつき</h3>
<p>
民生用の電子機器で使っている抵抗の大多数が、 3σ で 5% の精度のものです。1kΩ の抵抗を 10 個持ってきたら、その抵抗値のばらつきは正規分布に従うはずであり、以下のような具合になるはずです。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
N=10; r,R=0.05, 1kΩ`; seed(0); R (1+ r/3 randn(N))
===============================
[ 1029.40087243  1006.66928681  1016.31229974  1037.34821999  1031.1259665
   983.71203534  1015.83480696   997.47737986   998.2796858   1006.84330837]
---- ClTensor ----
</span>
</code>
</pre>
<p>
ちなみに 5% 以上の誤差になるものは、1000 個の抵抗のうちで 2 個ぐらいです。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
N=1000; r,R=0.05, 1kΩ`; vc=R (1+ r/3 randn(N)); len([ x for x in vc if x&lt;0.95R or 1.05R&lt;x])
===============================
2
</span>
</code>
</pre>
10% 以上の誤差になるものは1000000 個の抵抗持ってきても 0 個です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
N=1000000; r,R=0.05, 1kΩ`; vc=R (1+ r/3 randn(N)); len([ x for x in vc if x&lt;0.9 R or 1.1 R&lt;x])
===============================
0
</span>
</code>
</pre>
<p>
以上の計算より、5% 3σ 精度の抵抗値は、500 個に一個程度 5% を超えるものがある。でも 100 万個の抵抗をもってきても 10% を超える誤差のものは出てこないといえます。
<p>
ちなみに、5% 抵抗を合成してやると、抵抗の誤差同士が打ち消しあって より少ない抵抗値のばらつきになります。
<p>
下の回路の合成抵抗値は並列接続で半分になり直接接続で倍になるので、全体としては　1kΩ　に戻ります。
<pre>
           1kΩ               1kΩ 
       ┌─WMWM─┐      ┌─WMWM─┐
   ──┤        ├───┤        ├─
       │  1kΩ  │      │  1kΩ  │      
       └─MWMW─┘      └─MWMW─┘
</pre>
<p>
この回路の抵抗値 1kΩ のばらつき具合：標準偏差は下のようにシミュレーション計算できます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
N=1000; r,R=0.05, 1kΩ`; seed(0); vc=[ (vc1~+vc2)+(vc3~+vc4) for vc1,vc2,vc3,vc4 in R (1+ r/3 randn(N,4))]; sqrt( sum([ (x-sum(vc)/N)^2 for x in vc ])/(N-1) )<br>
===============================<br>
8.31846294487<br>
</span>
</code>
<p>
元の標準偏差 1kΩ, 5%, 3σ から定まる抵抗値のばらつきぐあい 50/3 の半分程度のばらつきぐあいになりました。

<h3>四次元立方体の三次元への投影図</h3>
<p>
「四次元立方体を三次元に射影する」ことを PythonSf で行います。でも最初からでは難しいので「三次元立方体を二次元に射影する」ことを行ってから、それを四次元に拡張する手順を踏みます。
<p>
PythonSf での one-liners を使って思考の螺旋階段を上っていく様子がよく分かる例だと思います。

<h4>三次元立方体を二次元に射影する</h4>
<p>
三次元立方体の頂点は下の PythonSf 式で表現できます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
# 三次元立方体の頂点<br>
ls=[-1,1]; [ ~[x,y,z] for x,y,z in mitr(ls,ls,ls)]<br>
===============================<br>
[ClTensor([-1., -1., -1.]), ClTensor([-1., -1.,  1.]), ClTensor([-1.,  1., -1.]), ClTensor([-1.,  1.,  1.]), ClTensor([ 1., -1., -1.]), ClTensor([ 1., -1.,  1.]), ClTensor([ 1.,  1., -1.]), ClTensor([ 1.,  1.,  1.])]<br>
</span>
</code>
<p>
下の one-liner の方が、八個の頂点が分かりやすいですね。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 2^3:八個の頂点
ls=[-1,1]; ~[ [x,y,z] for x,y,z in mitr(ls,ls,ls)]
===============================
[[-1. -1. -1.]
 [-1. -1.  1.]
 [-1.  1. -1.]
 [-1.  1.  1.]
 [ 1. -1. -1.]
 [ 1. -1.  1.]
 [ 1.  1. -1.]
 [ 1.  1.  1.]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
座標軸の原点一箇所から放出される光線が立方体の各頂点を通って平面と交わる点を求めることで、立方体を平面に射影できます。そのため Z 軸に垂直な射影される平面を想定します。その Z 軸との交点は 12 の位置にあるものとしましょう。
<p>
原点一箇所から放出される光線が、上で作った立方体の八個の頂点を通って平面に射影されるよう、 その立方体をZ 軸方向に 6 だけ平行移動させます。下の PythonSf 式を使って、カレント・ディレクトリの mt.pvl ファイルに、その頂点の座標値を残します。
。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
ls=[-1,1]; mt:= ~[ ~[x,y,z] for x,y,z in mitr(ls,ls,ls)]+ ~[0,0,6]
===============================
[[-1. -1.  5.]
 [-1. -1.  7.]
 [-1.  1.  5.]
 [-1.  1.  7.]
 [ 1. -1.  5.]
 [ 1. -1.  7.]
 [ 1.  1.  5.]
 [ 1.  1.  7.]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
[0,0,0] 原点から放射された光線が、上で求めた八つの頂点を通って、上で想定した Z 軸に垂直な平面で交わったと想定し、その平面と直線の交点座標を求めましょう。
<p>

「Z 軸に直行し [0,0,12] で交わる平面」と「原点と ~[x,y,z] 点を通った直線」が交わる点の座標を求めます。
<pre>
<code>
(t ~[x,y,z])[2] == 12  for ∃t
t z == 12
∴
t = 12/z    for z ∈ {5,7}

ゆえに平面との交点の座標は下の PythonSf 式で計算できる
12/z ~[x,y,z]
</code>
</pre>

<p>
具体例で再度考えましょう。「Z 軸に直行し [0,0,12] で交わる平面」と「原点と ~[-1,-1,7] 点を通った直線」が交わる点の座標は次の PythonSf 式で求められます。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
12/7 ~[-1,-1,17]
===============================
[ -1.71428571  -1.71428571  29.14285714]
---- ClTensor ----
</span>
</code>
</pre>
<p>
ですから、上で作った立方体の八つの頂点を通る、座標軸の原点から射出されて光線は下の八つの点で平面と交わります。この点は mt2dCube の名前のファイル変数で保存します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:mt; mt2dCube:=~[ v 12/v[2] for v in mt]
===============================
[[ -2.4         -2.4         12.        ]
 [ -1.71428571  -1.71428571  12.        ]
 [ -2.4          2.4         12.        ]
 [ -1.71428571   1.71428571  12.        ]
 [  2.4         -2.4         12.        ]
 [  1.71428571  -1.71428571  12.        ]
 [  2.4          2.4         12.        ]
 [  1.71428571   1.71428571  12.        ]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
ファイル変数 mt, mt2dCube それぞれ八つの座標位置を人間に分かりやすいように、下の PytthonSf 式を使って図示します。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
mt,mt2=:mt,mt2dCube; for v0,v1 in combinate(mt,2):plotTrajectory([v0,v1]); for v0,v1 in combinate(mt2,2):plotTrajectory([v0,v1],color=red);
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_projection_of_cubic2plane.jpg">
<br>
<p>
上の図で赤い部分が立方体の射影図です。

<h4>四次元立方体を三次元に射影する</h4>
<p>
三次元の立方体を平面に射影することと殆ど同様に、四次元立方体を四次元の超平面：三次元空間に射影できます。
<p>
四次元立方体の 2^4:16 個の頂点を、第４の 軸方向に 6 だけ平行移動させたときの頂点の座標をファイル変数 mt に残します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
ls=[-1,1]; mt:= ~[ ~[x,y,z,t] for x,y,z,t in mitr(ls,ls,ls,ls)]+ ~[0,0,0,6]
===============================
[[-1. -1. -1.  5.]
 [-1. -1. -1.  7.]
 [-1. -1.  1.  5.]
 [-1. -1.  1.  7.]
 [-1.  1. -1.  5.]
 [-1.  1. -1.  7.]
 [-1.  1.  1.  5.]
 [-1.  1.  1.  7.]
 [ 1. -1. -1.  5.]
 [ 1. -1. -1.  7.]
 [ 1. -1.  1.  5.]
 [ 1. -1.  1.  7.]
 [ 1.  1. -1.  5.]
 [ 1.  1. -1.  7.]
 [ 1.  1.  1.  5.]
 [ 1.  1.  1.  7.]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
第四の軸に直行し [0,0,0,12] で交わる超平面に、原点と立方体の頂点を通る直線が交わる座標を求め、ファイル変数 mt3dCube に残します。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:mt; mt3dCube:=~[ v 12/v[3] for v in mt]
===============================
[[ -2.4         -2.4         -2.4         12.        ]
 [ -1.71428571  -1.71428571  -1.71428571  12.        ]
 [ -2.4         -2.4          2.4         12.        ]
 [ -1.71428571  -1.71428571   1.71428571  12.        ]
 [ -2.4          2.4         -2.4         12.        ]
 [ -1.71428571   1.71428571  -1.71428571  12.        ]
 [ -2.4          2.4          2.4         12.        ]
 [ -1.71428571   1.71428571   1.71428571  12.        ]
 [  2.4         -2.4         -2.4         12.        ]
 [  1.71428571  -1.71428571  -1.71428571  12.        ]
 [  2.4         -2.4          2.4         12.        ]
 [  1.71428571  -1.71428571   1.71428571  12.        ]
 [  2.4          2.4         -2.4         12.        ]
 [  1.71428571   1.71428571  -1.71428571  12.        ]
 [  2.4          2.4          2.4         12.        ]
 [  1.71428571   1.71428571   1.71428571  12.        ]]
---- ClTensor ----
</span>
</code>
</pre>
<p>
四次元での超平面：すなわち三次元空間に射影された四次元立方体の三次元図を下の PythonSf 式で描きます。

<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
mt=:mt3dCube; [plotTrajectory([v0[:3],v1[:3]])for v0,v1 in combinate(mt,2) if norm(v0-v1)~==4.8  or norm(v0-v1)~==(2*1.71428571)]
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_projection_of_cubic3plane.jpg">
<br>
<p>
五次元立方体を四次元超平面に射影し、その四次元立体をさらに三次元空間に射影したときの頂点の位置も次の PythonSf 式で描けます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
ls=[-1,1]; mt= ~[ v for v in mitr(*[ls]*5)]+ ~[0,0,0,0,6];mt=~[ v 12/v[4] for v in mt][:,:-1]+[0,0,0,6]; mt=~[ v 12/v[3] for v in mt][:,:-1];plotPt(mt); drawAxis()
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_projection_of_cubic5point1.jpg">
<br>
<br>
<img src="./jpg/1111/oneliners_projection_of_cubic5point2.jpg">
<br>
<p>
こんな図形は自分の手で回転させ様々の方向から見てみないと分かりにくいと思います。ぜひ上の one-liner で御自分のコンピュータで動かしマウスで動かしてみてください。
<p>
ここで行った立方体を平面に、四次元立方体を三次元に射影する PythonSf 式たちは、プログラム・コードを書いているのではなく、数式を書き連ねていると言ったほうが近いと思います。プログラム・コード記述の苦しさが殆どありません。面倒なプログラム・デバッグもありません。数学思考に集中できます。途中までの計算結果を見ながら PythonSf 式を書き連らねているだけです。

<a name="■■ 正規表現"></a>
<h2>■■ 正規表現</h2>
<p>
Python の正規表現は使いにくすぎます。Perl でのような正規表現を使いまくるコードを書く気にはなれません。正規表現をコンパイルしてから チェックする文字列に match(...) させ group(..) で取り出すなんて面倒なことをしてられません。そこで kre.py 正規表現改良モジュールを作りました。正規表現にマッチング・インスタンスを「対象文字列 / 正規表現」と割り算演算子で返すようにしました。部分文字列を「%(序数)」mod 演算子で返すようにしました。「対象文字列 / 正規表現%0」で正規表現にマッチした文字列を返すようにしました。
<p>
PythonSf では krgl('正規表現文字列') でコンパイル済みの正規表現インスタンスを作ります。これで対象文字列を割ってやれば、正規表現処理されたマッチング・インスタンスができます。これを %0 でわれば、マッチする文字列が帰ります。次のような具合です。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
'abcdefg'/krgl('[c-e]*')%0
===============================
cde

'abcdefghijkl'/krgl('([c-e]*).*([g-i]+)')%0
===============================
abcdefghi

'abcdefghijkl'/krgl('([c-e]+).*([g-i]+)')%1
===============================
cde

'abcdefghijkl'/krgl('([c-e]*).*([g-i]+)')%2
===============================
i
</span>
</code>
</pre>
<p>
PythonSf 正規表現クラス krgl を使えばワンライナーで実用的なことが様々にできます。次のような具合です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# pysf ディレクリとにあるファイルのうち k で始まるファイル名のものを列挙します
rg,wlk=krgl('^k'),os.walk('./pysf'); `print( [(path,[f for f in files if f/rg%0]) for path,dir,files in wlk] )
[('./pysf',
  ['kcommon.py',
   'kcommon.pyc',
   'kmayavi.py',
   'kmayavi.pyc',
   'kmayaviPy.bak',
   'kNumeric.bak',
   'kNumeric.py',
   'kNumeric.pyc',
   'kNumericPy.bak',
   'kre.py',
   'kre.pyc'])]
===============================
None

# PythonSf の実行時に定まっているグローバル変数の中から plot で始まるものを列挙する
# PythonSf のグローバル変数で不正確に記憶している名称を探すのに便利です
rg=krgl('^plot'); [ s for s in globals().keys() if s/rg%0]
===============================
['plot3dGr', 'plotTmCh', 'plot3d', 'plotPt', 'plotBode', 'plotTrajectory', 'plot2d', 'plot3dRowCol', 'plotGr', 'plotDgGnPh']

# sympy モジュールのグローバル変数全体から fact を含むものを列挙する
# kre.se.I 引数を追加することで大文字／小文字を区別させない
import sympy as md; rg=krgl('fact',kre.se.I); [ s for s in vars(md).keys() if s/rg%0]
===============================
['factorint', 'factorial2', 'cofactors', 'factorial', 'factor_', 'factor', 'factortools', 'FallingFactorial', 'primefactors', 'factor_list', 'RisingFactorial', 'facts']
</span>
</code>
</pre>
<p>
このように kre.py の正規表現クラス krgl 使えば、 Perl でのような正規表現の活用の仕方が可能になります。
<!--
rg=krgl('^m'); [ s for s in globals().keys() if s/rg%0]

rg=krgl('^render'); [ s for s in globals().keys() if s/rg%0]

rp3=λ x:norm(x[:2])^2;mt=kOde(λ *x:[x[2],x[3],-x[0]/rp3(x),-x[1]/rp3(x)], [1,0, 0,1.2], 50s`,1000)[:,:2]; plotTrajectory(zip(mt[:,0],mt[:,1]))
rp3=λ x:norm(x[:2])^3;mt=kOde(λ *x:[x[2],x[3],-x[0]/rp3(x),-x[1]/rp3(x)], [1,0, 0,1.2], 50s`,1000)[:,:2]; plotTrajectory(zip(mt[:,0],mt[:,1]))
<== [-x/r^3, -y/r^3] であり、1/r^2 に比例する引力
rp3=λ x:norm(x[:2])^2.5;mt=kOde(λ *x:[x[2],x[3],-x[0]/rp3(x),-x[1]/rp3(x)], [1,0, 0,1.2], 50s`,1000)[:,:2]; plotTrajectory(zip(mt[:,0],mt[:,1]))
-->`
<a name="■■ PythonSf Octernion と Cayley/Dickson construction"></a>
<h2>■■ PythonSf Octernion と Cayley/Dickson construction</h2>
<p>
PythonSf では Oc(...) を使うことで、四元数、八元数を扱えます。Cayley/Dicson 構成法：八元数操作を Zp(N) 有元体に適用してやることで、非可換または結合率の成り立たない有限代数系が使えるようになります。
<p>
PythonSf には八元数:Octornion:oc.Oc を備えており、非可換な代数での挙動、結合率さえ成り立たない代数での挙動を簡単にコンピュータ上で実行させ試してみることができりす。八元数 oc.Oc だといっても、上側の数値が 0 のときは、それを表示しないので、引数を四つ以下に限定にしてやれば quaternion としての動作になります。引数を二つ以下に限定してやれば複素数の動作になります。

<pre>
<code>
<span style="color: #9f009f;">
Oc(1,2,3,4,5) Oc(5,0,7)
===============================
Oc(-16, -18, 22, 34, 25, 0, -35, 0)

Oc(1,2,3,4) Oc(5,6,7,8)
===============================
Oc(-60, 12, 30, 24)

Oc(1,2    ) Oc(5,6    )
===============================
Oc(-7, 16)
</span>
</code>
</pre>
<p>
この oc.Oc の八元数演算の実装は、愚直に積と和の組み合わせ演算だけでなされています。ですから oc.Oc に 実数以外の体インスタンスを渡してやれば、その一般体の上で、八元数の加減乗除算が実行されてしまいます。すなわち一般体複素数、一般体四元数、一般体八元数の演算が行われるように代数系を拡張できてしまいます。
<p>
体の八元数化による体代数系の拡張は<a href="http://en.wikipedia.org/wiki/Cayley?Dickson_construction">Cayley_Dickson_construction
</a>,<a href="http://ja.wikipedia.org/wiki/ケーリー＝ディクソンの構成法">「ケーリー＝ディクソンの構成法」として知られています。</a>
<p>
ケーリー＝ディクソンの構成法の良いところは拡張された代数系の挙動の予測が付けやすいことです。足し算については、元の体代数系のベクトル足し算になります。積演算については、四元数にしてやることで非可換な代数系が得られます。八元数にしてやることで結合律さえ成り立たない代数系が得られます。
<p>
このケーリー＝ディクソンの構成法を Zp(N) に適用してやれば、簡単に非可換であったり結合律が成り立たない有限な代数系を作れます。そして有限：小規模な代数系ならばコンピュータで虱潰しに調べ上げられるので便利です。といっても、実際にそのようなプログラムを 0 から作り上げるのは普通の人間では月単位の仕事になってしまうでしょう。でも PythonSf ならば八元数の要素を Zp(N) 要素にしてやるだけで、それを実装できしまいます。
<p>
ClOctonion による「ケーリー＝ディクソンの構成法」の適用は、まだ実験的な実装段階です。Compatibility のない仕様変更が将来なされる可能性があります。
<!--
ただし、この代数系の拡張は Python の duck typing の上で動いてしまっている実装になっています。加減乗除べき乗算を Zp(N) 側で行うのか、Octonion 側で行うのかは実装に依存します。八元体のクラス実装がよほど旨くないと、八元数のクラスと一般体のクラスを直行的に組み合わせるようなことは、どこかで問題を起こします。理想を言えば Caley-Dickson 構成法だけをとりだし Monad として実装しておき、任意の Ring と組み合わせられるようにしておくべきです。その Cayley-Dicson Monad には自然数構造を備えなければなりません。自然数との加減乗算とべき乗算を備えなければなりません。そこまでやっても、使いこなせる方が どれぐらいいるのか？ 実際には Zp(N) 側で Octonion に合わせた加減乗除算にしてやらねばなりません。PythonSf の Zp(N) は、そのような Octonion に合わせた実装になっています。それ以外の代数系についても ケーリー＝ディクソンの構成法を適用できるようにするためには注意深い見直しが必要です。Coverage100% のテストぐらいは必須です。まだ その段階にありません。
-->
<h5>O3:Z3 四元数</h5>
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 非可換な例
O3(1,2,3,0) O3(2,1,0,1)
===============================
Oc(0, 2, 1, 1)

O3(2,1,0,1) O3(1,2,3,0)
===============================
Oc(0, 2, 2, 1)

# 非可換な例を虱潰しに挙げる
lst=[0,1,2]; mi=list( mitr(*([lst]*4)) ); [(tpL,tpR) for tpL,tpR in mitr(mi,mi) if O3(tpL) O3(tpR) != O3(tpR) O3(tpL)]
たくさん
# 可換な例を虱潰しに挙げる
lst=[0,1,2]; mi=list( mitr(*([lst]*4)) ); [(tpL,tpR) for tpL,tpR in mitr(mi,mi) if O3(tpL) O3(tpR) == O3(tpR) O3(tpL)]
たくさん

# 積演算の逆元
1/O3(1,0,2,3) 
===============================
(2, 0, 2, 0)
# 逆元が存在しない例
1/O3(1,1,2,3) 
    snipped
ZeroDivisionError: Square value is 0 at ClOctonion:inv().

# ゼロ因子の例
O3(0,1,1,1) O3(2,0,1,2)
===============================
0
# ゼロ因子を虱潰しに挙げる
# λ x: O3(0,1,1,1) x の Kernel
#     積の単位元は含まれていない
ls=range(3); [ tpl for tpl in mitr(*[ls]*4) if O3(0,1,1,1) O3(tpl) == 0]
===============================
[(0, 0, 0, 0), (0, 1, 1, 1), (0, 2, 2, 2), (1, 0, 2, 1), (1, 1, 0, 2), (1, 2, 1, 0), (2, 0, 1, 2), (2, 1, 2, 0), (2, 2, 0, 1)]

# λ x: O3(0,1,1,1) x の Kernel は積演算について閉じている
ls=range(3); lst=[ tpl for tpl in mitr(*[ls]*4) if O3(0,1,1,1) O3(tpl) == 0]; [ O3(x) O3(y) in lst for x,y in mitr(lst,lst)]
===============================
[True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]

# λ x: O3(0,1,1,1) x の Kernel は和演算について閉じている
ls=range(3); lst=[ tpl for tpl in mitr(*[ls]*4) if O3(0,1,1,1) O3(tpl) == 0]; [ O3(x)+O3(y) in lst for x,y in mitr(lst,lst)]
===============================
[True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]

# この小さい環の世界でも非可換性は残っている
ls=range(3); lst=[ tpl for tpl in mitr(*[ls]*4) if O3(0,1,1,1) O3(tpl) == 0]; [ O3(x) O3(y) == O3(y) O3(x)in lst for x,y in mitr(lst,lst)]
===============================
[True, True, True, True, True, True, True, True, True, True, True, True, False, False, False, False, False, False, True, True, True, False, False, False, False, False, False, True, False, False, True, False, False, True, False, False, True, False, False, False, True, False, False, False, True, True, False, False, False, False, True, False, True, False, True, False, False, True, False, False, True, False, False, True, False, False, False, False, True, False, True, False, True, False, False, False, True, False, False, False, True]


</span>
</code>
</pre>

<h5>O3,O5 圏論操作</h5>
<p>
下の fO5toO3 は O5 から O3 への自然変換とみなせる
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
fO5toO3 = fCT(λ x:O3(x.m_tpl), O5, O3); fO5toO3(O5(1,2,3,4)) 
===============================
(1, 2, 0, 1)

fO5toO3 = fCT(λ x:O3(x.m_tpl), O5, O3); fO5toO3.dom, fO5toO3.cod
===============================
((<class 'sfCrrntIni.O5'>,), (<class 'sfCrrntIni.O3'>,))

fO5toO3 = fCT(λ x:O3(x.m_tpl), O5, O3); fO5toO3(O3(1,2,6,4)) 
Traceback (most recent call last):
  File "C:\Python27\lib\runpy.py", line 162, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "C:\Python27\lib\runpy.py", line 72, in _run_code
    exec code in run_globals
  File "D:\my\vc7\mtCm\sfPP.py", line 2, in <module>
    pysf.sfPPrcssr.start()
  File "pysf\sfPPrcssr.py", line 2739, in start
    __execLine( (" ".join(sys.argv[1:])).strip() )
  File "pysf\sfPPrcssr.py", line 2355, in __execLine
    valStt = eval(ustConvertedAt, globals(), locals() )
  File "<string>", line 1, in <module>
  File "sfCrrntIni.py", line 155, in _
    + str(sqAg[k])
  File "sfCrrntIni.py", line 37, in Assert
    raise sf.ClAppError(strAg)
pysf.sfFnctns.ClAppError: Error at CT:__call__(..) input type check:(1, 2, 0, 1)


</span>
</code>
</pre>
<p>
product, sum も非自明な自然変換に使える
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
sum(O3(1,2,3,4))
===============================
1
product(O3(1,2,3,4))
===============================
0

product(O3(1,2,1,4))
===============================
0
<== 八元数での product になっている。下のようにせねばならない。

product(O3(1,2,1,4)[:4])
===============================
2

</span>
</code>
</pre>
<h5>Z3 八元数</h5>
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 結合律が成り立たない整数八元数の例
O=oc.Oc; a,b,c=O(1,2,3,4,5),O(2,1,4,5,6),O(3,4,1,6,7); str((a b) c), str(a (b c))
===============================
('(-426, -279, 12, -323, -366, -4, 52, 12)', '(-426, -279, 12, -323, -366, -12, 44, -28)')

# 結合律が成り立たない Zp(3) 八元数の例
O=oc.Oc; a,b,c=O(~[1,2,3,4,5,Z3]),O(~[2,1,4,5,6,Z3]),O(~[3,4,1,6,7,Z3]); str((a b) c), str(a (b c))
===============================
('(0, 0, 0, 1, 0, 2, 1, 0)', '(0, 0, 0, 1, 0, 0, 2, 2)')
</span>
</code>
</pre>

<a name="■■ Category Theory"></a>
<h2>■■ Category Theory</h2>
<p>
標準配布のカレント・ディレクトリの sfCrrntIni.py ファイルには圏論を扱うための dom, cod を扱えるようにする CT クラス、関数 fCT(..) が実装されています。圏論で頻出する monoid 構造を扱うため：即ち二項関数を扱うための関数 f2CT(..) も設けてあります。また~% user 演算子を関数合成操作に割り当ててあります。さらに Z2,Z3,Z4,Z5,Z5 有限体クラス、 O2,O3,O4,O5,O7 有限八元数クラスを設けてあり、圏論における様々の実例を実際に計算できる PythonSf one-liner 式で表現できます。
<h3>CT: a class defining input parameter types and output parameter types</h3>
<p>
クラス CT は関数の入出力パラメータのタイプを指定するクラスです。Python でも、C や Java 言語での float function(int) のような、関数の型指定を可能にします。CT(int,float) で int 引数の float 出力の関数型指定を行うクラスのインスタンスを作ります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
CT(int, float)
===============================
<sfCrrntIni.CT object at 0x0222EDD0>
</span>
</code>
</pre>
<p>
このインスタンスに対し関数を渡してやると、int 引数を与えて、float 結果を返すことを確認する作業が追加された関数を返します。int を与えて float が返る動作をしているときは、下のように普通の動作をします。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
ct=CT(int, float); f=ct(λ x:x+1.5); f(3)
===============================
4.5
</span>
</code>
</pre>
<p>
でも、入力パラメータまたは出力結果の型が指定と異なるとき、次のように例外が発生します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
ct=CT(int, float); f=ct(λ x:x+1.5); f(3.1)
Traceback (most recent call last):
  File "C:\Python27\lib\runpy.py", line 162, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "C:\Python27\lib\runpy.py", line 72, in _run_code
    exec code in run_globals
  File "D:\my\vc7\mtCm\sfPP.py", line 2, in <module>
    pysf.sfPPrcssr.start()
  File "pysf\sfPPrcssr.py", line 2741, in start
    __execLine( (" ".join(sys.argv[1:])).strip() )
  File "pysf\sfPPrcssr.py", line 2357, in __execLine
    valStt = eval(ustConvertedAt, globals(), locals() )
  File "<string>", line 1, in <module>
  File "sfCrrntIni.py", line 230, in _
    + str(sqAg[k])
  File "sfCrrntIni.py", line 85, in Assert
    raise sf.ClAppError(strAg)
pysf.sfFnctns.ClAppError: Error at CT:__call__(..) input type check:3.1
</span>
</code>
</pre>
<p>
入力引数や戻り値の型は、リストで型を指定することで複数の引数値に対応させます。また型指定には集合や True/False 値を返す関数を使うことも可能です。下のような具合です
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
ct=CT([int, float,{7,8,9},λ x:isinstance(x,complex)], complex); f=ct(λ x,y,z,t:x+y+z+6+1.5j); f(3,4.1, 7, 2j)
===============================
(20.1+1.5j)

ct=CT([int, float,{7,8,9},λ x:isinstance(x,complex)], complex); f=ct(λ x,y,z,t:x+y+z+6+1.5j); f(3,4.1, 5, 2j)
Traceback (most recent call last):
  File "C:\Python27\lib\runpy.py", line 162, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "C:\Python27\lib\runpy.py", line 72, in _run_code
    exec code in run_globals
  File "D:\my\vc7\mtCm\sfPP.py", line 2, in <module>
    pysf.sfPPrcssr.start()
  File "pysf\sfPPrcssr.py", line 2741, in start
    __execLine( (" ".join(sys.argv[1:])).strip() )
  File "pysf\sfPPrcssr.py", line 2357, in __execLine
    valStt = eval(ustConvertedAt, globals(), locals() )
  File "<string>", line 1, in <module>
  File "sfCrrntIni.py", line 230, in _
    + str(sqAg[k])
  File "sfCrrntIni.py", line 85, in Assert
    raise sf.ClAppError(strAg)
pysf.sfFnctns.ClAppError: Error at CT:__call__(..) input type check:5
、その constructor で
</span>
</code>
</pre>
<p>
上の CT クラスによる型指定機能は、圏論の dom/cod を明示するのに役立ちます。でもワン・ライナーで使うには CT クラスのインスタンスを毎度作らねばならず面倒です。なので下のような fCT(...) 関数を設けてあります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.source(fCT)
In file: sfCrrntIni.py

def fCT(f, inputTypeOrSqTypeAg=None, outTypeAg=None):
    ctAt = CT(inputTypeOrSqTypeAg, outTypeAg)
    return ctAt(f)

===============================
None
</span>
</code>
</pre>
<p>
下のように使います。ちなみに type がデフォルトの None で指定されているときは、型チェックを行わないことを意味します。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
f=fCT(λ x:x+1, Z3); f(Z3(2))
===============================
Z3(0)

f=fCT(λ x:x+1.5, int); f(0)
===============================
1.5
</span>
</code>
</pre>
<p>
圏論で頻出する monoid のために二項関数の型指定を行う f2CT(..) も sfCrrntIn.py に実装しています。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
np.source(f2CT)
In file: sfCrrntIni.py

def f2CT(f, ty=None, tyOut=None):
    # comment
    if ty==None and tyOut==None:
        return fCT(f,[None,None],tyOut)
    elif ty!=None and tyOut==None:
        return fCT(f, [ty,ty], ty)
    else:
        # ty!=None and tyOut!=None:
        return fCT(f, [ty,ty], tyOut)

===============================
None
</span>
</code>
</pre>
<p>
下のように使います。ちなみに f2CT(..) のときは、戻り値の型をデフォルト None のままにしておくことは、戻り値の型が入力値の型と同じであることを意味しています。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
f=f2CT(λ x,y:x+y, Z3); f(Z3(1), Z3(2))
===============================
Z3(0)

f=f2CT(λ x,y:x+y, Z3); f.dom, f.cod
===============================
((<class 'sfCrrntIni.Z3'>, <class 'sfCrrntIni.Z3'>), (<class 'sfCrrntIni.Z3'>,))

f=f2CT(λ x,y:x+y+0.5, int, float); f(1, 2)
===============================
3.5

f=f2CT(λ x,y:x+y, int, float); f(1, 2)
Traceback (most recent call last):
  File "C:\Python27\lib\runpy.py", line 162, in _run_module_as_main
    "__main__", fname, loader, pkg_name)
  File "C:\Python27\lib\runpy.py", line 72, in _run_code
    exec code in run_globals
  File "D:\my\vc7\mtCm\sfPP.py", line 2, in <module>
    pysf.sfPPrcssr.start()
  File "pysf\sfPPrcssr.py", line 2741, in start
    __execLine( (" ".join(sys.argv[1:])).strip() )
  File "pysf\sfPPrcssr.py", line 2357, in __execLine
    valStt = eval(ustConvertedAt, globals(), locals() )
  File "<string>", line 1, in <module>
  File "sfCrrntIni.py", line 256, in _
    + str(valAt)
  File "sfCrrntIni.py", line 85, in Assert
    raise sf.ClAppError(strAg)
pysf.sfFnctns.ClAppError: Error at CT:__call__(..) output type check:3
</span>
</code>
</pre>
<p>
CT クラスを使って関数の入出力型を指定できることは、圏論の dom/cod を明示する意味で便利です。でも C/C++/Java でのように、プログラム全体に渡る整合性の確認を行わせる型指定の便利さまでは享受できません。Python では全ての関数で型指定・チェックが行われるわけではないからです。CT に過度に期待すべきではありません。また圏論での PythonSf 式による検討で、型チェックを行わずに済ますことも多くあります。
<p>
圏論の議論では Curry 化関数になっている CT クラスの fst,lst メンバーのほうが、型指定よりも便利に使えるかもしれません。fst は最初の引数の、lst は最後の引数の Curry 化関数です。次のように使います。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
f=f2CT(λ x,y:x+2y, Z3); [f.fst(Z3(1))(Z3(x)) for x in range(5)]
===============================
[1, 0, 2, 1, 0]

f=f2CT(λ x,y:x+2y, Z3); [f.lst(Z3(1))(Z3(x)) for x in range(5)]
===============================
[2, 0, 1, 2, 0]
</span>
</code>
</pre>
<p>
圏論で頻出する関数合成のために sfCrrntIni.py で、ユーザー演算子：~%　に関数合成の機能をアサインしてあります。下のコードで実装されています。
<pre>
<code>
# ~%: user 演算子に関数合成
k__tilda__UsOp_mul____ = lambda x,y:Oc(sf.krry((Oc(x) * Oc(y)).m_tpl, Z5)) # ~*
</code>
</pre>
<!--
CT: class Casting Types

    CT instance.fst
    CT instance.lst

    CT() だと type check 無しで関数を保持するインスタンスになる

    You can use Currying functions without type checks.    
    f=CT()(λ x,y:x+2y).fst(3); f(1),f(2),f(3)
    ===============================
    (5, 7, 9)
    f=CT()(λ x,y:x+2y).lst(3); f(1),f(2),f(3)
    ===============================
    (7, 8, 9)
-->
<h3>cartesian product:直積集合</h3>
<p>
abstract nonsence と揶揄されることもある圏論なんかを、何が嬉しくてやるのかと言えば、集合論が弱すぎるからです。集合論では対象の構造を論じるのに {式(x) for x in ... } しかありません。あとは自然言語で記述していくことになります。
<p>
圏論は集合に結合律を満たす arrow 構造を追加します。これにより対象の構造を視覚化できます。数学の世界では広く出てくる結合律による縛りが、豊富なグラフ構造をもたらします。
<p>
その具体例として McLane の教科書の最初に書いてある直積集合の圏論的な扱いについてみてみましょう。<a href="http://books.google.co.jp/books?id=eBvhyc4z8HQC&printsec=frontcover&hl=ja#v=onepage&q&f=false">ここの</a> 4 ページで読めます。
<h4>集合論での直積集合</h4>
<p>
集合論の範囲で {1,2} と {5,6,7} の直積集合は {(x,y) such that x∈{1,2},y∈{5,6,7} } とでも書くでしょう。PythonSf ならば次のように書けます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 集合 X,Y の直積集合 XxY を PythonSf 式で作る
X,Y={1,2},{5,6,7}; XxY={(x,y) for x,y in mitr(X,Y)}; XxY
===============================
set([(2, 7), (2, 6), (1, 5), (1, 6), (1, 7), (2, 5)])

# XxY を kfs frozenset にしてみる
X,Y={1,2},{5,6,7}; XxY=kfs([(x,y) for x,y in mitr(X,Y)]); XxY
===============================
kfs([(1, 5), (1, 6), (1, 7), (2, 5), (2, 6), (2, 7)])
</span>
</code>
</pre>
<p>
（kfs:frozenset を使うと、その集合の中身が sorting されているので便利です。一方で {... ..} の集合記述も数学での表記に近く、記述も簡素です。以下では両方の集合記述が混在されて使われます。）

<p>
集合論での直積集合は要素ペアが示されるだけです。その働きは自然言語で不明瞭に説明されるだけです。集合論は数学的対象を記述する道具として弱すぎます。下のような、直積集合:XxYから X への自明な写像は明白だからと説明もされないことのほうが多いでしょう。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
X,Y={1,2},{5,6,7}; XxY=kfs([(x,y) for x,y in mitr(X,Y)]); fXxY_X=fCT(λ tpl:tpl[0], XxY, X); fXxY_X((1,5))
===============================
1
</span>
</code>
</pre>
<h4>圏論での直積集合</h4>
<p>
圏論では集合 X と Y の直積集合 XxY は下のグラフで視覚化される、arrow p,q を伴った構造だと定義されます。
<pre>
<code>
    圏論での直積集合 XxY
  {1,2} p         q  {5,6,7}
    X ←─ XxY  ──→ Y
    ↑      ↑        ↑
    │      │∃!h    │
    │      │        │
    └───W ────┘
       f         g
</code>
</pre>
<p>
すなわち「(集合:XxY, arrow:p, arrow:q) が集合 X,Y の直積集合である」とは「任意の集合 W と f:W→X, g:W→Y 関数が与えられたとき、h:W→XxY がユニークに存在し f == h〇p, g== h〇q とできる」ことであるとされます。
<p>
こんな抽象的な言葉だけでは普通の人間では正しく理解できません。PythonSf を使って具体例を作ってみましょう。X,Y={1,2},{5,6,7} 二つの直積集合 XxY を dom とし、X,Y を cod とする p,q arrow 関数を下のように与えることで、圏論的な直積集合の定義の具体例を作れます。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
X,Y={1,2},{5,6,7}; XxY=kfs([(x,y) for x,y in mitr(X,Y)]);p,q=fCT(λ x_y:x_y[0],XxY,X), fCT(λ x_y:x_y[1],XxY,Y)
===============================
(<function _ at 0x02597730>, <function _ at 0x02C073B0>)
</span>
</code>
</pre>
<p>
上の XxY,p,q に対し、下のように W={0,1} 集合と arrow f,g を下のように与えてみます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
X,Y={1,2},{5,6,7}; XxY=kfs([(x,y) for x,y in mitr(X,Y)]);p,q=fCT(λ x_y:x_y[0],XxY,X), fCT(λ x_y:x_y[1],XxY,Y); W={10,11}; f,g=fCT(λ x:1,W,X), fCT(λ x:5+x%2,W,Y)
<br>
===============================
<br>
(&lt;function _ at 0x02C6F430&gt;, &lt;function _ at 0x02C6F3B0&gt;)
<br>
<br>
X,Y={1,2},{5,6,7}; XxY=kfs([(x,y) for x,y in mitr(X,Y)]);p,q=fCT(λ x_y:x_y[0],XxY,X), fCT(λ x_y:x_y[1],XxY,Y); W={10,11}; f,g=fCT(λ x:1,W,X), fCT(λ x:5+x%2,W,Y); [f(x) for x in W]
<br>
===============================
<br>
[1, 1]
<br>
<br>
X,Y={1,2},{5,6,7}; XxY=kfs([(x,y) for x,y in mitr(X,Y)]);p,q=fCT(λ x_y:x_y[0],XxY,X), fCT(λ x_y:x_y[1],XxY,Y); W={10,11}; f,g=fCT(λ x:1,W,X), fCT(λ x:5+x%2,W,Y); [g(x) for x in W]
<br>
===============================
<br>
[5, 6]
</span>
</code>
<br>
<p>
この適当に与えられた W,f,g に対し次のような ∃!h:W→XxY を作れます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
X,Y={1,2},{5,6,7}; XxY=kfs([(x,y) for x,y in mitr(X,Y)]);p,q=fCT(λ x_y:x_y[0],XxY,X), fCT(λ x_y:x_y[1],XxY,Y); W={10,11}; f,g=fCT(λ x:1,W,X), fCT(λ x:5+x%2,W,Y); dh={10:(1,5),11:(1,6)}; h=fCT(λ x:dh[x],W,XxY); [h(x) for x in W]
<br>
===============================
<br>
[(1, 5), (1, 6)]
<br>
<br>
<br>
</span>
</code>
<br>
<p>
このように与えられた h に対し先の直積集合のグラフが成り立つこと：arrow が commute することを次のように確認できます
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b><br>
# f と p〇h が commute する<br>
X,Y={1,2},{5,6,7}; XxY=kfs([(x,y) for x,y in mitr(X,Y)]);p,q=fCT(λ x_y:x_y[0],XxY,X), fCT(λ x_y:x_y[1],XxY,Y); W={10,11}; f,g=fCT(λ x:1,W,X), fCT(λ x:5+x%2,W,Y); dh={10:(1,5),11:(1,6)}; h=fCT(λ x:dh[x],W,XxY); [f(x) == (p~%h)(x) for x in W]
<br>
===============================
<br>
[True, True]
<br>
<br>
# g と q〇h が commute する<br>
X,Y={1,2},{5,6,7}; XxY=kfs([(x,y) for x,y in mitr(X,Y)]);p,q=fCT(λ x_y:x_y[0],XxY,X), fCT(λ x_y:x_y[1],XxY,Y); W={10,11}; f,g=fCT(λ x:1,W,X), fCT(λ x:5+x%2,W,Y); dh={10:(1,5),11:(1,6)}; h=fCT(λ x:dh[x],W,XxY); [g(x) == (q~%h)(x) for x in W]
<br>
===============================
<br>
[True, True]
</span>
</code>
<br>
<p>
この h 関数：arrow が与えられた W,f,g に対してユニークに定まることは虱潰しによる確認で証明できます。でも煩雑になりすぎるので省略します。自明に近いとも思います。

<h4>{0,1,2,3,4,5} を直積集合にする</h4>
<p>
圏論の直積集合の定義ならば、集合 WW:{0,1,2,3,4,5} も X,Y の直積集合にできます。次のような pp,qq を考えて見ましょう。
<pre>
<code>
# 圏論での直積集合 
       {0,1,2,3,4,5,6}
  {1,2} pp       qq {5,6,7}
    X ←─  WW  ──→ Y
    ↑      ↑        ↑
    │      │∃!h    │
    │      │        │
    └───W ────┘
       f         g
</code>
</pre>

<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
# pp:WW→X<br>
X,Y={1,2},{5,6,7}; WW=kfs(range(6));pp,qq=fCT(λ x_y:1 if x_y<3 else 2,WW,X), fCT(λ x_y:5+x_y%3,WW,Y); W={10,11}; [pp(x) for x in WW]
<br>
===============================
<br>
[1, 1, 1, 2, 2, 2]
<br>
<br>

# qq:WW→Y<br>
X,Y={1,2},{5,6,7}; WW=kfs(range(6));pp,qq=fCT(λ x_y:1 if x_y<3 else 2,WW,X), fCT(λ x_y:5+x_y%3,WW,Y); W={10,11}; [qq(x) for x in WW]
<br>
===============================
<br>
[5, 6, 7, 5, 6, 7]
</span>
</code>
<br>
<p>
上のような X,Y,WW,pp,qq に対し、先ほどの f,g に対応する ∃!h を次のように定義しましょう
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
X,Y={1,2},{5,6,7}; WW=kfs(range(6));pp,qq=fCT(λ x_y:1 if x_y<3 else 2,WW,X), fCT(λ x_y:5+x_y%3,WW,Y); W={10,11}; f,g=fCT(λ x:1,W,X), fCT(λ x:5+x%2,W,Y); dh={10:0,11:1}; h=fCT(λ x:dh[x],W,WW); [h(x) for x in W]
<br>
===============================
<br>
[0, 1]
</span>
</code>
<br>
<p>
上の ∃!h  と {0,1,2,3,4,5} に対し、下のように直積構造が成立することを確認できます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>

# f と pp〇h が commute する<br>
X,Y={1,2},{5,6,7}; WW=kfs(range(6));pp,qq=fCT(λ x_y:1 if x_y<3 else 2,WW,X), fCT(λ x_y:5+x_y%3,WW,Y); W={10,11}; f,g=fCT(λ x:1,W,X), fCT(λ x:5+x%2,W,Y); dh={10:0,11:1}; h=fCT(λ x:dh[x],W,WW); [f(x)==(pp~%h)(x) for x in W]
<br>
===============================
<br>
[True, True]
<br>
<br>

# g と qq〇h が commute する<br>
X,Y={1,2},{5,6,7}; WW=kfs(range(6));pp,qq=fCT(λ x_y:1 if x_y<3 else 2,WW,X), fCT(λ x_y:5+x_y%3,WW,Y); W={10,11}; f,g=fCT(λ x:1,W,X), fCT(λ x:5+x%2,W,Y); dh={10:0,11:1}; h=fCT(λ x:dh[x],W,WW); [g(x)==(qq~%h)(x) for x in W]
<br>
===============================
<br>
[True, True]
</span>
</code>
<br>
<p>
圏論の直積集合の定義を導入することで {0,1,2,3,4,5} のような直積集合とは思えない集合も {1,2} と {5,6,7} の直積集合とみなせるようになりました。これにより直積集合に関する多くの性質が {0,1,2,3,4,5} 集合についても成り立ちます。このことは {0,1,2,3,4,5} 集合に直積集合の構造を導入したとも言えます。圏論の威力を示す例だとも思います。皆様はどのように思われるでしょうか。
<h3>cartesian co-product:直和集合</h3>
<pre>
<code>
A──→ A + B ←─→B
│        l[f,g]   │
│        V        │
└──→  B  ←──┘
</code>
</pre>
to be discussed
<h3>functor 構造</h3>
to be discussed

<h3>natural transformation 構造</h3>
to be discussed

<h3>adjunction 構造</h3>
to be discussed

<h3>monad 構造</h3>
to be discussed

<h3>圏論の奨め</h3>
<p>
圏論を使うことで、複数の分野に散在していた抽象概念を、さらなる高みから統一して把握しなおすことが可能になります。これは研究者などの「新たな概念を生み出す」者たちに強力なツールをもたらします。抽象的に頭の中だけでボンヤリと考えていたことがらにグラフを使って可視化された具体的な全体構造を見通せるようになります。
<p>
圏論は大学の研究者に限らす「新たな概念を生み出す」者たち全てが利用できる強力ツールです。例えば PythonSf の基本関数たち（sin, cos や `X 恒等関数など）は「リカーシブに加減乗除算と整数べき乗算が可能」です。この「リカーシブに加減乗除と整数べき乗算が可能」な構造は monad とみなせます。「リカーシブに加減乗除算と整数べき乗算が可能」にしているのは ClAF クラスの実装です。この実装仕様を定めるのに monad 構造を意識しているか否かは全体を見通すと力に決定的な違いをもたらします。
<p>
圏論なんて abstract nonsence だと思われている方もいると思います。でも「新たな概念を生み出す者」であることを望むならば、学んでおくべき新しい道具です。それを学ぶ手間隙以上の強力な道具を手に入れられます。
<!--
Cayley Dickson 構成の Monad は ClAF を変形すれば簡単に実装できそう
関数に dom,cod を設けられます。

adjunction など functor と natural transformation を組み合わせた構造の具体例を容易に作れます。

圏論とは
-->
<a name="■■ オペアンプ・フィルタ回路"></a>
<h2>■■ オペアンプ・フィルタ回路</h2>
PythonSf の Laplace 演算子 `s は Matlab, Mathematica などを大きく超えた計算機能です。それをオペアンプ回路に適用した例を見ていきましょう。オペアンプの伝達関数も含んだ回路系の記述・計算が簡単にできるのを見てください。オペアンプ自体の伝達関数も含めてワンライナーで簡単に特性や応答を計算できます。

<h3>反転増幅回路</h3>
<p>
下の回路の伝達関数を考えます。
<pre>
<code>
                     ┌──┐ 
                 ┌─┤ Zf ├─┐
                 │  └──┘　│
         ┌─┐→│Vm    　    │
    Vi ─┤Zi├─┴─◆-       │
         └─┘Ii    │G ＞──┴─── Vo
                 ┌─◇+
                 │
                 │
                 ≡

</code>
</pre>
<p>
下の関係式がなりたちます。
<pre>
<code>
Vo = -G Vm  ----------- (1)
Vi-Vm = Zi Ii --------- (2)
Vm - Vo = Zf Ii ------- (3)
</code>
</pre>
<p>
Vo/Vi の伝達関数が欲しいので、下の PythonSf 式で symbolic な代数解を計算させます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
ts(); Vi,Vo,Vm, Ii, Zi,Zf, G = ts.symbols('Vi,Vo,Vm, Ii, Zi,Zf, G'); ts.solve([ts.Eq(Vo+G Vm), ts.Eq(Vi-Vm-Zi Ii), ts.Eq(Vm-Vo-Zf Ii)], [Vo,Vm,Ii])
<br>
===============================
<br>
{Vo: G*Vi*Zf/(-G*Zi - Zf - Zi), Ii: Vi*(G + 1)/(G*Zi + Zf + Zi), Vm: Vi*Zf/(G*Zi + Zf + Zi)}
<br>
</span>
</code>
<p>
上の代数解より、Vo と Vi には下の関係式が成り立つことが解ります。
<pre>
<code>
Vo==-G Vi Zf/(G Zi + Zf + Zi)
  ==-  Vi Zf/(  Zi + (Zf + Zi)/G )  --------- (4)

∴
Vo/Vi == -Zf/(Zi + (Zf + Zi)/G )  ----------- (5)

G が無限大のとき
Vo/Vi == -Zf/Zi ----------------------------- (6)
</code>
</pre>
<p>
さて代表的なオペアンプ uA741 の DC ゲインは 25000 倍であり、その GBW は 1MHz です。そのファイル変数 uA741.pvl を下のように作っておきましょう。後で上の G に代入する形で使います。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
f=1 M` Hz`; uA741:=2pi f/(`s + 2pi f/25000)
===============================
 
6.283e+06
---------
s + 251.3

<b>PythonSf ワンライナー</b>
G=:uA741; G.plotBode(0.1Hz`, 10M` Hz`)
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_ua741_bode.jpg">
<p>
下のような回路の特性を検討してみましょう
<pre>
<code>
                                C1:0.001uF
                           ┌──┤├──┐
                           │   R2:10kΩ │
                           ├──MWMW──┤
    Ii     R1:1kΩ C1:0.1uF│            │ 
     ───MWMW──┤├──┴─◆-       │
    Vi                 Vm      │ G＞──┴───
                           ┌─◇+  uA741
                           │ 
                           │ 
                           ≡
</code>
</pre>
<p>
理想オペアンプのとき、(6) 式より、上の回路の周波数特性は次のようになります。(下の式で ~+ 演算子は並列接続での足し算を計算させています)
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
R1,R2,C1,C2=1kΩ`,10kΩ`,0.1uF`,0.001uF`; Zi,Zf = R1+1/(C1 `s), R2~+(1/(C2 `s)); (-Zf/Zi ).plotBode(10 Hz`, 10 M` Hz`)
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_ideal_bandpass_bode.jpg">
<br>
<p>
uA741 オペアンプのとき、(5)式より上の回路の周波数特性は次のようになります。ゲイン特性が 1MHz 近辺で異なります。位相特性は、100kHz ぐらいから違ってきています。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
G=:uA741; R1,R2,C1,C2=1kΩ`,10kΩ`,0.1uF`,0.001uF`; Zi,Zf = R1+1/(C1 `s), R2~+(1/(C2 `s)); ( -Zf/(Zi + (Zf + Zi)/G ) ).plotBode(10 Hz`, 10 M` Hz`)
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_ua741_bandpass_bode.jpg">
<br>
<br>
理想オペアンプと uA741 でのステップ応答の違いを見てみましょう
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
G=:uA741; R1,R2,C1,C2=1kΩ`,10kΩ`,0.1uF`,0.001uF`; Zi,Zf = R1+1/(C1 `s), R2~+(1/(C2 `s)); ( -Zf/Zi ).plotAnRspns(0.3ms`); ( -Zf/(Zi + (Zf + Zi)/G ) ).plotAnRspns(0.3ms`, color=red)
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_ideal_ua741_step.jpg">
<br>
<p>
赤い線のほうが uA741 側です。当然ながら uA741 のステップ応答のほうが少し鈍ります。でも多くの場合で許されそうな範囲です。
<p>
厳密には uA741 の slew rate は 0.5V/us 程度ですから、そっちの方の影響の方が少しだけ強そうです。もし slew rate まで含めてシミュレートしようとすると、PythonSf ではなく Spice を持ち出してくるべきでしょう。PythonSf でも kOde(..) を使って微分方程式を解かせればシミュレートできます。でも その微分方程式モデルを作り上げる手間が面倒すぎです。
<p>
逆に線形系：Laplace 変換で扱える範疇ならば、上の程度の回路の特性検討は Spice よりも PythonSf の方が便利だと思います。Spice ソフトを立ち上げたり、回路図を描いて部品定数を入力するのではなく、エディタ上で PythonSf 式を書くだけなのですから。

<h3>多重帰還型バンドパスフィルタ</h3>
<p>
もう少し複雑な下の回路トポロジで記述される多重帰還型バンドパスフィルタを検討してみましょう。
<pre>
<code>
                                           Io
                   ┌──────┬──────┐ 
                   │            │        Vo  │ 
               ┌─┴─┐    ┌─┴─┐        │ 
               │  Z3  │    │  Z5  │        │ 
               └─┬─┘    └─┬─┘        │ 
                   │↑I2      →│            │ 
    Ii ┌──┐    │V2┌──┐Im│            │ 
     ─┤ Z1 ├──┼─┤ Z4 ├─┴──◆-   Vo│
    Vi └──┘  ↓│Ig└──┘Vm      │ G＞─┴───
               ┌─┴─┐          ┌─◇+
               │  Z2  │          │ 
               └─┬─┘          │ 
                   ≡              ≡
</code>
</pre>
<p>
上の Vi,Vo と Z1, Z2,Z3,Z4,Z5 と V2,Vm,I2,Ig,Im の間に次の六つの関係式が成り立ちます。
<pre>
<code>
Vm = - 1/G Vo ---------------------------------------(1)
Im = (1+1/G) Vo/Z5 --------------------------------- (2)
I2 = 1/Z3 (V2-Vo) ---------------------------------- (3)
Im = 1/Z5 (V2-Vm) ---------------------------------- (4)
Vi-V2 = Z1 I2 + Z1 Im + Z1 Ig ---------------------- (5)
V2 = Vm + Im Z4
   = -1/G Vo + (1+1/G) Vo Z4/Z5 -------------------- (6)
</code>
</pre>
<p>
上の関係式から V2, Im,Ig,Vm を消去して Vo/Vi を表す式を求めるため、下の PythonSf 式を使って Vo,V2, Im,Ig,Vm を Vi と Z1,Z2,Z3,Z4,Z5 の組み合わせの式に変形します。その結果の Vo = .... の式から Vo/Vi = f(Z1,Z2,Z3,Z4,Z5, G) の式を導きます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
ts(); I2,Im,Ig,Vi,Vm,Vo,V2,Z1,Z2,Z5,Z4,Z3,G = ts.symbols('I2,Im,Ig,Vi,Vm,Vo,V2,Z1,Z2,Z5,Z4,Z3,G'); ts.solve([ts.Eq(Im + (1+1/G) Vo/Z5), ts.Eq(1/Z3 (V2-Vo) - I2), ts.Eq(1/Z4 (V2-Vm) - Im),ts.Eq(V2 - Z2 Ig),ts.Eq(-Vi +V2 + Z1 I2 + Z1 Im + Z1 Ig),ts.Eq(V2+1/G Vo - Im Z4)], [I2,Im,Ig,Vo,Vm,V2])
<br>
===============================
<br>
{I2: Vi*Z2*(G*Z4 + G*Z5 + Z4 + Z5)/(G*Z1*Z2*Z3 + G*Z1*Z2*Z4 + G*Z1*Z2*Z5 + G*Z1*Z3*Z4 + G*Z2*Z3*Z4 + Z1*Z2*Z3 + Z1*Z2*Z4 + Z1*Z2*Z5 + Z1*Z3*Z4 + Z1*Z3*Z5 + Z2*Z3*Z4 + Z2*Z3*Z5), Im: Vi*Z2*Z3*(G + 1)/(G*Z1*Z2*Z3 + G*Z1*Z2*Z4 + G*Z1*Z2*Z5 + G*Z1*Z3*Z4 + G*Z2*Z3*Z4 + Z1*Z2*Z3 + Z1*Z2*Z4 + Z1*Z2*Z5 + Z1*Z3*Z4 + Z1*Z3*Z5 + Z2*Z3*Z4 + Z2*Z3*Z5), Vo: G*Vi*Z2*Z3*Z5/(-G*Z1*Z2*Z3 - G*Z1*Z2*Z4 - G*Z1*Z2*Z5 - G*Z1*Z3*Z4 - G*Z2*Z3*Z4 - Z1*Z2*Z3 - Z1*Z2*Z4 - Z1*Z2*Z5 - Z1*Z3*Z4 - Z1*Z3*Z5 - Z2*Z3*Z4 - Z2*Z3*Z5), Ig: Vi*Z3*(G*Z4 + Z4 + Z5)/(G*Z1*Z2*Z3 + G*Z1*Z2*Z4 + G*Z1*Z2*Z5 + G*Z1*Z3*Z4 + G*Z2*Z3*Z4 + Z1*Z2*Z3 + Z1*Z2*Z4 + Z1*Z2*Z5 + Z1*Z3*Z4 + Z1*Z3*Z5 + Z2*Z3*Z4 + Z2*Z3*Z5), V2: Vi*Z2*Z3*(G*Z4 + Z4 + Z5)/(G*Z1*Z2*Z3 + G*Z1*Z2*Z4 + G*Z1*Z2*Z5 + G*Z1*Z3*Z4 + G*Z2*Z3*Z4 + Z1*Z2*Z3 + Z1*Z2*Z4 + Z1*Z2*Z5 + Z1*Z3*Z4 + Z1*Z3*Z5 + Z2*Z3*Z4 + Z2*Z3*Z5), Vm: Vi*Z2*Z3*Z5/(G*Z1*Z2*Z3 + G*Z1*Z2*Z4 + G*Z1*Z2*Z5 + G*Z1*Z3*Z4 + G*Z2*Z3*Z4 + Z1*Z2*Z3 + Z1*Z2*Z4 + Z1*Z2*Z5 + Z1*Z3*Z4 + Z1*Z3*Z5 + Z2*Z3*Z4 + Z2*Z3*Z5)}
<br>
<br>
# Vo = .... の式
<br>
Vo= G*Vi*Z2*Z3*Z5/(-G*Z1*Z2*Z3 - G*Z1*Z2*Z4 - G*Z1*Z2*Z5 - G*Z1*Z3*Z4 - G*Z2*Z3*Z4 - Z1*Z2*Z3 - Z1*Z2*Z4 - Z1*Z2*Z5 - Z1*Z3*Z4 - Z1*Z3*Z5 - Z2*Z3*Z4 - Z2*Z3*Z5)
<br>
<br>
# Vo/Vi = f(Z1,Z2,Z3,Z4,Z5, G) の式
<br>
Vo/Vi= Z2 Z3 Z5/(-Z1 Z2 Z3 - Z1 Z2 Z4 - Z1 Z2 Z5 - Z1 Z3 Z4 - Z2 Z3 Z4 -(Z1 Z2 Z3 + Z1 Z2 Z4 + Z1 Z2 Z5 + Z1 Z3 Z4 + Z1 Z3 Z5 + Z2 Z3 Z4 +
Z2 Z3 Z5)/G)
<br>
 --------------------------------------------------- (7)
</span>
</code>
<br>
<p>
上の 7 式なんて、手計算では絶対に計算しきれないと思います。途中で誤りが入り込んで計算が収束しないでしょう。sympy は凄いと思います。そして sympy で Python プログラム・コードを書くとしても、普通のエンジニアはデバッグ途中でギブ・アップすると思います。でもワン・ライナーであれこれ試せる PythonSf ならば、この程度のトポロジーの回路でも扱えます。ここらが限度の気もしますが、通常の回路設計ならば これで十分でしょう。各 Z ブロックは単一素子に限らなくて、任意の L C R の組み合わせでもかまわないのですから。
<p>
上で求めた Vo/Vi の式を下の多重帰還型バンドパスフィルタ回路に適用してみましょう。
<pre>
<code>
                   ┌──────┬──────┐ 
                   │Z3          │Z5      Vo  │ 
                 ─┴─1000p     ≧220k        │ 
                 ─┬─          ≦            │ 
                 ↑│I2      →  │            │ 
    Ii     Z1      │V2  Z4  Im  │            │ 
     ───MWMW──┼──┤├──┴─◆-       │
    Vi     22k     │   1000p Vm     │ G＞──┴───
                   ≧Z2          ┌─◇+
                   ≦1k          │ 
                   │            │ 
                   ≡            ≡
</code>
</pre>
<p>
理想オペアンプでは次のような伝達関数・Bode 線図になります。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
# 伝達関数
Z1,Z2,Z3,Z4,Z5 = 22kΩ`, 1kΩ`, 1/(1000pF` `s), 1/(1000pF` `s),220kΩ`; trf=Z2 Z3 Z5/(-Z1 Z2 Z3 - Z1 Z2 Z4 - Z1 Z2 Z5 - Z1 Z3 Z4 - Z2 Z3 Z4); trf
<pre>
===============================
     -4.545e+04 s
----------------------
 2
s + 9091 s + 4.752e+09
</pre>
</span>
</code>

<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
# Bode 線図
Z1,Z2,Z3,Z4,Z5 = 22kΩ`, 1kΩ`, 1/(1000pF` `s), 1/(1000pF` `s),220kΩ`; trf=Z2 Z3 Z5/(-Z1 Z2 Z3 - Z1 Z2 Z4 - Z1 Z2 Z5 - Z1 Z3 Z4 - Z2 Z3 Z4); trf.plotBode(1k` Hz`,100k` Hz`)
</span>
</code>
<br>
<img src="./jpg/1111/oneliners_ideal_multiple_feedback_bandpass.jpg">
<br>
<p>
この伝達関数の極は次の PythonSf 式で求められます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
Z1,Z2,Z3,Z4,Z5 = 22kΩ`, 1kΩ`, 1/(1000pF` `s), 1/(1000pF` `s),220kΩ`; trf=Z2 Z3 Z5/(-Z1 Z2 Z3 - Z1 Z2 Z4 - Z1 Z2 Z5 - Z1 Z3 Z4 - Z2 Z3 Z4); trf.m_plDenom.roots
<br>
===============================
<br>
[-4545.45454545+68785.20886555j -4545.45454545-68785.20886555j]
</span>
</code>
<br>
<p>
uA741 オペアンプでは次のような伝達関数・Bode 線図になります。中心周波数が理想オペアンプのときより数 kHz 低くなります。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
<br>
G=:uA741; Z1,Z2,Z3,Z4,Z5 = 22kΩ`, 1kΩ`, 1/(1000pF` `s), 1/(1000pF` `s),220kΩ`; trf=Z2 Z3 Z5/(-Z1 Z2 Z3 - Z1 Z2 Z4 - Z1 Z2 Z5 - Z1 Z3 Z4 - Z2 Z3 Z4 -(Z1 Z2 Z3 + Z1 Z2 Z4 + Z1 Z2 Z5 + Z1 Z3 Z4 + Z1 Z3 Z5 + Z2 Z3 Z4 + Z2 Z3 Z5)/G); trf
<br>
<pre>
===============================
              -2.856e+11 s
----------------------------------------
 3             2
s + 7.338e+06 s + 6.214e+10 s + 2.986e+16
</pre>
</span>
</code>
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
G=:uA741; Z1,Z2,Z3,Z4,Z5 = 22kΩ`, 1kΩ`, 1/(1000pF` `s), 1/(1000pF` `s),220kΩ`; trf=Z2 Z3 Z5/(-Z1 Z2 Z3 - Z1 Z2 Z4 - Z1 Z2 Z5 - Z1 Z3 Z4 - Z2 Z3 Z4 -(Z1 Z2 Z3 + Z1 Z2 Z4 + Z1 Z2 Z5 + Z1 Z3 Z4 + Z1 Z3 Z5 + Z2 Z3 Z4 + Z2 Z3 Z5)/G); trf.plotBode(1k` Hz`,100k` Hz`)
</span>
</code>
<br>
<img src="./jpg/1111/oneliners__ua741_multiple_feedback_bandpass.jpg">
<p>
流石に複雑なトポロジーの回路で部品数も多い分、先の微分・積分回路によるバンド・パスのときより急峻な選択特性になっています。
<p>
この伝達関数の極は次の PythonSf 式で求められます。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
G=:uA741; Z1,Z2,Z3,Z4,Z5 = 22kΩ`, 1kΩ`, 1/(1000pF` `s), 1/(1000pF` `s),220kΩ`; trf=Z2 Z3 Z5/(-Z1 Z2 Z3 - Z1 Z2 Z4 - Z1 Z2 Z5 - Z1 Z3 Z4 - Z2 Z3 Z4 -(Z1 Z2 Z3 + Z1 Z2 Z4 + Z1 Z2 Z5 + Z1 Z3 Z4 + Z1 Z3 Z5 + Z2 Z3 Z4 + Z2 Z3 Z5)/G); trf.m_plDenom.roots
<br>
===============================
<br>
[ -7.33006081e+06    +0.j          -3.96063749e+03+63701.29330301j
  -3.96063749e+03-63701.29330301j]
</span>
</code>
<p>
部品定数を変化させ根軌跡を描くことで、共振特性も検討できそうです。周波数選択特性も設計できそうです。
<br>
<br>
<a name="■■ Fractal 図形"></a>
<h2>■■ Fractal 図形</h2>
<p>
PythonSf 記述は数学記述に近いので、数学的な対象の説明では、自然言語による説明より PythonSf コードの方が解り易いことが多くあります。Fractal 図形について、その様子を見てみましょう。
<p>
なお、ここでは one-liner ではなく、ブロック・コードのほうが多用されます。One-liner にして再利用する意味は殆ど無いからです。ならば可読性を優先すべきだからです。

<h3>Koch Curve</h3>
<p>
コッホ曲線を PythonSf で描きます。<a href="http://ja.wikipedia.org/wiki/コッホ曲線">Wiki</a> などにも Koch 曲線の説明があるのですが、下の 
複素数を使ったコードのほうが解りやすいと思います。
<!--
http://en.wikipedia.org/wiki/Koch_snowflake
-->
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ブロック</b>
# Koch 曲線
//@@
θ=exp(`i pi/3)
def f(lst,count=10):
    if count<0:
        return lst

    rtn=[]
    for k in range(len(lst)-1):
        sg = (lst[k+1]-lst[k])/3
        rtn += [lst[k], lst[k]+sg, lst[k]+sg+θ sg, lst[k]+sg 2]
    
    rtn += [lst[-1] ]
    return f(rtn, count-1)

plotTrajectory([ (x.real, x.imag) for x in f([0,1], 5)])
//@@@
</code>
</pre>
<br>
<img src="./jpg/1111/block_python_kocho2.jpg">
<p>
上のコードの肝は、下の二行です。
<pre>
<code>
        sg = (lst[k+1]-lst[k])/3
        rtn += [lst[k], lst[k]+sg, lst[k]+sg+θ sg, lst[k]+sg 2]
</code>
</pre>
<p>
Koch 曲線を lst に平面位置：複素数値を順番に並べることで表現します。その部分セグメント：直線：lst[k+1]-lst[k] の 1/3 の線分 sg を作ります。sg ができたら、θ sg によって左方向に 60度回転させた線分を作れます。そして [lst[k], lst[k]+sg, lst[k]+sg+θ sg, lst[k]+sg 2] によって元の線分をもう一段階細かく折り曲げた四つの繋がった線分を作ります。
<p>
下は [0,1,0.5-`i, 0] の三角形の線分から Koch 曲線を作ることで、雪の結晶のような Koch 曲線にしています。
</span>
</code>
</pre>
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ブロック</b>
# 星型の Koch 曲線
//@@
θ=exp(`i pi/3)
def f(lst,count=10):
    if count<0:
        return lst

    rtn=[]
    for k in range(len(lst)-1):
        sg = (lst[k+1]-lst[k])/3
        rtn += [lst[k], lst[k]+sg, lst[k]+sg+θ sg, lst[k]+sg 2]
    
    rtn += [lst[-1] ]
    return f(rtn, count-1)

plotTrajectory([ (x.real, x.imag) for x in f([0,1,0.5-`i, 0], 5)])
//@@@

</span>
</code>
</pre>
<br>
<img src="./jpg/1111/block_python_kocho2_snow.jpg">
<h3>Hilbert Curve</h3>
<p>
平面を埋め尽くす一次元の線として Hirbert Curve が有名です。でも<a href="http://en.wikipedia.org/wiki/Hilbert_curve#Applications_and_mapping_algorithms ">Wiki</a>や <a href="http://mathworld.wolfram.com/HilbertCurve.html">WolframMathWorld</a> などの説明を読んでも、どうやって描いていくのか簡単には理解できません。下の PythonSf ブロック・コードなら Hilbert Curve を作るアルゴリズムが良くわかると思います。いかがでしょうか？
<!--
http://en.wikipedia.org/wiki/Hilbert_curve#Applications_and_mapping_algorithms

http://mathworld.wolfram.com/HilbertCurve.html
A Lindenmayer system invented by Hilbert (1891) whose limit is a plane-filling function which fills a square. Traversing the polyhedron vertices of an n-dimensional hypercube in Gray code order produces a generator for the n-dimensional Hilbert curve. The Hilbert curve can be simply encoded with initial string "L", string rewriting rules "L" -> "+RF-LFL-FR+", "R" -> "-LF+RFR+FL-", and angle 90 degrees (Peitgen and Saupe 1988, p. 278). 

https://www.fractalus.com/kerry/tutorials/hilbert/hilbert-tutorial.html
-->
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ブロック</b>
//@@
N=3

# seed trajectory: matrix of position data
mt=~[(1/4,3/4),(1/4,1/4),(3/4,1/4),(3/4,3/4)]
mtL = ~[[ 0,1],     # rotate pi/2 left
        [-1,0]]
mtS = ~[[ 0,1],     # symmetric conversion for x==y axis
        [ 1,0]]

for _ in range(N):
    mt=~[list((mt mtL)[::-1] +~[1,1])
       + list(mt)
       + list(mt+~[1,0])
       + list(mt mtS + ~[1,1])
        ]/2

plotTrajectory(mt)
//@@@
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_hilbert_curve.jpg">
<br>
<p>
上のコードの肝は mt mtL と mt mtS の行列積です。mt は N x 2 行列であり N この平面位置ベクトルを保持しています。これに右から mtL:( pi/2 だけ回転させる) 変換と mtS:(x==y の直線に対称な位置に鏡影変換する行列を掛けることで位置ベクトルの羅列データ mt を変換しています。
<!--
<h2>Gauss の代数学基本定理</h2>
問題定義
Gauss の代数学の基本定理 「N 次多項式は N 個の根を持つ」を成り立たせている必要十分な理由を示せ
<== 四元数では無限個になる
常に Z3 n 次多項式が n 個の根を持つように Z3 体を拡張できるか
<== 直感的には無限次元になってしまいそう
<== 三次、四次、五次多項式まで調べてみよ
独立させる
<p>
数学も自然科学です。ですから数学の問題を実験により解明していけます。そして PythonSf は、この実験のための手間を著しく簡便にしてくれます。
<p>
例として「Gauss の代数学の基本定理:N 次多項式は N 個の根を持つ」性質は何によってもたらされているのか？」を考えて見ます。でも、このような単なる疑問文では漠然としすぎで、考察を進められないので、
<ul>
    <li> 多項式の根を求める → 自乗根: x^2 == 1 となる x を求める
</ul>
と問題を単純化します。そして 1 の自乗根を探す範囲を四元数に広げてみます。また逆に z5_x + z5_y i where z5_x, z5_y ∈ Zp(5) に根を探す範囲を狭めてみます。

<h2>sqrt(..) の多項式展開</h2>
sqrt は Maclaurin 展開できない
http://chaosweb.complex.eng.hokudai.ac.jp/~josch/workshop/math/Maclaurin/Maclaurin3.htm

<h3>実数値四元数</h3>
oc.Oc(2,30,500, 7000)^2
===============================
(-49250896, 120, 2000, 28000)

(x+yi+zj+wk) (x+yi+zj+wk) = x^2-y^2-z^2-w^2+(2 x y) i+(z x + w y + x z - y w) j+(w x - z y + y z : x w) k

上の式の確認
x,y,z,w = (2,30,500, 7000); x^2-y^2-z^2-w^2
===============================
-49250896
x,y,z,w = (2,30,500, 7000); (2 x y)
===============================
120
x,y,z,w = (2,30,500, 7000); (z x + w y + x z - y w) 
===============================
2000
x,y,z,w = (2,30,500, 7000); (w x - z y + y z + x w) 
===============================
28000


独立させる
Larent 展開;;http://www.f-denshi.com/000TokiwaJPN/12cmplx/090cmp.html
sqrt(..) 関数は z==0 の点で 0 次の極を持つ解析関数です。でも z==0 の点では Taylor 展開も Laurent 展開もできません。z=0+0j の点は孤立特異点であり、Rieman 面が発生しています

plot3dGr( sqrt, [-1,1],[`i,-`i])
plot3dGr(-sqrt, [-1,1],[`i,-`i])

z=1+0j など 0+0j 以外の場所では taylor 展開可能です
ts(); ts.sqrt(1+`x).series(`x,n=5)
===============================
1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128 + O(x**5)

ts(); (1/ ts.sqrt(1+`x) ).series(`x,n=5)
===============================
1 - x/2 + 3*x**2/8 - 5*x**3/16 + 35*x**4/128 + O(x**5)

sqrtm(`σx+`σy)
===============================
[[  5.94603558e-01 -5.94603558e-01j   8.40896415e-01 +1.11022302e-16j]
 [ -5.55111512e-17 +8.40896415e-01j   5.94603558e-01 -5.94603558e-01j]]
---- ClTensor ----

mt=sqrtm(`σx+`σy); mt^2
===============================
[[ 0. -3.33066907e-16j  1. -1.00000000e+00j]
 [ 1. +1.00000000e+00j  0. +2.22044605e-16j]]
---- ClTensor ----

sy(); sc.source(sy.linalg.sqrtm)
sc.source(np.linalg.sqrtm)
np.source(sqrtm)


x=`X; plotGr(1+x, 0.5,1.5); plotGr( 1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128,0.5,1.5, color=red)

ts(); ts.sqrt(1+`x).series(`x,n=10)
===============================
1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128 + 7*x**5/256 - 21*x**6/1024 + 33*x**7/2048 - 429*x**8/32768 + 715*x**9/65536 + O(x**10)

x=`X; plotGr(1+x, 0.5,1.5); plotGr(1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128 + 7*x**5/256 - 21*x**6/1024 + 33*x**7/2048 - 429*x**8/32768 + 715*x**9/65536 ,0.5,1.5, color=red)

x=`X; plotGr(sqrt( 1+x ),-0.5,0.5); plotGr( 1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128,-0.5,0.5, color=red)
x=`X; plotGr(sqrt( 1+x ),-1.0,3.5); plotGr( 1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128,-1.0,3.5, color=red)
x=`X; plotGr(sqrt( 1+x ),-1.0,3.5); plotGr(1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128 + 7*x**5/256 - 21*x**6/1024 + 33*x**7/2048 - 429*x**8/32768 + 715*x**9/65536 ,-1.0,3.5, color=red)
x=`X; plotGr(sqrt( 1+x ),-1.0,2.5); plotGr(1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128 + 7*x**5/256 - 21*x**6/1024 + 33*x**7/2048 - 429*x**8/32768 + 715*x**9/65536 ,-1.0,2.5, color=red)
x=`X; plotGr(sqrt( 1+x ),-1.0,1.5); plotGr(1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128 + 7*x**5/256 - 21*x**6/1024 + 33*x**7/2048 - 429*x**8/32768 + 715*x**9/65536 ,-1.0,1.5, color=red)
<== Taylor 展開は万能ではない
    <== sqrt(z) は 0 が Laurent 展開できない特異点であり、Taylor 展開では その影響が反対側にも及ぶ


行列でも Taylor 展開近似が成り立つか？
x=`σx+`σy; print(sqrt( 1+x )); `print( 1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128)
[[ 1.00000000+0.j          1.45534669-0.34356075j]
 [ 1.45534669+0.34356075j  1.00000000+0.j        ]]
---- ClTensor ----
ClTensor([[ 0.59375+0.j   ,  1.62500-0.625j],
       [ 1.62500+0.625j,  0.59375+0.j   ]], dtype=complex)
===============================
None

x=0.1 ( `σx+`σy ); print(sqrt( 1+x )); `print( 1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128)
[[ 1.00000000+0.j          1.04988954-0.04762406j]
 [ 1.04988954+0.04762406j  1.00000000+0.j        ]]
---- ClTensor ----
ClTensor([[ 0.99748438+0.j      ,  1.05012500-0.050125j],
       [ 1.05012500+0.050125j,  0.99748438+0.j      ]], dtype=complex)
===============================
None
x=0.2 ( `σx+`σy );`print(sqrt( 1+x )); `print( 1 + x/2 - x**2/8 + x**3/16 - 5*x**4/128)
ClTensor([[ 1.0000000+0.j        ,  1.0992162-0.09097391j],
       [ 1.0992162+0.09097391j,  1.0000000+0.j        ]], dtype=complex)
ClTensor([[ 0.98975+0.j   ,  1.10100-0.101j],
       [ 1.10100+0.101j,  0.98975+0.j   ]], dtype=complex)
===============================
None

`σx^2
===============================
[[ 1.  0.]
 [ 0.  1.]]
---- ClTensor ----

sqrt(kzrs(2,2)^0)
===============================
[[ 1.  0.]
 [ 0.  1.]]
---- ClTensor ----

その固有値は [1,1], [1,-1],[-1,-1],[-1,-1]
eigvalsh(`σx)
===============================
[-1.  1.]
---- ClTensor ----
eigvalsh(`σy)
===============================
[-1.+0.j  1.+0.j]
---- ClTensor ----

`σx^2
===============================
[[ 1.  0.]
 [ 0.  1.]]
---- ClTensor ----
`σy^2
===============================
[[ 1.+0.j  0.+0.j]
 [ 0.+0.j  1.+0.j]]
---- ClTensor ----

`σx^0, `σx, `σy, `σz はベクトルとして直行している
[ x.r y.r for x,y in combinate([`σx^0, `σx, `σy, `σz],2)]

-->





<a name="■■ wav データ処理"></a>
<h2>■■ wav データ処理</h2>
<p>
標準配布の PythonSf　の sfCrrntIni.py ファイルには wav ファイルを読み書きする readWv(..)/writeWv(..) 関数を書いてあります。readWv(..) 関数は wav ファイルのデータをベクトル・データに変換します。writeWv(..) 関数はベクトル・データのデータを wav ファイルに変換します。ベクトル・データであれば、PythonSf で自由に操作できます。
<p>
これを使って PythonSf one-liner による楽器音の合成や英語音声の解析を行います。
<p>
この小さな readWv(..)/wirteWv(..) カスタマイズ関数の導入だけで、PythonSf's one-liner による音声処理が可能になることを見てやってください。
<h3>ギター音の合成</h3>
<a href="http://en.wikipedia.org/wiki/Karplus-Strong_string_synthesis">Karplus というギター音の合成アルゴリズム</a>があります。弦を引っかくときのノイズ・データと、減衰フィルタから構成されます。
<!--
http://lab.andre-michelle.com/karplus-strong-guitar
http://www.mathworks.co.jp/products/signal/demos.html?file=/products/demos/shipping_ja/signal/filterguitardemo.html
http://electro-nut.blogspot.com/2009/08/karplus-strong-algorithm.html
音声合成ソフトでの Karplus 操作ビデオ;;http://wn.com/Karplus-Strong_algorithm
-->
<pre>
<code>
<span style="color: #9f009f;">
<b>pythonsf ブロック</b>
//@@
f0=220Hz`       # key 音
SR=44100Hz`     # sampling rate
z_=1/`s         # z^-1: z 変換記号
seed(0)         # random の種
pluckedNoise=rand(SR//f0)-0.5   # 弦を引っ掛けるノイズ
F=0.996/2 (1+z_)                # 減衰フィルタ 1
G=1/(1-F z_^(SR//f0))           # 減衰フィルタ 2: f0 での振動も生成する

# 伝達関数 G に pluked noise を与えたときの応答ベクトル data を作る
data=G.getDgRspns(np.r_[pluckedNoise, [0]*(SR-SR//f0)])

# 最大値を 2^15 に規格化する
data=2^15/max(abs(data))

# 規格化されたベクトル data をカレント・ディレクトリの temp.wav ファイルとして書き込む
writeWv(data, 'temp',(1, 2, SR, 32400, 'NONE', 'not compressed'))
//@@@

<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
f0,SR,z_=220Hz`, 44100Hz`, 1/`s; seed(0);F=0.996/2 (1+z_); G=1/(1-F z_^(SR//f0)); data=G.getDgRspns(np.r_[rand(SR//f0)-0.5, [0]*(SR-SR//f0)]); data*=2^15/max(abs(data)); writeWv(data, 'temp',(1, 2, SR, 32400, 'NONE', 'not compressed'))
</span>
</code>
<br>
</span>
</code>
</pre>
<p>
下のようにフィルタを追加して高周波を落としてやるとナイロン弦でのような音になります。
<br>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b><br>
f0,SR,z_=220Hz`, 44100Hz`, 1/`s; seed(0); sy();y=sg.lfilter([0.1]*10,[1,1.0], rand(SR//f0)-0.5);F=0.996/4 (1+z_+z_^2+z_^3); G=1/(1-F z_^(SR//f0)); data=G.getDgRspns(np.r_[y, [0]*(SR-SR//f0)]); data=2^15/max(abs(data)) data; writeWv(data, 'temp',(1, 2, SR, 32400, 'NONE', 'not compressed'))
</span>
</code>
<br>
<p>
scipy の signal sub package には、signal processing のための様々な関数群が用意されています。原理的には如何様なギター音でも合成できます。結構遊べます。
<h3>L/R 識別</h3>
英語の love と rub 音声ファイル love_rub.wav も標準配布のカレント・ディレクトリに入れてあります。16kHz サンプリングの整数値データです。これと PythonSf のワンライナーを使って、日本人の苦手な L/R 識別について調べ・考えてみましょう。
<p>
下のように love_rub.wav は 27545 点のデータからなり、1.728125 秒の長さの音声です。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
readWv('love_rub').shape
==============================
(27545,)

ts(); 27645.0/(16 k` Hz`)
===============================
1.7278125*s`
</span>
</code>
</pre>
<p>
<a href="http://sourceforge.jp/projects/sfnet_wavesurfer/releases/">WaveSurfer</a> というソフトを使って、その波形とスペクトログラムの時間変化を下のように可視化できます。
<br>
<img src="./jpg/1111/oneliners_wave_surfer_love_rub.jpg">
<br>
日本人が L/R の区別をできないのは、日本語でのラ行の音に置き換えて聞いてしまうからです。love も rub も「ラブ」聞いてしまうからです。PythonSf を使って子音 L や R だけを取り出して実際に聞いてみましょう。
<h4>L 子音の取り出しと識別</h4>
<p>
L の音は、love_ruv.wav ファイルで 0.358s -- 0.490s の範囲にあります。この時間幅をインデックスで表現すると、5707 -- 7011 の範囲です。下の計算で分かります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# L の音の範囲のインデックスを計算する
27545 0.358s`/(1.7278125*s`)
===============================
5707.28015916

27545 0.490s`/(1.7278125*s`)
===============================
7811.64044131

7800-5700
===============================
2100
</span>
</code>
</pre>

<p>
この L 子音の部分だけを抜き出して、デフォルトの _tmp.wav ファイに書き出します。ただし音声データを急激に 0 にするとプチ・ノイズになるので、最後の 200 点の音は直線状に絞って消します。したの arsq(1,200,-1/200) の部分が、それを行います。readWv(..) が「numpy の ndarray データを返すこと」と「ndarray と list の積は要素ごとを掛け合わした ndarray でーたになること」を利用しています。

<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# love_rub.wav から子音 L の部分を抜き出して _tmp.wav ファイルに保存する。
vct=readWv('love_rub')[5700:7800]; writeWv(vct ( (1,)*1900+arsq(1,200,-1/200)) )
===============================
None
</span>
</code>
</pre>
<p>
このようにして抜き出した子音 L の音:_tmp.wav を御自分の耳で是非とも聞いてください。日本語でのラ行の音とは異なることが分かると思います。この子音 L の部分だけ(母音とは独立させて)聞き取れるようになると L/R の誤認識を改善できます。
<p>
でもまだ この子音：L には余分なノイズに近い音が混じっています。私が L の音だと思っているのとは少し違いがあります。その L の音を抜き出すため、フーリエ変換を使います。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 子音 L のフーリエ変換
vc=readWv('_tmp'); plotGr( abs( fftshift( fft(vc) ) ) )
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_wave_surfer_l_fft.jpg">
<br>
<p>
上のグラフでフーリエ変換の絶対値のグラフは左右対称です。画面で左右対称になっていないのは、2100 点のデータをコンピュータ画面上で表示するときに歯抜けが発生するからです。歯抜けが左右対称には起きないためです。1000 点のデータ：±4kHz 弱の領域に限ると、下のように左右対称になります。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
# 子音 L のフーリエ変換結果を中心部分 1000 点に限定してグラフ化する
vc=readWv('_tmp'); plotGr( abs( fftshift( fft(vc) ) )[2100/2-550: 2100/2+550] )
</span>
</code>
</pre>
<br>
<img src="./jpg/1111/oneliners_wave_surfer_l_fft_1000.jpg">
<br>
子音 L の音から±220 点、±1.67kHz の領域のみの音を取り出して、それ以外とはノイズだとみなしてみましょう。
だとみなしてみましょう
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
# 16kHz サンプリングの fft データから 220 点のデータを取り出したときの周波数
16k` Hz` 220/2100
===============================
1676.19047619

# 子音 L の音を±1.6kHz に限定した _tmp.wav ファイルを作る
vc=readWv('_tmp'); v=fft(vc); v[220:-220]=0; writeWv( ifft(v).real )
</span>
</code>
</pre>
<p>
上のようにして作った _tmp.wav ファイルの音を自分の耳で聞いて見てください。love の音から、この部分の音に集中して聞き取るようにすることで love の英語の l が、日本語のラブとは違った音として聞き取れるようになってきます。


<h4>R 子音の取り出しと識別</h4>
to be discussed
<!--
*** R の音
27545 1.040s`/(1.7278125*s`)
===============================
16579.8082836

27545 1.165s`/(1.7278125*s`)
===============================
18572.5737023

vct=readWv('love_rub')[16570:18570]; writeWv(vct ( (1,)*1800+arsq(1,200,-1/200)) )
===============================
None
<== R の音は、なだらかに切り出すだけで、私の聞いている音になった。


vct=readWv('love_rub')[16570:18570]; plotGr(abs(sc.fft.fft(vct))^2)

<h3>和音</h3>
音楽の小理屈;;http://homepage2.nifty.com/sampodo/korikutu/korikutu.html
<h2>対称群</h2>
<p>
kfs:ソート機能付の frozeset
    <== 集合の集合 など frozenset でなければ使えない
        { {1,2,3}, {4,5} }
unhashable type: 'set' at excecuting:set([ set([1,2,3]), set([4,5]) ])
        { kfs({1,2,3}), kfs({4,5}) }
===============================
set([kfs([1, 2, 3]), kfs([4, 5])])
    ×<== == など frozenset でなければ使えない
{1,2,3} == {1,2,3}
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナー</b>
=:SS4, SA4; SA4 + Cy(0,1) SA4 == SS4
===============================
True
Sb
=:SS4, SA4; SS4/SA4
===============================
kfs([Sb(0,1,2,3), Sb(0,1,3,2)])

=:SS4, SA4; kfs([ x y x^-1 y^-1 for x,y in mitr(SA4,SA4)])
===============================
kfs([Sb(0,1,2,3), Sb(1,0,3,2), Sb(2,3,0,1), Sb(3,2,1,0)])

=:SS4, SA4; SS=kfs([ x y x^-1 y^-1 for x,y in mitr(SA4,SA4)]); [ x y in SS for x,y in mitr(SS,SS)]
===============================
[True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]
=:SS4, SA4; SS=kfs([ x y x^-1 y^-1 for x,y in mitr(SA4,SA4)]); [ x y in SS for x,y in mitr(SS,SS)]
=:SS4, SA4; SS=kfs([ x y x^-1 y^-1 for x,y in mitr(SA4,SA4)]); SA4/SS
===============================
kfs([Sb(0,1,2,3), Sb(0,2,3,1), Sb(0,3,1,2)])
=:SS4, SA4; SS=kfs([ x y x^-1 y^-1 for x,y in mitr(SA4,SA4)]); Sb(0,2,3,1) SS == SS Sb(0,2,3,1)
===============================
True

</span>
</code>
</pre>

<h2>wikipedia</h2>
<h3>gamma function</h3>
http://en.wikipedia.org/wiki/Gamma_function
χ 自乗分布;;http://en.wikipedia.org/wiki/Chi-squared_distribution など、様々の公式で gamma 関数が出てくる。何故だろうか。
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
sy(); ss.gamma(0.5+`i)
===============================
(0.300694617261-0.424967879433j)

sy(); seed(0);N=10; [ ss.gamma(x+1) ~= (x ss.gamma(x)) for x in randn(N)]
===============================
[True, True, True, True, True, True, True, True, True, True]

sy(); seed(0);N=10; [ ss.gamma(x+1) ~= (x ss.gamma(x)) for x in randn(N)+`i randn(N)]
===============================
[True, True, True, True, True, True, True, True, True, True]

sy(); plot3dGr( ss.gamma, [-5     ,5],[+5`i, -5`i])

sy(); vc=klsp(-3,3,300); f=ss.gamma; dct={};for idx,(x,y) in enmitr(vc,vc):dct[idx]=f(x+`i y); render2dRGB(dct)
</span>
</code>
</pre>
<h3>χ自乗検定：Pearson's chi-squared test</h3>
Pearson's chi-squared test;;http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test
( カイ二乗検定;;http://ja.wikipedia.org/wiki/カイ二乗検定 )
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
(44-50)^2/50 + (56-50)^2/50
===============================
1.44

1-quadR(λ x:exp(-x/2)/sqrt(2 pi x), 0, 1.44)
===============================
0.230139340443
</span>
</code>
</pre>
<h2>Building Abstractions with Functions</h2>
http://www-inst.eecs.berkeley.edu/~cs61a/sp12/book/objects.html
<pre>
<code>
<span style="color: #9f009f;">
<b>PythonSf ワンライナーたち</b>
import urllib as md; shakespeare = md.urlopen('http://inst.eecs.berkeley.edu/~cs61a/fa11/shakespeare.txt'); shakespeare.read()

import urllib as md; shakespeare = md.urlopen('http://inst.eecs.berkeley.edu/~cs61a/fa11/shakespeare.txt'); words:=set(shakespeare.read().decode().split())

=:words; [ w for w in words if len(w)>=5 and w[::-1] in words]
===============================
[u'lived', u'level', u'steel', u'speed', u'repel', u'drawer', u'redder', u'refer', u'sessa', u'madam', u'leper', u'diaper', u'deeps', u'reward', u'devil', u'repaid', u'stops', u'keels', u'spots', u'stink', u'rever', u'leets', u'sleek', u'asses', u'knits', u'minim']
</span>
</code>
</pre>
-->
<div>
<div id="div_1">
<p><input type="button" value="説明を表示する" style="WIDTH:150px"
   onClick="document.getElementById('div_2').style.display='block';
            document.getElementById('div_1').style.display='none'"></p>
</div>
<div id="div_2" style="display:none">
<p><input type="button" value="説明を隠す" style="WIDTH:150px"
   onClick="document.getElementById('div_2').style.display='none';
            document.getElementById('div_1').style.display='block'"></p>
<p>
なんだかんだ。（説明文）
</p>
<p><input type="button" value="説明を隠す△" style="WIDTH:150px"
   onClick="document.getElementById('div_2').style.display='none';
            document.getElementById('div_1').style.display='block';
            document.location='#div_1'"></p>
</div>
</div>
<!--
    mailto: your@email.ne.jp<br>
    Last update: 
高校数学
等比数列・等比級数と循環小数
>私は中学3年生です。数日前卒業式でした。
>数学の分野で学んだところを言うと、おととい数学Iの実数の絶対値のところを理解した感じです。
>ただhop step jumpなところがあり数学Aや数学Bに少し手を出したりもします。

期待できそうな若い人たちを見ていると嬉しくなります、

Python の膨大なライブラリは、理工系の様々な数値実験を手軽に実行可能にしてくれます。循環小数や等比数列・等比級数などの理論を数値実験しながら理解していけます。ここらの話を少し詳しくみてみましょう。

等比数列・等比級数の説明が Wikipedia にあります。これを Python に数値実験で なぞっていきましょう。

●等比数列
等比数列は初項 a と公比 r から定まる [a, ar, ar^2, ar^3, ... ] の数列です。Python で長さ N=10 の数列をリスト内包表記で作れます。

N=10; a,r=3,2; [a r^n for n in range(N)]
===============================
[3, 6, 12, 24, 48, 96, 192, 384, 768, 1536]

N=10; a,r=3,4; [a r^n for n in range(N)]
===============================
[3, 12, 48, 192, 768, 3072, 12288, 49152, 196608, 786432]

//@@
N=10
import sympy as ts
a=3
r=ts.Rational(1)/4
print [a* r**n for n in range(N)]
//@@@
[3, 3/4, 3/16, 3/64, 3/256, 3/1024, 3/4096, 3/16384, 3/65536, 3/262144]

数列の隣の項との比が常に公比 r になっていることが分かります。

最後の例で sympy の Rational を使いました。有理数クラスを持ってこないと、下のような小数点数値列となってしまいます。微小値ですが、数値計算誤差が入り込んできます。
N=10; a,r=3,1/4; [a r^n for n in range(N)]
===============================
[3.0, 0.75, 0.1875, 0.046875, 0.01171875, 0.0029296875, 0.000732421875, 0.00018310546875, 4.57763671875e-05, 1.1444091796875e-05]

tn.`Σ(tn.chain([2],tn.cycle([2,3,4])))
tn.ClMakeSumUpGn(tn.chain([2],tn.cycle([2,3,4])))[:10]
●等比級数
等比級数は、無限に伸びる等比数列の和です。公比 r が 1 より大きいと、等比数列の和は無限大の値に発散してしまいます。でも公比 r が 1 より小さいときは、数列が無限長であっても、その無限和は有限な値となります。

ここで無限数列という暴れ馬が出てきます。本来ならば有限な人間が操作できるのは有限なものに限られます。でも r が 1 より小さいときは、等比級数は無限長であっても有限和の値を持ちます。なんとか無限数列を扱いたくなります。等比級数の無限数列だけならば、そんなに拘る必要はないのですが、微分・積分が必須となる近代数学の世界では、いたる所で無限数列が顔を出してきます。なんとか無限数列を数学的な厳密性を損なうことなく扱う必要にせまられます。

そこで近代数学は「有限な手続きを組み合わせて極限値に収束させる」ことで無限数列という暴れ馬を乗りこなしていきます。以下の話は、この乗りこなし方を意識しながら見ていくと面白いでしょう。

この方法は無限という暴れ馬は不完全にしか乗りこなせていません。例えば現代数学の偏微分の定義では病的な例が山ほど出てくるのに目を瞑ったままです

等比級数は「等比数列の弟 n 項までの和が、n を無限大にしたとき収束する値」と定義することで、有限な人間が有限な手続きだけで無限数列を扱えるようにします。

「等比数列の弟 n 項までの和」は先の wikipedia で証明されているように、下の公式で表されます。
       n
Sn ≡ Σ a r^k ≡ a+ar+ar^2+ar^3+ ... + a r^n ≡ sum([a, a r, a r^2, a r^3, ... , a r^n])
      k=0

   ≡ a (1-r^(n+1))/(1-r)

数学で新しい公式が出てきたら、数値実験で試してみましょう。具体例で試すことで、その公式の意味が解ってきます。Python を使えば数値実験は簡単です。

n=10; a,r=3,4; sum([a*r**k for k in range(n+1)]), a*(1-r**(n+1))/(1-r)
===============================
(4194303, 4194303.0)

等比級数の公比 r が 1 より大きいとき、Sn=(a (1-r^(n+1))/(1-r) の公式が成り立ちながら、Sn が発散していく様子が、下の Python 式で解ります。

N=11; a,r=3,4; [(sum([a*r**k for k in range(n+1)]), a*(1-r**(n+1))/(1-r)) for n in range(N)]
===============================
[(3, 3.0), (15, 15.0), (63, 63.0), (255, 255.0), (1023, 1023.0), (4095, 4095.0), (16383, 16383.0), (65535, 65535.0), (262143, 262143.0), (1048575, 1048575.0), (4194303, 4194303.0)]
n=10; a,r=3,4; 

逆に等比級数の公比 r が 1 より小さいとき、Sn=(a (1-r^(n+1))/(1-r) の公式が成り立ちながら、Sn が収束していく様子が、下の Python 式で解ります。
N=11; a,r=3,0.4; [(sum([a*r**k for k in range(n+1)]), a*(1-r**(n+1))/(1-r)) for n in range(N)]
===============================
[(3.0, 3.0), (4.2, 4.2), (4.680000000000001, 4.68), (4.872000000000001, 4.872), (4.948800000000001, 4.9488), (4.979520000000001, 4.979520000000001), (4.991808000000001, 4.991808), (4.996723200000001, 4.996723200000001), (4.998689280000001, 4.998689280000001), (4.999475712000001, 4.999475712000001), (4.9997902848, 4.9997902848)]

上で書いた Python 式による数値実験は、ぜひとも自分で行ってください。Python で動かしてください。a や r を様々な値に変てみてください。[(sum([a*r**k for k in range(n+1)]), a*(1-r**(n+1))/(1-r)) for n in range(N)] の部分も自分で考えたコードにしてみてください。余裕があるのならば等比数列以外の数列にもチャレンジしてみてください。


ts(); a,r,k,n=ts.symbols('a r k n');         (ts.summation(a*r**k, (k,0,n))          )
===============================
a*(-r**(n + 1) + 1)/(-r + 1)

N=10; [ sum([a r^k for k in range(n+1)]) - a (1-r^(n+1))/(1-r) for (a,r),n in zip(randn(N,2), range(N))]
===============================
[0.0, 0.0, 2.2204460492503131e-16, 0.0, 2.2204460492503131e-16, 3.5527136788005009e-15, -5.5511151231257827e-17, -2.2204460492503131e-16, 0.0, 5.6843418860808015e-14]

さてSn=(a (1-r^(n+1))/(1-r) の公式は、 |r|＜1 のとき n→∞ にすると S∞ = a/(1-r) となります。r^(n+1)→ 0 となるからです。初項 a=3, 公比 r=0.4 のとき、その等比級数は下のようになります。上でも 5 に近づいていく様子が見えます。

a,r=3,0.4;                                      a/(1-r)
===============================
5.0

import sympy as ts; x=ts.symbols('x'); ts.summation(1/ x**2, ( x,1,10))
等比級数

● 循環小数
<ADDRESS>
</ADDRESS>
-->

</BODY>
</HTML>
